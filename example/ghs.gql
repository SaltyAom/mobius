input AbortQueuedMigrationsInput {
  clientMutationId: String
  ownerId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type AbortQueuedMigrationsPayload {
  clientMutationId: String
  success: Boolean
}
input AcceptEnterpriseAdministratorInvitationInput {
  clientMutationId: String
  invitationId: ID! @possibleTypes(concreteTypes: ["EnterpriseAdministratorInvitation"])
}
type AcceptEnterpriseAdministratorInvitationPayload {
  clientMutationId: String
  invitation: EnterpriseAdministratorInvitation
  message: String
}
input AcceptTopicSuggestionInput {
  clientMutationId: String
  name: String!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type AcceptTopicSuggestionPayload {
  clientMutationId: String
  topic: Topic
}
interface Actor {
  avatarUrl(
    size: Int
  ): URI!
  login: String!
  resourcePath: URI!
  url: URI!
}
type ActorLocation {
  city: String
  country: String
  countryCode: String
  region: String
  regionCode: String
}
enum ActorType {
  TEAM
  USER
}
input AddAssigneesToAssignableInput {
  assignableId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "Assignable")
  assigneeIds: [ID!]! @possibleTypes(concreteTypes: ["User"])
  clientMutationId: String
}
type AddAssigneesToAssignablePayload {
  assignable: Assignable
  clientMutationId: String
}
input AddCommentInput {
  body: String!
  clientMutationId: String
  subjectId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "IssueOrPullRequest")
}
type AddCommentPayload {
  clientMutationId: String
  commentEdge: IssueCommentEdge
  subject: Node
  timelineEdge: IssueTimelineItemEdge
}
input AddDiscussionCommentInput {
  body: String!
  clientMutationId: String
  discussionId: ID! @possibleTypes(concreteTypes: ["Discussion"])
  replyToId: ID @possibleTypes(concreteTypes: ["DiscussionComment"])
}
type AddDiscussionCommentPayload {
  clientMutationId: String
  comment: DiscussionComment
}
input AddDiscussionPollVoteInput {
  clientMutationId: String
  pollOptionId: ID! @possibleTypes(concreteTypes: ["DiscussionPollOption"])
}
type AddDiscussionPollVotePayload {
  clientMutationId: String
  pollOption: DiscussionPollOption
}
input AddEnterpriseOrganizationMemberInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
  role: OrganizationMemberRole
  userIds: [ID!]!
}
type AddEnterpriseOrganizationMemberPayload {
  clientMutationId: String
  users: [User!]
}
input AddEnterpriseSupportEntitlementInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  login: String!
}
type AddEnterpriseSupportEntitlementPayload {
  clientMutationId: String
  message: String
}
input AddLabelsToLabelableInput {
  clientMutationId: String
  labelIds: [ID!]! @possibleTypes(concreteTypes: ["Label"])
  labelableId: ID! @possibleTypes(concreteTypes: ["Discussion", "Issue", "PullRequest"], abstractType: "Labelable")
}
type AddLabelsToLabelablePayload {
  clientMutationId: String
  labelable: Labelable
}
input AddProjectCardInput {
  clientMutationId: String
  contentId: ID @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "ProjectCardItem")
  note: String
  projectColumnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type AddProjectCardPayload {
  cardEdge: ProjectCardEdge
  clientMutationId: String
  projectColumn: ProjectColumn
}
input AddProjectColumnInput {
  clientMutationId: String
  name: String!
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
}
type AddProjectColumnPayload {
  clientMutationId: String
  columnEdge: ProjectColumnEdge
  project: Project
}
input AddProjectV2DraftIssueInput {
  assigneeIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  body: String
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
  title: String!
}
type AddProjectV2DraftIssuePayload {
  clientMutationId: String
  projectItem: ProjectV2Item
}
input AddProjectV2ItemByIdInput {
  clientMutationId: String
  contentId: ID!
    @possibleTypes(concreteTypes: ["DraftIssue", "Issue", "PullRequest"], abstractType: "ProjectV2ItemContent")
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
type AddProjectV2ItemByIdPayload {
  clientMutationId: String
  item: ProjectV2Item
}
input AddPullRequestReviewCommentInput {
  body: String
  clientMutationId: String
  commitOID: GitObjectID
  inReplyTo: ID @possibleTypes(concreteTypes: ["PullRequestReviewComment"])
  path: String
  position: Int
  pullRequestId: ID @possibleTypes(concreteTypes: ["PullRequest"])
  pullRequestReviewId: ID @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type AddPullRequestReviewCommentPayload {
  clientMutationId: String
  comment: PullRequestReviewComment
  commentEdge: PullRequestReviewCommentEdge
}
input AddPullRequestReviewInput {
  body: String
  clientMutationId: String
  comments: [DraftPullRequestReviewComment]
  commitOID: GitObjectID
  event: PullRequestReviewEvent
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
  threads: [DraftPullRequestReviewThread]
}
type AddPullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
  reviewEdge: PullRequestReviewEdge
}
input AddPullRequestReviewThreadInput {
  body: String!
  clientMutationId: String
  line: Int
  path: String!
  pullRequestId: ID @possibleTypes(concreteTypes: ["PullRequest"])
  pullRequestReviewId: ID @possibleTypes(concreteTypes: ["PullRequestReview"])
  side: DiffSide = RIGHT
  startLine: Int
  startSide: DiffSide = RIGHT
  subjectType: PullRequestReviewThreadSubjectType = LINE
}
type AddPullRequestReviewThreadPayload {
  clientMutationId: String
  thread: PullRequestReviewThread
}
input AddReactionInput {
  clientMutationId: String
  content: ReactionContent!
  subjectId: ID!
    @possibleTypes(
      concreteTypes: [
        "CommitComment"
        "Discussion"
        "DiscussionComment"
        "Issue"
        "IssueComment"
        "PullRequest"
        "PullRequestReview"
        "PullRequestReviewComment"
        "Release"
        "TeamDiscussion"
        "TeamDiscussionComment"
      ]
      abstractType: "Reactable"
    )
}
type AddReactionPayload {
  clientMutationId: String
  reaction: Reaction
  reactionGroups: [ReactionGroup!]
  subject: Reactable
}
input AddStarInput {
  clientMutationId: String
  starrableId: ID! @possibleTypes(concreteTypes: ["Gist", "Repository", "Topic"], abstractType: "Starrable")
}
type AddStarPayload {
  clientMutationId: String
  starrable: Starrable
}
input AddUpvoteInput {
  clientMutationId: String
  subjectId: ID! @possibleTypes(concreteTypes: ["Discussion", "DiscussionComment"], abstractType: "Votable")
}
type AddUpvotePayload {
  clientMutationId: String
  subject: Votable
}
input AddVerifiableDomainInput {
  clientMutationId: String
  domain: URI!
  ownerId: ID! @possibleTypes(concreteTypes: ["Enterprise", "Organization"], abstractType: "VerifiableDomainOwner")
}
type AddVerifiableDomainPayload {
  clientMutationId: String
  domain: VerifiableDomain
}
type AddedToMergeQueueEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  enqueuer: User
  id: ID!
  mergeQueue: MergeQueue
  pullRequest: PullRequest
}
type AddedToProjectEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  project: Project @preview(toggledBy: "starfox-preview")
  projectCard: ProjectCard @preview(toggledBy: "starfox-preview")
  projectColumnName: String! @preview(toggledBy: "starfox-preview")
}
interface AnnouncementBanner {
  announcement: String
  announcementExpiresAt: DateTime
  announcementUserDismissible: Boolean
}
type App implements Node {
  createdAt: DateTime!
  databaseId: Int
  description: String
  id: ID!
  ipAllowListEntries(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: IpAllowListEntryOrder = {field: ALLOW_LIST_VALUE, direction: ASC}
  ): IpAllowListEntryConnection!
  logoBackgroundColor: String!
  logoUrl(
    size: Int
  ): URI!
  name: String!
  slug: String!
  updatedAt: DateTime!
  url: URI!
}
input ApproveDeploymentsInput {
  clientMutationId: String
  comment: String = ""
  environmentIds: [ID!]!
  workflowRunId: ID! @possibleTypes(concreteTypes: ["WorkflowRun"])
}
type ApproveDeploymentsPayload {
  clientMutationId: String
  deployments: [Deployment!]
}
input ApproveVerifiableDomainInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["VerifiableDomain"])
}
type ApproveVerifiableDomainPayload {
  clientMutationId: String
  domain: VerifiableDomain
}
input ArchiveProjectV2ItemInput {
  clientMutationId: String
  itemId: ID! @possibleTypes(concreteTypes: ["ProjectV2Item"])
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
type ArchiveProjectV2ItemPayload {
  clientMutationId: String
  item: ProjectV2Item
}
input ArchiveRepositoryInput {
  clientMutationId: String
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type ArchiveRepositoryPayload {
  clientMutationId: String
  repository: Repository
}
interface Assignable {
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
}
type AssignedEvent implements Node {
  actor: Actor
  assignable: Assignable!
  assignee: Assignee
  createdAt: DateTime!
  id: ID!
  user: User
    @deprecated(reason: "Assignees can now be mannequins. Use the 'assignee' field instead. Removal on 2020-01-01 UTC.")
}
union Assignee = Bot | Mannequin | Organization | User
interface AuditEntry {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  operationType: OperationType
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
union AuditEntryActor = Bot | Organization | User
input AuditLogOrder {
  direction: OrderDirection
  field: AuditLogOrderField
}
enum AuditLogOrderField {
  CREATED_AT
}
type AutoMergeDisabledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  disabler: User
  id: ID!
  pullRequest: PullRequest
  reason: String
  reasonCode: String
}
type AutoMergeEnabledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  enabler: User
  id: ID!
  pullRequest: PullRequest
}
type AutoMergeRequest {
  authorEmail: String
  commitBody: String
  commitHeadline: String
  enabledAt: DateTime
  enabledBy: Actor
  mergeMethod: PullRequestMergeMethod!
  pullRequest: PullRequest!
}
type AutoRebaseEnabledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  enabler: User
  id: ID!
  pullRequest: PullRequest
}
type AutoSquashEnabledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  enabler: User
  id: ID!
  pullRequest: PullRequest
}
type AutomaticBaseChangeFailedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  newBase: String!
  oldBase: String!
  pullRequest: PullRequest!
}
type AutomaticBaseChangeSucceededEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  newBase: String!
  oldBase: String!
  pullRequest: PullRequest!
}
scalar Base64String
type BaseRefChangedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  currentRefName: String!
  databaseId: Int
  id: ID!
  previousRefName: String!
  pullRequest: PullRequest!
}
type BaseRefDeletedEvent implements Node {
  actor: Actor
  baseRefName: String
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest
}
type BaseRefForcePushedEvent implements Node {
  actor: Actor
  afterCommit: Commit
  beforeCommit: Commit
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  ref: Ref
}
scalar BigInt
type Blame {
  ranges: [BlameRange!]!
}
type BlameRange {
  age: Int!
  commit: Commit!
  endingLine: Int!
  startingLine: Int!
}
type Blob implements GitObject & Node {
  abbreviatedOid: String!
  byteSize: Int!
  commitResourcePath: URI!
  commitUrl: URI!
  id: ID!
  isBinary: Boolean
  isTruncated: Boolean!
  oid: GitObjectID!
  repository: Repository!
  text: String
}
type Bot implements Actor & Node & UniformResourceLocatable {
  avatarUrl(
    size: Int
  ): URI!
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  login: String!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
}
union BranchActorAllowanceActor = App | Team | User
type BranchNamePatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}
input BranchNamePatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}
type BranchProtectionRule implements Node {
  allowsDeletions: Boolean!
  allowsForcePushes: Boolean!
  blocksCreations: Boolean!
  branchProtectionRuleConflicts(
    after: String
    before: String
    first: Int
    last: Int
  ): BranchProtectionRuleConflictConnection!
  bypassForcePushAllowances(
    after: String
    before: String
    first: Int
    last: Int
  ): BypassForcePushAllowanceConnection!
  bypassPullRequestAllowances(
    after: String
    before: String
    first: Int
    last: Int
  ): BypassPullRequestAllowanceConnection!
  creator: Actor
  databaseId: Int
  dismissesStaleReviews: Boolean!
  id: ID!
  isAdminEnforced: Boolean!
  lockAllowsFetchAndMerge: Boolean!
  lockBranch: Boolean!
  matchingRefs(
    after: String
    before: String
    first: Int
    last: Int
    query: String
  ): RefConnection!
  pattern: String!
  pushAllowances(
    after: String
    before: String
    first: Int
    last: Int
  ): PushAllowanceConnection!
  repository: Repository
  requireLastPushApproval: Boolean!
  requiredApprovingReviewCount: Int
  requiredDeploymentEnvironments: [String]
  requiredStatusCheckContexts: [String]
  requiredStatusChecks: [RequiredStatusCheckDescription!]
  requiresApprovingReviews: Boolean!
  requiresCodeOwnerReviews: Boolean!
  requiresCommitSignatures: Boolean!
  requiresConversationResolution: Boolean!
  requiresDeployments: Boolean!
  requiresLinearHistory: Boolean!
  requiresStatusChecks: Boolean!
  requiresStrictStatusChecks: Boolean!
  restrictsPushes: Boolean!
  restrictsReviewDismissals: Boolean!
  reviewDismissalAllowances(
    after: String
    before: String
    first: Int
    last: Int
  ): ReviewDismissalAllowanceConnection!
}
type BranchProtectionRuleConflict {
  branchProtectionRule: BranchProtectionRule
  conflictingBranchProtectionRule: BranchProtectionRule
  ref: Ref
}
type BranchProtectionRuleConflictConnection {
  edges: [BranchProtectionRuleConflictEdge]
  nodes: [BranchProtectionRuleConflict]
  pageInfo: PageInfo!
  totalCount: Int!
}
type BranchProtectionRuleConflictEdge {
  cursor: String!
  node: BranchProtectionRuleConflict
}
type BranchProtectionRuleConnection {
  edges: [BranchProtectionRuleEdge]
  nodes: [BranchProtectionRule]
  pageInfo: PageInfo!
  totalCount: Int!
}
type BranchProtectionRuleEdge {
  cursor: String!
  node: BranchProtectionRule
}
input BulkSponsorship {
  amount: Int!
  sponsorableId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "Sponsorable")
  sponsorableLogin: String
}
union BypassActor = App | Team
type BypassForcePushAllowance implements Node {
  actor: BranchActorAllowanceActor
  branchProtectionRule: BranchProtectionRule
  id: ID!
}
type BypassForcePushAllowanceConnection {
  edges: [BypassForcePushAllowanceEdge]
  nodes: [BypassForcePushAllowance]
  pageInfo: PageInfo!
  totalCount: Int!
}
type BypassForcePushAllowanceEdge {
  cursor: String!
  node: BypassForcePushAllowance
}
type BypassPullRequestAllowance implements Node {
  actor: BranchActorAllowanceActor
  branchProtectionRule: BranchProtectionRule
  id: ID!
}
type BypassPullRequestAllowanceConnection {
  edges: [BypassPullRequestAllowanceEdge]
  nodes: [BypassPullRequestAllowance]
  pageInfo: PageInfo!
  totalCount: Int!
}
type BypassPullRequestAllowanceEdge {
  cursor: String!
  node: BypassPullRequestAllowance
}
type CVSS {
  score: Float!
  vectorString: String
}
type CWE implements Node {
  cweId: String!
  description: String!
  id: ID!
  name: String!
}
type CWEConnection {
  edges: [CWEEdge]
  nodes: [CWE]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CWEEdge {
  cursor: String!
  node: CWE
}
input CancelEnterpriseAdminInvitationInput {
  clientMutationId: String
  invitationId: ID! @possibleTypes(concreteTypes: ["EnterpriseAdministratorInvitation"])
}
type CancelEnterpriseAdminInvitationPayload {
  clientMutationId: String
  invitation: EnterpriseAdministratorInvitation
  message: String
}
input CancelSponsorshipInput {
  clientMutationId: String
  sponsorId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "Sponsor")
  sponsorLogin: String
  sponsorableId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "Sponsorable")
  sponsorableLogin: String
}
type CancelSponsorshipPayload {
  clientMutationId: String
  sponsorsTier: SponsorsTier
}
input ChangeUserStatusInput {
  clientMutationId: String
  emoji: String
  expiresAt: DateTime
  limitedAvailability: Boolean = false
  message: String
  organizationId: ID @possibleTypes(concreteTypes: ["Organization"])
}
type ChangeUserStatusPayload {
  clientMutationId: String
  status: UserStatus
}
type CheckAnnotation {
  annotationLevel: CheckAnnotationLevel
  blobUrl: URI!
  databaseId: Int
  location: CheckAnnotationSpan!
  message: String!
  path: String!
  rawDetails: String
  title: String
}
type CheckAnnotationConnection {
  edges: [CheckAnnotationEdge]
  nodes: [CheckAnnotation]
  pageInfo: PageInfo!
  totalCount: Int!
}
input CheckAnnotationData {
  annotationLevel: CheckAnnotationLevel!
  location: CheckAnnotationRange!
  message: String!
  path: String!
  rawDetails: String
  title: String
}
type CheckAnnotationEdge {
  cursor: String!
  node: CheckAnnotation
}
enum CheckAnnotationLevel {
  FAILURE
  NOTICE
  WARNING
}
type CheckAnnotationPosition {
  column: Int
  line: Int!
}
input CheckAnnotationRange {
  endColumn: Int
  endLine: Int!
  startColumn: Int
  startLine: Int!
}
type CheckAnnotationSpan {
  end: CheckAnnotationPosition!
  start: CheckAnnotationPosition!
}
enum CheckConclusionState {
  ACTION_REQUIRED
  CANCELLED
  FAILURE
  NEUTRAL
  SKIPPED
  STALE
  STARTUP_FAILURE
  SUCCESS
  TIMED_OUT
}
type CheckRun implements Node & RequirableByPullRequest & UniformResourceLocatable {
  annotations(
    after: String
    before: String
    first: Int
    last: Int
  ): CheckAnnotationConnection
  checkSuite: CheckSuite!
  completedAt: DateTime
  conclusion: CheckConclusionState
  databaseId: Int
  deployment: Deployment
  detailsUrl: URI
  externalId: String
  id: ID!
  isRequired(
    pullRequestId: ID
    pullRequestNumber: Int
  ): Boolean!
  name: String!
  pendingDeploymentRequest: DeploymentRequest
  permalink: URI!
  repository: Repository!
  resourcePath: URI!
  startedAt: DateTime
  status: CheckStatusState!
  steps(
    after: String
    before: String
    first: Int
    last: Int
    number: Int
  ): CheckStepConnection
  summary: String
  text: String
  title: String
  url: URI!
}
input CheckRunAction {
  description: String!
  identifier: String!
  label: String!
}
type CheckRunConnection {
  edges: [CheckRunEdge]
  nodes: [CheckRun]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CheckRunEdge {
  cursor: String!
  node: CheckRun
}
input CheckRunFilter {
  appId: Int
  checkName: String
  checkType: CheckRunType
  conclusions: [CheckConclusionState!]
  status: CheckStatusState
  statuses: [CheckStatusState!]
}
input CheckRunOutput {
  annotations: [CheckAnnotationData!]
  images: [CheckRunOutputImage!]
  summary: String!
  text: String
  title: String!
}
input CheckRunOutputImage {
  alt: String!
  caption: String
  imageUrl: URI!
}
enum CheckRunState {
  ACTION_REQUIRED
  CANCELLED
  COMPLETED
  FAILURE
  IN_PROGRESS
  NEUTRAL
  PENDING
  QUEUED
  SKIPPED
  STALE
  STARTUP_FAILURE
  SUCCESS
  TIMED_OUT
  WAITING
}
type CheckRunStateCount {
  count: Int!
  state: CheckRunState!
}
enum CheckRunType {
  ALL
  LATEST
}
enum CheckStatusState {
  COMPLETED
  IN_PROGRESS
  PENDING
  QUEUED
  REQUESTED
  WAITING
}
type CheckStep {
  completedAt: DateTime
  conclusion: CheckConclusionState
  externalId: String
  name: String!
  number: Int!
  secondsToCompletion: Int
  startedAt: DateTime
  status: CheckStatusState!
}
type CheckStepConnection {
  edges: [CheckStepEdge]
  nodes: [CheckStep]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CheckStepEdge {
  cursor: String!
  node: CheckStep
}
type CheckSuite implements Node {
  app: App
  branch: Ref
  checkRuns(
    after: String
    before: String
    filterBy: CheckRunFilter
    first: Int
    last: Int
  ): CheckRunConnection
  commit: Commit!
  conclusion: CheckConclusionState
  createdAt: DateTime!
  creator: User
  databaseId: Int
  id: ID!
  matchingPullRequests(
    after: String
    baseRefName: String
    before: String
    first: Int
    headRefName: String
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [PullRequestState!]
  ): PullRequestConnection
  push: Push
  repository: Repository!
  resourcePath: URI!
  status: CheckStatusState!
  updatedAt: DateTime!
  url: URI!
  workflowRun: WorkflowRun
}
input CheckSuiteAutoTriggerPreference {
  appId: ID!
  setting: Boolean!
}
type CheckSuiteConnection {
  edges: [CheckSuiteEdge]
  nodes: [CheckSuite]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CheckSuiteEdge {
  cursor: String!
  node: CheckSuite
}
input CheckSuiteFilter {
  appId: Int
  checkName: String
}
union Claimable = Mannequin | User
input ClearLabelsFromLabelableInput {
  clientMutationId: String
  labelableId: ID! @possibleTypes(concreteTypes: ["Discussion", "Issue", "PullRequest"], abstractType: "Labelable")
}
type ClearLabelsFromLabelablePayload {
  clientMutationId: String
  labelable: Labelable
}
input ClearProjectV2ItemFieldValueInput {
  clientMutationId: String
  fieldId: ID!
    @possibleTypes(
      concreteTypes: ["ProjectV2Field", "ProjectV2IterationField", "ProjectV2SingleSelectField"]
      abstractType: "ProjectV2FieldConfiguration"
    )
  itemId: ID! @possibleTypes(concreteTypes: ["ProjectV2Item"])
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
type ClearProjectV2ItemFieldValuePayload {
  clientMutationId: String
  projectV2Item: ProjectV2Item
}
input CloneProjectInput {
  body: String
  clientMutationId: String
  includeWorkflows: Boolean!
  name: String!
  public: Boolean
  sourceId: ID! @possibleTypes(concreteTypes: ["Project"])
  targetOwnerId: ID! @possibleTypes(concreteTypes: ["Organization", "Repository", "User"], abstractType: "ProjectOwner")
}
type CloneProjectPayload {
  clientMutationId: String
  jobStatusId: String
  project: Project
}
input CloneTemplateRepositoryInput {
  clientMutationId: String
  description: String
  includeAllBranches: Boolean = false
  name: String!
  ownerId: ID! @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "RepositoryOwner")
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  visibility: RepositoryVisibility!
}
type CloneTemplateRepositoryPayload {
  clientMutationId: String
  repository: Repository
}
interface Closable {
  closed: Boolean!
  closedAt: DateTime
  viewerCanClose: Boolean!
  viewerCanReopen: Boolean!
}
input CloseDiscussionInput {
  clientMutationId: String
  discussionId: ID! @possibleTypes(concreteTypes: ["Discussion"])
  reason: DiscussionCloseReason = RESOLVED
}
type CloseDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}
input CloseIssueInput {
  clientMutationId: String
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
  stateReason: IssueClosedStateReason
}
type CloseIssuePayload {
  clientMutationId: String
  issue: Issue
}
input ClosePullRequestInput {
  clientMutationId: String
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type ClosePullRequestPayload {
  clientMutationId: String
  pullRequest: PullRequest
}
type ClosedEvent implements Node & UniformResourceLocatable {
  actor: Actor
  closable: Closable!
  closer: Closer
  createdAt: DateTime!
  id: ID!
  resourcePath: URI!
  stateReason: IssueStateReason
  url: URI!
}
union Closer = Commit | PullRequest
type CodeOfConduct implements Node {
  body: String
  id: ID!
  key: String!
  name: String!
  resourcePath: URI
  url: URI
}
enum CollaboratorAffiliation {
  ALL
  DIRECT
  OUTSIDE
}
interface Comment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  lastEditedAt: DateTime
  publishedAt: DateTime
  updatedAt: DateTime!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerDidAuthor: Boolean!
}
enum CommentAuthorAssociation {
  COLLABORATOR
  CONTRIBUTOR
  FIRST_TIMER
  FIRST_TIME_CONTRIBUTOR
  MANNEQUIN
  MEMBER
  NONE
  OWNER
}
enum CommentCannotUpdateReason {
  ARCHIVED
  DENIED
  INSUFFICIENT_ACCESS
  LOCKED
  LOGIN_REQUIRED
  MAINTENANCE
  VERIFIED_EMAIL_REQUIRED
}
type CommentDeletedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  deletedCommentAuthor: Actor
  id: ID!
}
type Commit implements GitObject & Node & Subscribable & UniformResourceLocatable {
  abbreviatedOid: String!
  additions: Int!
  associatedPullRequests(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PullRequestOrder = {field: CREATED_AT, direction: ASC}
  ): PullRequestConnection
  author: GitActor
  authoredByCommitter: Boolean!
  authoredDate: DateTime!
  authors(
    after: String
    before: String
    first: Int
    last: Int
  ): GitActorConnection!
  blame(
    path: String!
  ): Blame!
  changedFiles: Int!
    @deprecated(
      reason: "'changedFiles' will be removed. Use 'changedFilesIfAvailable' instead. Removal on 2023-01-01 UTC."
    )
  changedFilesIfAvailable: Int
  checkSuites(
    after: String
    before: String
    filterBy: CheckSuiteFilter
    first: Int
    last: Int
  ): CheckSuiteConnection
  comments(
    after: String
    before: String
    first: Int
    last: Int
  ): CommitCommentConnection!
  commitResourcePath: URI!
  commitUrl: URI!
  committedDate: DateTime!
  committedViaWeb: Boolean!
  committer: GitActor
  deletions: Int!
  deployments(
    after: String
    before: String
    environments: [String!]
    first: Int
    last: Int
    orderBy: DeploymentOrder = {field: CREATED_AT, direction: ASC}
  ): DeploymentConnection
  file(
    path: String!
  ): TreeEntry
  history(
    after: String
    author: CommitAuthor
    before: String
    first: Int
    last: Int
    path: String
    since: GitTimestamp
    until: GitTimestamp
  ): CommitHistoryConnection!
  id: ID!
  message: String!
  messageBody: String!
  messageBodyHTML: HTML!
  messageHeadline: String!
  messageHeadlineHTML: HTML!
  oid: GitObjectID!
  onBehalfOf: Organization
  parents(
    after: String
    before: String
    first: Int
    last: Int
  ): CommitConnection!
  pushedDate: DateTime @deprecated(reason: "'pushedDate' is no longer supported. Removal on 2023-07-01 UTC.")
  repository: Repository!
  resourcePath: URI!
  signature: GitSignature
  status: Status
  statusCheckRollup: StatusCheckRollup
  submodules(
    after: String
    before: String
    first: Int
    last: Int
  ): SubmoduleConnection!
  tarballUrl: URI!
  tree: Tree!
  treeResourcePath: URI!
  treeUrl: URI!
  url: URI!
  viewerCanSubscribe: Boolean!
  viewerSubscription: SubscriptionState
  zipballUrl: URI!
}
input CommitAuthor {
  emails: [String!]
  id: ID
}
type CommitAuthorEmailPatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}
input CommitAuthorEmailPatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}
type CommitComment implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  commit: Commit
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  isMinimized: Boolean!
  lastEditedAt: DateTime
  minimizedReason: String
  path: String
  position: Int
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}
type CommitCommentConnection {
  edges: [CommitCommentEdge]
  nodes: [CommitComment]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CommitCommentEdge {
  cursor: String!
  node: CommitComment
}
type CommitCommentThread implements Node & RepositoryNode {
  comments(
    after: String
    before: String
    first: Int
    last: Int
  ): CommitCommentConnection!
  commit: Commit
  id: ID!
  path: String
  position: Int
  repository: Repository!
}
type CommitConnection {
  edges: [CommitEdge]
  nodes: [Commit]
  pageInfo: PageInfo!
  totalCount: Int!
}
input CommitContributionOrder {
  direction: OrderDirection!
  field: CommitContributionOrderField!
}
enum CommitContributionOrderField {
  COMMIT_COUNT
  OCCURRED_AT
}
type CommitContributionsByRepository {
  contributions(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: CommitContributionOrder = {field: OCCURRED_AT, direction: DESC}
  ): CreatedCommitContributionConnection!
  repository: Repository!
  resourcePath: URI!
  url: URI!
}
type CommitEdge {
  cursor: String!
  node: Commit
}
type CommitHistoryConnection {
  edges: [CommitEdge]
  nodes: [Commit]
  pageInfo: PageInfo!
  totalCount: Int!
}
input CommitMessage {
  body: String
  headline: String!
}
type CommitMessagePatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}
input CommitMessagePatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}
input CommittableBranch {
  branchName: String
  id: ID
  repositoryNameWithOwner: String
}
type CommitterEmailPatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}
input CommitterEmailPatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}
type Comparison implements Node {
  aheadBy: Int!
  baseTarget: GitObject!
  behindBy: Int!
  commits(
    after: String
    before: String
    first: Int
    last: Int
  ): ComparisonCommitConnection!
  headTarget: GitObject!
  id: ID!
  status: ComparisonStatus!
}
type ComparisonCommitConnection {
  authorCount: Int!
  edges: [CommitEdge]
  nodes: [Commit]
  pageInfo: PageInfo!
  totalCount: Int!
}
enum ComparisonStatus {
  AHEAD
  BEHIND
  DIVERGED
  IDENTICAL
}
type ConnectedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  isCrossRepository: Boolean!
  source: ReferencedSubject!
  subject: ReferencedSubject!
}
interface Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  resourcePath: URI!
  url: URI!
  user: User!
}
type ContributionCalendar {
  colors: [String!]!
  isHalloween: Boolean!
  months: [ContributionCalendarMonth!]!
  totalContributions: Int!
  weeks: [ContributionCalendarWeek!]!
}
type ContributionCalendarDay {
  color: String!
  contributionCount: Int!
  contributionLevel: ContributionLevel!
  date: Date!
  weekday: Int!
}
type ContributionCalendarMonth {
  firstDay: Date!
  name: String!
  totalWeeks: Int!
  year: Int!
}
type ContributionCalendarWeek {
  contributionDays: [ContributionCalendarDay!]!
  firstDay: Date!
}
enum ContributionLevel {
  FIRST_QUARTILE
  FOURTH_QUARTILE
  NONE
  SECOND_QUARTILE
  THIRD_QUARTILE
}
input ContributionOrder {
  direction: OrderDirection!
}
type ContributionsCollection {
  commitContributionsByRepository(
    maxRepositories: Int = 25
  ): [CommitContributionsByRepository!]!
  contributionCalendar: ContributionCalendar!
  contributionYears: [Int!]!
  doesEndInCurrentMonth: Boolean!
  earliestRestrictedContributionDate: Date
  endedAt: DateTime!
  firstIssueContribution: CreatedIssueOrRestrictedContribution
  firstPullRequestContribution: CreatedPullRequestOrRestrictedContribution
  firstRepositoryContribution: CreatedRepositoryOrRestrictedContribution
  hasActivityInThePast: Boolean!
  hasAnyContributions: Boolean!
  hasAnyRestrictedContributions: Boolean!
  isSingleDay: Boolean!
  issueContributions(
    after: String
    before: String
    excludeFirst: Boolean = false
    excludePopular: Boolean = false
    first: Int
    last: Int
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedIssueContributionConnection!
  issueContributionsByRepository(
    excludeFirst: Boolean = false
    excludePopular: Boolean = false
    maxRepositories: Int = 25
  ): [IssueContributionsByRepository!]!
  joinedGitHubContribution: JoinedGitHubContribution
  latestRestrictedContributionDate: Date
  mostRecentCollectionWithActivity: ContributionsCollection
  mostRecentCollectionWithoutActivity: ContributionsCollection
  popularIssueContribution: CreatedIssueContribution
  popularPullRequestContribution: CreatedPullRequestContribution
  pullRequestContributions(
    after: String
    before: String
    excludeFirst: Boolean = false
    excludePopular: Boolean = false
    first: Int
    last: Int
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedPullRequestContributionConnection!
  pullRequestContributionsByRepository(
    excludeFirst: Boolean = false
    excludePopular: Boolean = false
    maxRepositories: Int = 25
  ): [PullRequestContributionsByRepository!]!
  pullRequestReviewContributions(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedPullRequestReviewContributionConnection!
  pullRequestReviewContributionsByRepository(
    maxRepositories: Int = 25
  ): [PullRequestReviewContributionsByRepository!]!
  repositoryContributions(
    after: String
    before: String
    excludeFirst: Boolean = false
    first: Int
    last: Int
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedRepositoryContributionConnection!
  restrictedContributionsCount: Int!
  startedAt: DateTime!
  totalCommitContributions: Int!
  totalIssueContributions(
    excludeFirst: Boolean = false
    excludePopular: Boolean = false
  ): Int!
  totalPullRequestContributions(
    excludeFirst: Boolean = false
    excludePopular: Boolean = false
  ): Int!
  totalPullRequestReviewContributions: Int!
  totalRepositoriesWithContributedCommits: Int!
  totalRepositoriesWithContributedIssues(
    excludeFirst: Boolean = false
    excludePopular: Boolean = false
  ): Int!
  totalRepositoriesWithContributedPullRequestReviews: Int!
  totalRepositoriesWithContributedPullRequests(
    excludeFirst: Boolean = false
    excludePopular: Boolean = false
  ): Int!
  totalRepositoryContributions(
    excludeFirst: Boolean = false
  ): Int!
  user: User!
}
input ConvertProjectCardNoteToIssueInput {
  body: String
  clientMutationId: String
  projectCardId: ID! @possibleTypes(concreteTypes: ["ProjectCard"])
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  title: String
}
type ConvertProjectCardNoteToIssuePayload {
  clientMutationId: String
  projectCard: ProjectCard
}
input ConvertPullRequestToDraftInput {
  clientMutationId: String
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type ConvertPullRequestToDraftPayload {
  clientMutationId: String
  pullRequest: PullRequest
}
type ConvertToDraftEvent implements Node & UniformResourceLocatable {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
}
type ConvertedNoteToIssueEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  project: Project @preview(toggledBy: "starfox-preview")
  projectCard: ProjectCard @preview(toggledBy: "starfox-preview")
  projectColumnName: String! @preview(toggledBy: "starfox-preview")
}
type ConvertedToDiscussionEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  discussion: Discussion
  id: ID!
}
input CopyProjectV2Input {
  clientMutationId: String
  includeDraftIssues: Boolean = false
  ownerId: ID! @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "OrganizationOrUser")
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
  title: String!
}
type CopyProjectV2Payload {
  clientMutationId: String
  projectV2: ProjectV2
}
input CreateAttributionInvitationInput {
  clientMutationId: String
  ownerId: ID! @possibleTypes(concreteTypes: ["Bot", "Enterprise", "Mannequin", "Organization", "User"])
  sourceId: ID! @possibleTypes(concreteTypes: ["Bot", "Enterprise", "Mannequin", "Organization", "User"])
  targetId: ID! @possibleTypes(concreteTypes: ["Bot", "Enterprise", "Mannequin", "Organization", "User"])
}
type CreateAttributionInvitationPayload {
  clientMutationId: String
  owner: Organization
  source: Claimable
  target: Claimable
}
input CreateBranchProtectionRuleInput {
  allowsDeletions: Boolean
  allowsForcePushes: Boolean
  blocksCreations: Boolean
  bypassForcePushActorIds: [ID!]
  bypassPullRequestActorIds: [ID!]
  clientMutationId: String
  dismissesStaleReviews: Boolean
  isAdminEnforced: Boolean
  lockAllowsFetchAndMerge: Boolean
  lockBranch: Boolean
  pattern: String!
  pushActorIds: [ID!]
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  requireLastPushApproval: Boolean
  requiredApprovingReviewCount: Int
  requiredDeploymentEnvironments: [String!]
  requiredStatusCheckContexts: [String!]
  requiredStatusChecks: [RequiredStatusCheckInput!]
  requiresApprovingReviews: Boolean
  requiresCodeOwnerReviews: Boolean
  requiresCommitSignatures: Boolean
  requiresConversationResolution: Boolean
  requiresDeployments: Boolean
  requiresLinearHistory: Boolean
  requiresStatusChecks: Boolean
  requiresStrictStatusChecks: Boolean
  restrictsPushes: Boolean
  restrictsReviewDismissals: Boolean
  reviewDismissalActorIds: [ID!]
}
type CreateBranchProtectionRulePayload {
  branchProtectionRule: BranchProtectionRule
  clientMutationId: String
}
input CreateCheckRunInput {
  actions: [CheckRunAction!]
  clientMutationId: String
  completedAt: DateTime
  conclusion: CheckConclusionState
  detailsUrl: URI
  externalId: String
  headSha: GitObjectID!
  name: String!
  output: CheckRunOutput
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  startedAt: DateTime
  status: RequestableCheckStatusState
}
type CreateCheckRunPayload {
  checkRun: CheckRun
  clientMutationId: String
}
input CreateCheckSuiteInput {
  clientMutationId: String
  headSha: GitObjectID!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type CreateCheckSuitePayload {
  checkSuite: CheckSuite
  clientMutationId: String
}
input CreateCommitOnBranchInput {
  branch: CommittableBranch!
  clientMutationId: String
  expectedHeadOid: GitObjectID!
  fileChanges: FileChanges
  message: CommitMessage!
}
type CreateCommitOnBranchPayload {
  clientMutationId: String
  commit: Commit
  ref: Ref
}
input CreateDeploymentInput @preview(toggledBy: "flash-preview") {
  autoMerge: Boolean = true
  clientMutationId: String
  description: String = ""
  environment: String = "production"
  payload: String = "{}"
  refId: ID! @possibleTypes(concreteTypes: ["Ref"])
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  requiredContexts: [String!]
  task: String = "deploy"
}
type CreateDeploymentPayload @preview(toggledBy: "flash-preview") {
  autoMerged: Boolean
  clientMutationId: String
  deployment: Deployment
}
input CreateDeploymentStatusInput @preview(toggledBy: "flash-preview") {
  autoInactive: Boolean = true
  clientMutationId: String
  deploymentId: ID! @possibleTypes(concreteTypes: ["Deployment"])
  description: String = ""
  environment: String
  environmentUrl: String = ""
  logUrl: String = ""
  state: DeploymentStatusState!
}
type CreateDeploymentStatusPayload @preview(toggledBy: "flash-preview") {
  clientMutationId: String
  deploymentStatus: DeploymentStatus
}
input CreateDiscussionInput {
  body: String!
  categoryId: ID! @possibleTypes(concreteTypes: ["DiscussionCategory"])
  clientMutationId: String
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  title: String!
}
type CreateDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}
input CreateEnterpriseOrganizationInput {
  adminLogins: [String!]!
  billingEmail: String!
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  login: String!
  profileName: String!
}
type CreateEnterpriseOrganizationPayload {
  clientMutationId: String
  enterprise: Enterprise
  organization: Organization
}
input CreateEnvironmentInput {
  clientMutationId: String
  name: String!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type CreateEnvironmentPayload {
  clientMutationId: String
  environment: Environment
}
input CreateIpAllowListEntryInput {
  allowListValue: String!
  clientMutationId: String
  isActive: Boolean!
  name: String
  ownerId: ID! @possibleTypes(concreteTypes: ["App", "Enterprise", "Organization"], abstractType: "IpAllowListOwner")
}
type CreateIpAllowListEntryPayload {
  clientMutationId: String
  ipAllowListEntry: IpAllowListEntry
}
input CreateIssueInput {
  assigneeIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  body: String
  clientMutationId: String
  issueTemplate: String
  labelIds: [ID!] @possibleTypes(concreteTypes: ["Label"])
  milestoneId: ID @possibleTypes(concreteTypes: ["Milestone"])
  projectIds: [ID!] @possibleTypes(concreteTypes: ["Project"])
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  title: String!
}
type CreateIssuePayload {
  clientMutationId: String
  issue: Issue
}
input CreateLabelInput @preview(toggledBy: "bane-preview") {
  clientMutationId: String
  color: String!
  description: String
  name: String!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type CreateLabelPayload @preview(toggledBy: "bane-preview") {
  clientMutationId: String
  label: Label
}
input CreateLinkedBranchInput {
  clientMutationId: String
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
  name: String
  oid: GitObjectID!
  repositoryId: ID @possibleTypes(concreteTypes: ["Repository"])
}
type CreateLinkedBranchPayload {
  clientMutationId: String
  linkedBranch: LinkedBranch
}
input CreateMigrationSourceInput {
  accessToken: String
  clientMutationId: String
  githubPat: String
  name: String!
  ownerId: ID! @possibleTypes(concreteTypes: ["Organization"])
  type: MigrationSourceType!
  url: String
}
type CreateMigrationSourcePayload {
  clientMutationId: String
  migrationSource: MigrationSource
}
input CreateProjectInput {
  body: String
  clientMutationId: String
  name: String!
  ownerId: ID! @possibleTypes(concreteTypes: ["Organization", "Repository", "User"], abstractType: "ProjectOwner")
  repositoryIds: [ID!] @possibleTypes(concreteTypes: ["Repository"])
  template: ProjectTemplate
}
type CreateProjectPayload {
  clientMutationId: String
  project: Project
}
input CreateProjectV2FieldInput {
  clientMutationId: String
  dataType: ProjectV2CustomFieldType!
  name: String!
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
  singleSelectOptions: [ProjectV2SingleSelectFieldOptionInput!]
}
type CreateProjectV2FieldPayload {
  clientMutationId: String
  projectV2Field: ProjectV2FieldConfiguration
}
input CreateProjectV2Input {
  clientMutationId: String
  ownerId: ID! @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "OrganizationOrUser")
  repositoryId: ID @possibleTypes(concreteTypes: ["Repository"])
  teamId: ID @possibleTypes(concreteTypes: ["Team"])
  title: String!
}
type CreateProjectV2Payload {
  clientMutationId: String
  projectV2: ProjectV2
}
input CreatePullRequestInput {
  baseRefName: String!
  body: String
  clientMutationId: String
  draft: Boolean = false
  headRefName: String!
  headRepositoryId: ID @possibleTypes(concreteTypes: ["Repository"])
  maintainerCanModify: Boolean = true
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  title: String!
}
type CreatePullRequestPayload {
  clientMutationId: String
  pullRequest: PullRequest
}
input CreateRefInput {
  clientMutationId: String
  name: String!
  oid: GitObjectID!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type CreateRefPayload {
  clientMutationId: String
  ref: Ref
}
input CreateRepositoryInput {
  clientMutationId: String
  description: String
  hasIssuesEnabled: Boolean = true
  hasWikiEnabled: Boolean = false
  homepageUrl: URI
  name: String!
  ownerId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "RepositoryOwner")
  teamId: ID @possibleTypes(concreteTypes: ["Team"])
  template: Boolean = false
  visibility: RepositoryVisibility!
}
type CreateRepositoryPayload {
  clientMutationId: String
  repository: Repository
}
input CreateRepositoryRulesetInput {
  bypassActors: [RepositoryRulesetBypassActorInput!]
  clientMutationId: String
  conditions: RepositoryRuleConditionsInput!
  enforcement: RuleEnforcement!
  name: String!
  rules: [RepositoryRuleInput!]
  sourceId: ID! @possibleTypes(concreteTypes: ["Organization", "Repository"], abstractType: "RuleSource")
  target: RepositoryRulesetTarget
}
type CreateRepositoryRulesetPayload {
  clientMutationId: String
  ruleset: RepositoryRuleset
}
input CreateSponsorsListingInput {
  billingCountryOrRegionCode: SponsorsCountryOrRegionCode
  clientMutationId: String
  contactEmail: String
  fiscalHostLogin: String
  fiscallyHostedProjectProfileUrl: String
  fullDescription: String
  residenceCountryOrRegionCode: SponsorsCountryOrRegionCode
  sponsorableLogin: String
}
type CreateSponsorsListingPayload {
  clientMutationId: String
  sponsorsListing: SponsorsListing
}
input CreateSponsorsTierInput {
  amount: Int!
  clientMutationId: String
  description: String!
  isRecurring: Boolean = true
  publish: Boolean = false
  repositoryId: ID @possibleTypes(concreteTypes: ["Repository"])
  repositoryName: String
  repositoryOwnerLogin: String
  sponsorableId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "Sponsorable")
  sponsorableLogin: String
  welcomeMessage: String
}
type CreateSponsorsTierPayload {
  clientMutationId: String
  sponsorsTier: SponsorsTier
}
input CreateSponsorshipInput {
  amount: Int
  clientMutationId: String
  isRecurring: Boolean
  privacyLevel: SponsorshipPrivacy = PUBLIC
  receiveEmails: Boolean = true
  sponsorId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "Sponsor")
  sponsorLogin: String
  sponsorableId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "Sponsorable")
  sponsorableLogin: String
  tierId: ID @possibleTypes(concreteTypes: ["SponsorsTier"])
}
type CreateSponsorshipPayload {
  clientMutationId: String
  sponsorship: Sponsorship
}
input CreateSponsorshipsInput {
  clientMutationId: String
  privacyLevel: SponsorshipPrivacy = PUBLIC
  receiveEmails: Boolean = false
  sponsorLogin: String!
  sponsorships: [BulkSponsorship!]!
}
type CreateSponsorshipsPayload {
  clientMutationId: String
  sponsorables: [Sponsorable!]
}
input CreateTeamDiscussionCommentInput {
  body: String
  clientMutationId: String
  discussionId: ID @possibleTypes(concreteTypes: ["TeamDiscussion"])
}
type CreateTeamDiscussionCommentPayload {
  clientMutationId: String
  teamDiscussionComment: TeamDiscussionComment
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
}
input CreateTeamDiscussionInput {
  body: String
  clientMutationId: String
  private: Boolean
  teamId: ID @possibleTypes(concreteTypes: ["Team"])
  title: String
}
type CreateTeamDiscussionPayload {
  clientMutationId: String
  teamDiscussion: TeamDiscussion
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
}
type CreatedCommitContribution implements Contribution {
  commitCount: Int!
  isRestricted: Boolean!
  occurredAt: DateTime!
  repository: Repository!
  resourcePath: URI!
  url: URI!
  user: User!
}
type CreatedCommitContributionConnection {
  edges: [CreatedCommitContributionEdge]
  nodes: [CreatedCommitContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CreatedCommitContributionEdge {
  cursor: String!
  node: CreatedCommitContribution
}
type CreatedIssueContribution implements Contribution {
  isRestricted: Boolean!
  issue: Issue!
  occurredAt: DateTime!
  resourcePath: URI!
  url: URI!
  user: User!
}
type CreatedIssueContributionConnection {
  edges: [CreatedIssueContributionEdge]
  nodes: [CreatedIssueContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CreatedIssueContributionEdge {
  cursor: String!
  node: CreatedIssueContribution
}
union CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution
type CreatedPullRequestContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
  user: User!
}
type CreatedPullRequestContributionConnection {
  edges: [CreatedPullRequestContributionEdge]
  nodes: [CreatedPullRequestContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CreatedPullRequestContributionEdge {
  cursor: String!
  node: CreatedPullRequestContribution
}
union CreatedPullRequestOrRestrictedContribution = CreatedPullRequestContribution | RestrictedContribution
type CreatedPullRequestReviewContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  pullRequest: PullRequest!
  pullRequestReview: PullRequestReview!
  repository: Repository!
  resourcePath: URI!
  url: URI!
  user: User!
}
type CreatedPullRequestReviewContributionConnection {
  edges: [CreatedPullRequestReviewContributionEdge]
  nodes: [CreatedPullRequestReviewContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CreatedPullRequestReviewContributionEdge {
  cursor: String!
  node: CreatedPullRequestReviewContribution
}
type CreatedRepositoryContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  repository: Repository!
  resourcePath: URI!
  url: URI!
  user: User!
}
type CreatedRepositoryContributionConnection {
  edges: [CreatedRepositoryContributionEdge]
  nodes: [CreatedRepositoryContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}
type CreatedRepositoryContributionEdge {
  cursor: String!
  node: CreatedRepositoryContribution
}
union CreatedRepositoryOrRestrictedContribution = CreatedRepositoryContribution | RestrictedContribution
type CrossReferencedEvent implements Node & UniformResourceLocatable {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  isCrossRepository: Boolean!
  referencedAt: DateTime!
  resourcePath: URI!
  source: ReferencedSubject!
  target: ReferencedSubject!
  url: URI!
  willCloseTarget: Boolean!
}
scalar Date
scalar DateTime
input DeclineTopicSuggestionInput {
  clientMutationId: String
  name: String!
  reason: TopicSuggestionDeclineReason!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type DeclineTopicSuggestionPayload {
  clientMutationId: String
  topic: Topic
}
enum DefaultRepositoryPermissionField {
  ADMIN
  NONE
  READ
  WRITE
}
interface Deletable {
  viewerCanDelete: Boolean!
}
input DeleteBranchProtectionRuleInput {
  branchProtectionRuleId: ID! @possibleTypes(concreteTypes: ["BranchProtectionRule"])
  clientMutationId: String
}
type DeleteBranchProtectionRulePayload {
  clientMutationId: String
}
input DeleteDeploymentInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["Deployment"])
}
type DeleteDeploymentPayload {
  clientMutationId: String
}
input DeleteDiscussionCommentInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["DiscussionComment"])
}
type DeleteDiscussionCommentPayload {
  clientMutationId: String
  comment: DiscussionComment
}
input DeleteDiscussionInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["Discussion"])
}
type DeleteDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}
input DeleteEnvironmentInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["Environment"])
}
type DeleteEnvironmentPayload {
  clientMutationId: String
}
input DeleteIpAllowListEntryInput {
  clientMutationId: String
  ipAllowListEntryId: ID! @possibleTypes(concreteTypes: ["IpAllowListEntry"])
}
type DeleteIpAllowListEntryPayload {
  clientMutationId: String
  ipAllowListEntry: IpAllowListEntry
}
input DeleteIssueCommentInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["IssueComment"])
}
type DeleteIssueCommentPayload {
  clientMutationId: String
}
input DeleteIssueInput {
  clientMutationId: String
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
}
type DeleteIssuePayload {
  clientMutationId: String
  repository: Repository
}
input DeleteLabelInput @preview(toggledBy: "bane-preview") {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["Label"])
}
type DeleteLabelPayload @preview(toggledBy: "bane-preview") {
  clientMutationId: String
}
input DeleteLinkedBranchInput {
  clientMutationId: String
  linkedBranchId: ID! @possibleTypes(concreteTypes: ["LinkedBranch"])
}
type DeleteLinkedBranchPayload {
  clientMutationId: String
  issue: Issue
}
input DeletePackageVersionInput {
  clientMutationId: String
  packageVersionId: ID! @possibleTypes(concreteTypes: ["PackageVersion"])
}
type DeletePackageVersionPayload {
  clientMutationId: String
  success: Boolean
}
input DeleteProjectCardInput {
  cardId: ID! @possibleTypes(concreteTypes: ["ProjectCard"])
  clientMutationId: String
}
type DeleteProjectCardPayload {
  clientMutationId: String
  column: ProjectColumn
  deletedCardId: ID
}
input DeleteProjectColumnInput {
  clientMutationId: String
  columnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type DeleteProjectColumnPayload {
  clientMutationId: String
  deletedColumnId: ID
  project: Project
}
input DeleteProjectInput {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
}
type DeleteProjectPayload {
  clientMutationId: String
  owner: ProjectOwner
}
input DeleteProjectV2FieldInput {
  clientMutationId: String
  fieldId: ID!
    @possibleTypes(
      concreteTypes: ["ProjectV2Field", "ProjectV2IterationField", "ProjectV2SingleSelectField"]
      abstractType: "ProjectV2FieldConfiguration"
    )
}
type DeleteProjectV2FieldPayload {
  clientMutationId: String
  projectV2Field: ProjectV2FieldConfiguration
}
input DeleteProjectV2Input {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
input DeleteProjectV2ItemInput {
  clientMutationId: String
  itemId: ID! @possibleTypes(concreteTypes: ["ProjectV2Item"])
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
type DeleteProjectV2ItemPayload {
  clientMutationId: String
  deletedItemId: ID
}
type DeleteProjectV2Payload {
  clientMutationId: String
  projectV2: ProjectV2
}
input DeleteProjectV2WorkflowInput {
  clientMutationId: String
  workflowId: ID! @possibleTypes(concreteTypes: ["ProjectV2Workflow"])
}
type DeleteProjectV2WorkflowPayload {
  clientMutationId: String
  deletedWorkflowId: ID
  projectV2: ProjectV2
}
input DeletePullRequestReviewCommentInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["PullRequestReviewComment"])
}
type DeletePullRequestReviewCommentPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
  pullRequestReviewComment: PullRequestReviewComment
}
input DeletePullRequestReviewInput {
  clientMutationId: String
  pullRequestReviewId: ID! @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type DeletePullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
}
input DeleteRefInput {
  clientMutationId: String
  refId: ID! @possibleTypes(concreteTypes: ["Ref"])
}
type DeleteRefPayload {
  clientMutationId: String
}
input DeleteRepositoryRulesetInput {
  clientMutationId: String
  repositoryRulesetId: ID! @possibleTypes(concreteTypes: ["RepositoryRuleset"])
}
type DeleteRepositoryRulesetPayload {
  clientMutationId: String
}
input DeleteTeamDiscussionCommentInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["TeamDiscussionComment"])
}
type DeleteTeamDiscussionCommentPayload {
  clientMutationId: String
}
input DeleteTeamDiscussionInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["TeamDiscussion"])
}
type DeleteTeamDiscussionPayload {
  clientMutationId: String
}
input DeleteVerifiableDomainInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["VerifiableDomain"])
}
type DeleteVerifiableDomainPayload {
  clientMutationId: String
  owner: VerifiableDomainOwner
}
type DemilestonedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  milestoneTitle: String!
  subject: MilestoneItem!
}
type DependabotUpdate implements RepositoryNode {
  error: DependabotUpdateError
  pullRequest: PullRequest
  repository: Repository!
}
type DependabotUpdateError {
  body: String!
  errorType: String!
  title: String!
}
type DependencyGraphDependency @preview(toggledBy: "hawkgirl-preview") {
  hasDependencies: Boolean!
  packageLabel: String!
    @deprecated(
      reason: "'packageLabel' will be removed. Use normalized 'packageName' field instead. Removal on 2022-10-01 UTC."
    )
  packageManager: String
  packageName: String!
  repository: Repository
  requirements: String!
}
type DependencyGraphDependencyConnection @preview(toggledBy: "hawkgirl-preview") {
  edges: [DependencyGraphDependencyEdge]
  nodes: [DependencyGraphDependency]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DependencyGraphDependencyEdge @preview(toggledBy: "hawkgirl-preview") {
  cursor: String!
  node: DependencyGraphDependency
}
enum DependencyGraphEcosystem {
  ACTIONS
  COMPOSER
  GO
  MAVEN
  NPM
  NUGET
  PIP
  PUB
  RUBYGEMS
  RUST
  SWIFT
}
type DependencyGraphManifest implements Node @preview(toggledBy: "hawkgirl-preview") {
  blobPath: String!
  dependencies(
    after: String
    before: String
    first: Int
    last: Int
  ): DependencyGraphDependencyConnection
  dependenciesCount: Int
  exceedsMaxSize: Boolean!
  filename: String!
  id: ID!
  parseable: Boolean!
  repository: Repository!
}
type DependencyGraphManifestConnection @preview(toggledBy: "hawkgirl-preview") {
  edges: [DependencyGraphManifestEdge]
  nodes: [DependencyGraphManifest]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DependencyGraphManifestEdge @preview(toggledBy: "hawkgirl-preview") {
  cursor: String!
  node: DependencyGraphManifest
}
type DeployKey implements Node {
  createdAt: DateTime!
  id: ID!
  key: String!
  readOnly: Boolean!
  title: String!
  verified: Boolean!
}
type DeployKeyConnection {
  edges: [DeployKeyEdge]
  nodes: [DeployKey]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DeployKeyEdge {
  cursor: String!
  node: DeployKey
}
type DeployedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  deployment: Deployment!
  id: ID!
  pullRequest: PullRequest!
  ref: Ref
}
type Deployment implements Node {
  commit: Commit
  commitOid: String!
  createdAt: DateTime!
  creator: Actor!
  databaseId: Int
  description: String
  environment: String
  id: ID!
  latestEnvironment: String
  latestStatus: DeploymentStatus
  originalEnvironment: String
  payload: String
  ref: Ref
  repository: Repository!
  state: DeploymentState
  statuses(
    after: String
    before: String
    first: Int
    last: Int
  ): DeploymentStatusConnection
  task: String
  updatedAt: DateTime!
}
type DeploymentConnection {
  edges: [DeploymentEdge]
  nodes: [Deployment]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DeploymentEdge {
  cursor: String!
  node: Deployment
}
type DeploymentEnvironmentChangedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  deploymentStatus: DeploymentStatus!
  id: ID!
  pullRequest: PullRequest!
}
input DeploymentOrder {
  direction: OrderDirection!
  field: DeploymentOrderField!
}
enum DeploymentOrderField {
  CREATED_AT
}
type DeploymentProtectionRule {
  databaseId: Int
  reviewers(
    after: String
    before: String
    first: Int
    last: Int
  ): DeploymentReviewerConnection!
  timeout: Int!
  type: DeploymentProtectionRuleType!
}
type DeploymentProtectionRuleConnection {
  edges: [DeploymentProtectionRuleEdge]
  nodes: [DeploymentProtectionRule]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DeploymentProtectionRuleEdge {
  cursor: String!
  node: DeploymentProtectionRule
}
enum DeploymentProtectionRuleType {
  REQUIRED_REVIEWERS
  WAIT_TIMER
}
type DeploymentRequest {
  currentUserCanApprove: Boolean!
  environment: Environment!
  reviewers(
    after: String
    before: String
    first: Int
    last: Int
  ): DeploymentReviewerConnection!
  waitTimer: Int!
  waitTimerStartedAt: DateTime
}
type DeploymentRequestConnection {
  edges: [DeploymentRequestEdge]
  nodes: [DeploymentRequest]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DeploymentRequestEdge {
  cursor: String!
  node: DeploymentRequest
}
type DeploymentReview implements Node {
  comment: String!
  databaseId: Int
  environments(
    after: String
    before: String
    first: Int
    last: Int
  ): EnvironmentConnection!
  id: ID!
  state: DeploymentReviewState!
  user: User!
}
type DeploymentReviewConnection {
  edges: [DeploymentReviewEdge]
  nodes: [DeploymentReview]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DeploymentReviewEdge {
  cursor: String!
  node: DeploymentReview
}
enum DeploymentReviewState {
  APPROVED
  REJECTED
}
union DeploymentReviewer = Team | User
type DeploymentReviewerConnection {
  edges: [DeploymentReviewerEdge]
  nodes: [DeploymentReviewer]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DeploymentReviewerEdge {
  cursor: String!
  node: DeploymentReviewer
}
enum DeploymentState {
  ABANDONED
  ACTIVE
  DESTROYED
  ERROR
  FAILURE
  INACTIVE
  IN_PROGRESS
  PENDING
  QUEUED
  SUCCESS
  WAITING
}
type DeploymentStatus implements Node {
  createdAt: DateTime!
  creator: Actor!
  deployment: Deployment!
  description: String
  environment: String @preview(toggledBy: "flash-preview")
  environmentUrl: URI
  id: ID!
  logUrl: URI
  state: DeploymentStatusState!
  updatedAt: DateTime!
}
type DeploymentStatusConnection {
  edges: [DeploymentStatusEdge]
  nodes: [DeploymentStatus]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DeploymentStatusEdge {
  cursor: String!
  node: DeploymentStatus
}
enum DeploymentStatusState {
  ERROR
  FAILURE
  INACTIVE
  IN_PROGRESS
  PENDING
  QUEUED
  SUCCESS
  WAITING
}
input DequeuePullRequestInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type DequeuePullRequestPayload {
  clientMutationId: String
  mergeQueueEntry: MergeQueueEntry
}
enum DiffSide {
  LEFT
  RIGHT
}
input DisablePullRequestAutoMergeInput {
  clientMutationId: String
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type DisablePullRequestAutoMergePayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
}
type DisconnectedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  isCrossRepository: Boolean!
  source: ReferencedSubject!
  subject: ReferencedSubject!
}
type Discussion implements Closable & Comment & Deletable & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & Updatable & Votable {
  activeLockReason: LockReason
  answer: DiscussionComment
  answerChosenAt: DateTime
  answerChosenBy: Actor
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  category: DiscussionCategory!
  closed: Boolean!
  closedAt: DateTime
  comments(
    after: String
    before: String
    first: Int
    last: Int
  ): DiscussionCommentConnection!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  labels(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
  ): LabelConnection
  lastEditedAt: DateTime
  locked: Boolean!
  number: Int!
  poll: DiscussionPoll
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  stateReason: DiscussionStateReason
  title: String!
  updatedAt: DateTime!
  upvoteCount: Int!
  url: URI!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanClose: Boolean!
  viewerCanDelete: Boolean!
  viewerCanReact: Boolean!
  viewerCanReopen: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdate: Boolean!
  viewerCanUpvote: Boolean!
  viewerDidAuthor: Boolean!
  viewerHasUpvoted: Boolean!
  viewerSubscription: SubscriptionState
}
type DiscussionCategory implements Node & RepositoryNode {
  createdAt: DateTime!
  description: String
  emoji: String!
  emojiHTML: HTML!
  id: ID!
  isAnswerable: Boolean!
  name: String!
  repository: Repository!
  slug: String!
  updatedAt: DateTime!
}
type DiscussionCategoryConnection {
  edges: [DiscussionCategoryEdge]
  nodes: [DiscussionCategory]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DiscussionCategoryEdge {
  cursor: String!
  node: DiscussionCategory
}
enum DiscussionCloseReason {
  DUPLICATE
  OUTDATED
  RESOLVED
}
type DiscussionComment implements Comment & Deletable & Minimizable & Node & Reactable & Updatable & UpdatableComment & Votable {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  deletedAt: DateTime
  discussion: Discussion
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  isAnswer: Boolean!
  isMinimized: Boolean!
  lastEditedAt: DateTime
  minimizedReason: String
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  replies(
    after: String
    before: String
    first: Int
    last: Int
  ): DiscussionCommentConnection!
  replyTo: DiscussionComment
  resourcePath: URI!
  updatedAt: DateTime!
  upvoteCount: Int!
  url: URI!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMarkAsAnswer: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanReact: Boolean!
  viewerCanUnmarkAsAnswer: Boolean!
  viewerCanUpdate: Boolean!
  viewerCanUpvote: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
  viewerHasUpvoted: Boolean!
}
type DiscussionCommentConnection {
  edges: [DiscussionCommentEdge]
  nodes: [DiscussionComment]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DiscussionCommentEdge {
  cursor: String!
  node: DiscussionComment
}
type DiscussionConnection {
  edges: [DiscussionEdge]
  nodes: [Discussion]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DiscussionEdge {
  cursor: String!
  node: Discussion
}
input DiscussionOrder {
  direction: OrderDirection!
  field: DiscussionOrderField!
}
enum DiscussionOrderField {
  CREATED_AT
  UPDATED_AT
}
type DiscussionPoll implements Node {
  discussion: Discussion
  id: ID!
  options(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: DiscussionPollOptionOrder = {field: AUTHORED_ORDER, direction: ASC}
  ): DiscussionPollOptionConnection
  question: String!
  totalVoteCount: Int!
  viewerCanVote: Boolean!
  viewerHasVoted: Boolean!
}
type DiscussionPollOption implements Node {
  id: ID!
  option: String!
  poll: DiscussionPoll
  totalVoteCount: Int!
  viewerHasVoted: Boolean!
}
type DiscussionPollOptionConnection {
  edges: [DiscussionPollOptionEdge]
  nodes: [DiscussionPollOption]
  pageInfo: PageInfo!
  totalCount: Int!
}
type DiscussionPollOptionEdge {
  cursor: String!
  node: DiscussionPollOption
}
input DiscussionPollOptionOrder {
  direction: OrderDirection!
  field: DiscussionPollOptionOrderField!
}
enum DiscussionPollOptionOrderField {
  AUTHORED_ORDER
  VOTE_COUNT
}
enum DiscussionState {
  CLOSED
  OPEN
}
enum DiscussionStateReason {
  DUPLICATE
  OUTDATED
  REOPENED
  RESOLVED
}
input DismissPullRequestReviewInput {
  clientMutationId: String
  message: String!
  pullRequestReviewId: ID! @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type DismissPullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
}
enum DismissReason {
  FIX_STARTED
  INACCURATE
  NOT_USED
  NO_BANDWIDTH
  TOLERABLE_RISK
}
input DismissRepositoryVulnerabilityAlertInput {
  clientMutationId: String
  dismissReason: DismissReason!
  repositoryVulnerabilityAlertId: ID! @possibleTypes(concreteTypes: ["RepositoryVulnerabilityAlert"])
}
type DismissRepositoryVulnerabilityAlertPayload {
  clientMutationId: String
  repositoryVulnerabilityAlert: RepositoryVulnerabilityAlert
}
type DraftIssue implements Node {
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  creator: Actor
  id: ID!
  projectV2Items(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2ItemConnection!
  projectsV2(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2Connection!
  title: String!
  updatedAt: DateTime!
}
input DraftPullRequestReviewComment {
  body: String!
  path: String!
  position: Int!
}
input DraftPullRequestReviewThread {
  body: String!
  line: Int!
  path: String!
  side: DiffSide = RIGHT
  startLine: Int
  startSide: DiffSide = RIGHT
}
input EnablePullRequestAutoMergeInput {
  authorEmail: String
  clientMutationId: String
  commitBody: String
  commitHeadline: String
  expectedHeadOid: GitObjectID
  mergeMethod: PullRequestMergeMethod = MERGE
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type EnablePullRequestAutoMergePayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
}
input EnqueuePullRequestInput {
  clientMutationId: String
  expectedHeadOid: GitObjectID
  jump: Boolean
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type EnqueuePullRequestPayload {
  clientMutationId: String
  mergeQueueEntry: MergeQueueEntry
}
type Enterprise implements AnnouncementBanner & Node {
  announcement: String
  announcementExpiresAt: DateTime
  announcementUserDismissible: Boolean
  avatarUrl(
    size: Int
  ): URI!
  billingInfo: EnterpriseBillingInfo
  createdAt: DateTime!
  databaseId: Int
  description: String
  descriptionHTML: HTML!
  id: ID!
  location: String
  members(
    after: String
    before: String
    deployment: EnterpriseUserDeployment
    first: Int
    hasTwoFactorEnabled: Boolean = null
    last: Int
    orderBy: EnterpriseMemberOrder = {field: LOGIN, direction: ASC}
    organizationLogins: [String!]
    query: String
    role: EnterpriseUserAccountMembershipRole
  ): EnterpriseMemberConnection!
  name: String!
  organizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    query: String
    viewerOrganizationRole: RoleInOrganization
  ): OrganizationConnection!
  ownerInfo: EnterpriseOwnerInfo
  resourcePath: URI!
  slug: String!
  url: URI!
  viewerIsAdmin: Boolean!
  websiteUrl: URI
}
type EnterpriseAdministratorConnection {
  edges: [EnterpriseAdministratorEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseAdministratorEdge {
  cursor: String!
  node: User
  role: EnterpriseAdministratorRole!
}
type EnterpriseAdministratorInvitation implements Node {
  createdAt: DateTime!
  email: String
  enterprise: Enterprise!
  id: ID!
  invitee: User
  inviter: User
  role: EnterpriseAdministratorRole!
}
type EnterpriseAdministratorInvitationConnection {
  edges: [EnterpriseAdministratorInvitationEdge]
  nodes: [EnterpriseAdministratorInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseAdministratorInvitationEdge {
  cursor: String!
  node: EnterpriseAdministratorInvitation
}
input EnterpriseAdministratorInvitationOrder {
  direction: OrderDirection!
  field: EnterpriseAdministratorInvitationOrderField!
}
enum EnterpriseAdministratorInvitationOrderField {
  CREATED_AT
}
enum EnterpriseAdministratorRole {
  BILLING_MANAGER
  OWNER
}
enum EnterpriseAllowPrivateRepositoryForkingPolicyValue {
  ENTERPRISE_ORGANIZATIONS
  ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS
  EVERYWHERE
  SAME_ORGANIZATION
  SAME_ORGANIZATION_USER_ACCOUNTS
  USER_ACCOUNTS
}
interface EnterpriseAuditEntryData {
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
}
type EnterpriseBillingInfo {
  allLicensableUsersCount: Int!
  assetPacks: Int!
  bandwidthQuota: Float!
  bandwidthUsage: Float!
  bandwidthUsagePercentage: Int!
  storageQuota: Float!
  storageUsage: Float!
  storageUsagePercentage: Int!
  totalAvailableLicenses: Int!
  totalLicenses: Int!
}
enum EnterpriseDefaultRepositoryPermissionSettingValue {
  ADMIN
  NONE
  NO_POLICY
  READ
  WRITE
}
enum EnterpriseEnabledDisabledSettingValue {
  DISABLED
  ENABLED
  NO_POLICY
}
enum EnterpriseEnabledSettingValue {
  ENABLED
  NO_POLICY
}
type EnterpriseFailedInvitationConnection {
  edges: [EnterpriseFailedInvitationEdge]
  nodes: [OrganizationInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
  totalUniqueUserCount: Int!
}
type EnterpriseFailedInvitationEdge {
  cursor: String!
  node: OrganizationInvitation
}
type EnterpriseIdentityProvider implements Node {
  digestMethod: SamlDigestAlgorithm
  enterprise: Enterprise
  externalIdentities(
    after: String
    before: String
    first: Int
    last: Int
    login: String
    membersOnly: Boolean
    userName: String
  ): ExternalIdentityConnection!
  id: ID!
  idpCertificate: X509Certificate
  issuer: String
  recoveryCodes: [String!]
  signatureMethod: SamlSignatureAlgorithm
  ssoUrl: URI
}
union EnterpriseMember = EnterpriseUserAccount | User
type EnterpriseMemberConnection {
  edges: [EnterpriseMemberEdge]
  nodes: [EnterpriseMember]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseMemberEdge {
  cursor: String!
  node: EnterpriseMember
}
input EnterpriseMemberOrder {
  direction: OrderDirection!
  field: EnterpriseMemberOrderField!
}
enum EnterpriseMemberOrderField {
  CREATED_AT
  LOGIN
}
enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  ALL
  DISABLED
  NO_POLICY
  PRIVATE
  PUBLIC
}
enum EnterpriseMembersCanMakePurchasesSettingValue {
  DISABLED
  ENABLED
}
type EnterpriseOrganizationMembershipConnection {
  edges: [EnterpriseOrganizationMembershipEdge]
  nodes: [Organization]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseOrganizationMembershipEdge {
  cursor: String!
  node: Organization
  role: EnterpriseUserAccountMembershipRole!
}
type EnterpriseOutsideCollaboratorConnection {
  edges: [EnterpriseOutsideCollaboratorEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseOutsideCollaboratorEdge {
  cursor: String!
  node: User
  repositories(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: RepositoryOrder = {field: NAME, direction: ASC}
  ): EnterpriseRepositoryInfoConnection!
}
type EnterpriseOwnerInfo {
  admins(
    after: String
    before: String
    first: Int
    hasTwoFactorEnabled: Boolean = null
    last: Int
    orderBy: EnterpriseMemberOrder = {field: LOGIN, direction: ASC}
    organizationLogins: [String!]
    query: String
    role: EnterpriseAdministratorRole
  ): EnterpriseAdministratorConnection!
  affiliatedUsersWithTwoFactorDisabled(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  affiliatedUsersWithTwoFactorDisabledExist: Boolean!
  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue!
  allowPrivateRepositoryForkingSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  allowPrivateRepositoryForkingSettingPolicyValue: EnterpriseAllowPrivateRepositoryForkingPolicyValue
  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue!
  defaultRepositoryPermissionSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: DefaultRepositoryPermissionField!
  ): OrganizationConnection!
  domains(
    after: String
    before: String
    first: Int
    isApproved: Boolean = null
    isVerified: Boolean = null
    last: Int
    orderBy: VerifiableDomainOrder = {field: DOMAIN, direction: ASC}
  ): VerifiableDomainConnection!
  enterpriseServerInstallations(
    after: String
    before: String
    connectedOnly: Boolean = false
    first: Int
    last: Int
    orderBy: EnterpriseServerInstallationOrder = {field: HOST_NAME, direction: ASC}
  ): EnterpriseServerInstallationConnection!
  failedInvitations(
    after: String
    before: String
    first: Int
    last: Int
    query: String
  ): EnterpriseFailedInvitationConnection!
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue!
  ipAllowListEntries(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: IpAllowListEntryOrder = {field: ALLOW_LIST_VALUE, direction: ASC}
  ): IpAllowListEntryConnection!
  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue!
  isUpdatingDefaultRepositoryPermission: Boolean!
  isUpdatingTwoFactorRequirement: Boolean!
  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue!
  membersCanChangeRepositoryVisibilitySettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  membersCanCreateInternalRepositoriesSetting: Boolean
  membersCanCreatePrivateRepositoriesSetting: Boolean
  membersCanCreatePublicRepositoriesSetting: Boolean
  membersCanCreateRepositoriesSetting: EnterpriseMembersCanCreateRepositoriesSettingValue
  membersCanCreateRepositoriesSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: OrganizationMembersCanCreateRepositoriesSettingValue!
  ): OrganizationConnection!
  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanDeleteIssuesSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanDeleteRepositoriesSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanInviteCollaboratorsSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue!
  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanUpdateProtectedBranchesSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanViewDependencyInsightsSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue!
  oidcProvider: OIDCProvider
  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue!
  organizationProjectsSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  outsideCollaborators(
    after: String
    before: String
    first: Int
    hasTwoFactorEnabled: Boolean = null
    last: Int
    login: String
    orderBy: EnterpriseMemberOrder = {field: LOGIN, direction: ASC}
    organizationLogins: [String!]
    query: String
    visibility: RepositoryVisibility
  ): EnterpriseOutsideCollaboratorConnection!
  pendingAdminInvitations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: EnterpriseAdministratorInvitationOrder = {field: CREATED_AT, direction: DESC}
    query: String
    role: EnterpriseAdministratorRole
  ): EnterpriseAdministratorInvitationConnection!
  pendingCollaboratorInvitations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: RepositoryInvitationOrder = {field: CREATED_AT, direction: DESC}
    query: String
  ): RepositoryInvitationConnection!
  pendingMemberInvitations(
    after: String
    before: String
    first: Int
    invitationSource: OrganizationInvitationSource
    last: Int
    organizationLogins: [String!]
    query: String
  ): EnterprisePendingMemberInvitationConnection!
  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue!
  repositoryProjectsSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  samlIdentityProvider: EnterpriseIdentityProvider
  samlIdentityProviderSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: IdentityProviderConfigurationState!
  ): OrganizationConnection!
  supportEntitlements(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: EnterpriseMemberOrder = {field: LOGIN, direction: ASC}
  ): EnterpriseMemberConnection!
  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue!
  teamDiscussionsSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
  twoFactorRequiredSetting: EnterpriseEnabledSettingValue!
  twoFactorRequiredSettingOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    value: Boolean!
  ): OrganizationConnection!
}
type EnterprisePendingMemberInvitationConnection {
  edges: [EnterprisePendingMemberInvitationEdge]
  nodes: [OrganizationInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
  totalUniqueUserCount: Int!
}
type EnterprisePendingMemberInvitationEdge {
  cursor: String!
  node: OrganizationInvitation
}
type EnterpriseRepositoryInfo implements Node {
  id: ID!
  isPrivate: Boolean!
  name: String!
  nameWithOwner: String!
}
type EnterpriseRepositoryInfoConnection {
  edges: [EnterpriseRepositoryInfoEdge]
  nodes: [EnterpriseRepositoryInfo]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseRepositoryInfoEdge {
  cursor: String!
  node: EnterpriseRepositoryInfo
}
type EnterpriseServerInstallation implements Node {
  createdAt: DateTime!
  customerName: String!
  hostName: String!
  id: ID!
  isConnected: Boolean!
  updatedAt: DateTime!
  userAccounts(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: EnterpriseServerUserAccountOrder = {field: LOGIN, direction: ASC}
  ): EnterpriseServerUserAccountConnection!
  userAccountsUploads(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: EnterpriseServerUserAccountsUploadOrder = {field: CREATED_AT, direction: DESC}
  ): EnterpriseServerUserAccountsUploadConnection!
}
type EnterpriseServerInstallationConnection {
  edges: [EnterpriseServerInstallationEdge]
  nodes: [EnterpriseServerInstallation]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseServerInstallationEdge {
  cursor: String!
  node: EnterpriseServerInstallation
}
type EnterpriseServerInstallationMembershipConnection {
  edges: [EnterpriseServerInstallationMembershipEdge]
  nodes: [EnterpriseServerInstallation]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseServerInstallationMembershipEdge {
  cursor: String!
  node: EnterpriseServerInstallation
  role: EnterpriseUserAccountMembershipRole!
}
input EnterpriseServerInstallationOrder {
  direction: OrderDirection!
  field: EnterpriseServerInstallationOrderField!
}
enum EnterpriseServerInstallationOrderField {
  CREATED_AT
  CUSTOMER_NAME
  HOST_NAME
}
type EnterpriseServerUserAccount implements Node {
  createdAt: DateTime!
  emails(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: EnterpriseServerUserAccountEmailOrder = {field: EMAIL, direction: ASC}
  ): EnterpriseServerUserAccountEmailConnection!
  enterpriseServerInstallation: EnterpriseServerInstallation!
  id: ID!
  isSiteAdmin: Boolean!
  login: String!
  profileName: String
  remoteCreatedAt: DateTime!
  remoteUserId: Int!
  updatedAt: DateTime!
}
type EnterpriseServerUserAccountConnection {
  edges: [EnterpriseServerUserAccountEdge]
  nodes: [EnterpriseServerUserAccount]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseServerUserAccountEdge {
  cursor: String!
  node: EnterpriseServerUserAccount
}
type EnterpriseServerUserAccountEmail implements Node {
  createdAt: DateTime!
  email: String!
  id: ID!
  isPrimary: Boolean!
  updatedAt: DateTime!
  userAccount: EnterpriseServerUserAccount!
}
type EnterpriseServerUserAccountEmailConnection {
  edges: [EnterpriseServerUserAccountEmailEdge]
  nodes: [EnterpriseServerUserAccountEmail]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseServerUserAccountEmailEdge {
  cursor: String!
  node: EnterpriseServerUserAccountEmail
}
input EnterpriseServerUserAccountEmailOrder {
  direction: OrderDirection!
  field: EnterpriseServerUserAccountEmailOrderField!
}
enum EnterpriseServerUserAccountEmailOrderField {
  EMAIL
}
input EnterpriseServerUserAccountOrder {
  direction: OrderDirection!
  field: EnterpriseServerUserAccountOrderField!
}
enum EnterpriseServerUserAccountOrderField {
  LOGIN
  REMOTE_CREATED_AT
}
type EnterpriseServerUserAccountsUpload implements Node {
  createdAt: DateTime!
  enterprise: Enterprise!
  enterpriseServerInstallation: EnterpriseServerInstallation!
  id: ID!
  name: String!
  syncState: EnterpriseServerUserAccountsUploadSyncState!
  updatedAt: DateTime!
}
type EnterpriseServerUserAccountsUploadConnection {
  edges: [EnterpriseServerUserAccountsUploadEdge]
  nodes: [EnterpriseServerUserAccountsUpload]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnterpriseServerUserAccountsUploadEdge {
  cursor: String!
  node: EnterpriseServerUserAccountsUpload
}
input EnterpriseServerUserAccountsUploadOrder {
  direction: OrderDirection!
  field: EnterpriseServerUserAccountsUploadOrderField!
}
enum EnterpriseServerUserAccountsUploadOrderField {
  CREATED_AT
}
enum EnterpriseServerUserAccountsUploadSyncState {
  FAILURE
  PENDING
  SUCCESS
}
type EnterpriseUserAccount implements Actor & Node {
  avatarUrl(
    size: Int
  ): URI!
  createdAt: DateTime!
  enterprise: Enterprise!
  enterpriseInstallations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: EnterpriseServerInstallationOrder = {field: HOST_NAME, direction: ASC}
    query: String
    role: EnterpriseUserAccountMembershipRole
  ): EnterpriseServerInstallationMembershipConnection!
  id: ID!
  login: String!
  name: String
  organizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = {field: LOGIN, direction: ASC}
    query: String
    role: EnterpriseUserAccountMembershipRole
  ): EnterpriseOrganizationMembershipConnection!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
  user: User
}
enum EnterpriseUserAccountMembershipRole {
  MEMBER
  OWNER
  UNAFFILIATED
}
enum EnterpriseUserDeployment {
  CLOUD
  SERVER
}
type Environment implements Node {
  databaseId: Int
  id: ID!
  name: String!
  protectionRules(
    after: String
    before: String
    first: Int
    last: Int
  ): DeploymentProtectionRuleConnection!
}
type EnvironmentConnection {
  edges: [EnvironmentEdge]
  nodes: [Environment]
  pageInfo: PageInfo!
  totalCount: Int!
}
type EnvironmentEdge {
  cursor: String!
  node: Environment
}
enum EnvironmentOrderField {
  NAME
}
input Environments {
  direction: OrderDirection!
  field: EnvironmentOrderField!
}
type ExternalIdentity implements Node {
  guid: String!
  id: ID!
  organizationInvitation: OrganizationInvitation
  samlIdentity: ExternalIdentitySamlAttributes
  scimIdentity: ExternalIdentityScimAttributes
  user: User
}
type ExternalIdentityAttribute {
  metadata: String
  name: String!
  value: String!
}
type ExternalIdentityConnection {
  edges: [ExternalIdentityEdge]
  nodes: [ExternalIdentity]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ExternalIdentityEdge {
  cursor: String!
  node: ExternalIdentity
}
type ExternalIdentitySamlAttributes {
  attributes: [ExternalIdentityAttribute!]!
  emails: [UserEmailMetadata!]
  familyName: String
  givenName: String
  groups: [String!]
  nameId: String
  username: String
}
type ExternalIdentityScimAttributes {
  emails: [UserEmailMetadata!]
  familyName: String
  givenName: String
  groups: [String!]
  username: String
}
input FileAddition {
  contents: Base64String!
  path: String!
}
input FileChanges {
  additions: [FileAddition!] = []
  deletions: [FileDeletion!] = []
}
input FileDeletion {
  path: String!
}
enum FileViewedState {
  DISMISSED
  UNVIEWED
  VIEWED
}
input FollowOrganizationInput {
  clientMutationId: String
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type FollowOrganizationPayload {
  clientMutationId: String
  organization: Organization
}
input FollowUserInput {
  clientMutationId: String
  userId: ID! @possibleTypes(concreteTypes: ["User"])
}
type FollowUserPayload {
  clientMutationId: String
  user: User
}
type FollowerConnection {
  edges: [UserEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type FollowingConnection {
  edges: [UserEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type FundingLink {
  platform: FundingPlatform!
  url: URI!
}
enum FundingPlatform {
  COMMUNITY_BRIDGE
  CUSTOM
  GITHUB
  ISSUEHUNT
  KO_FI
  LFX_CROWDFUNDING
  LIBERAPAY
  OPEN_COLLECTIVE
  OTECHIE
  PATREON
  TIDELIFT
}
type GenericHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
}
type Gist implements Node & Starrable & UniformResourceLocatable {
  comments(
    after: String
    before: String
    first: Int
    last: Int
  ): GistCommentConnection!
  createdAt: DateTime!
  description: String
  files(
    limit: Int = 10
    oid: GitObjectID
  ): [GistFile]
  forks(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: GistOrder
  ): GistConnection!
  id: ID!
  isFork: Boolean!
  isPublic: Boolean!
  name: String!
  owner: RepositoryOwner
  pushedAt: DateTime
  resourcePath: URI!
  stargazerCount: Int!
  stargazers(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: StarOrder
  ): StargazerConnection!
  updatedAt: DateTime!
  url: URI!
  viewerHasStarred: Boolean!
}
type GistComment implements Comment & Deletable & Minimizable & Node & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  gist: Gist!
  id: ID!
  includesCreatedEdit: Boolean!
  isMinimized: Boolean!
  lastEditedAt: DateTime
  minimizedReason: String
  publishedAt: DateTime
  updatedAt: DateTime!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}
type GistCommentConnection {
  edges: [GistCommentEdge]
  nodes: [GistComment]
  pageInfo: PageInfo!
  totalCount: Int!
}
type GistCommentEdge {
  cursor: String!
  node: GistComment
}
type GistConnection {
  edges: [GistEdge]
  nodes: [Gist]
  pageInfo: PageInfo!
  totalCount: Int!
}
type GistEdge {
  cursor: String!
  node: Gist
}
type GistFile {
  encodedName: String
  encoding: String
  extension: String
  isImage: Boolean!
  isTruncated: Boolean!
  language: Language
  name: String
  size: Int
  text(
    truncate: Int
  ): String
}
input GistOrder {
  direction: OrderDirection!
  field: GistOrderField!
}
enum GistOrderField {
  CREATED_AT
  PUSHED_AT
  UPDATED_AT
}
enum GistPrivacy {
  ALL
  PUBLIC
  SECRET
}
type GitActor {
  avatarUrl(
    size: Int
  ): URI!
  date: GitTimestamp
  email: String
  name: String
  user: User
}
type GitActorConnection {
  edges: [GitActorEdge]
  nodes: [GitActor]
  pageInfo: PageInfo!
  totalCount: Int!
}
type GitActorEdge {
  cursor: String!
  node: GitActor
}
type GitHubMetadata {
  gitHubServicesSha: GitObjectID!
  gitIpAddresses: [String!]
  hookIpAddresses: [String!]
  importerIpAddresses: [String!]
  isPasswordAuthenticationVerifiable: Boolean!
  pagesIpAddresses: [String!]
}
interface GitObject {
  abbreviatedOid: String!
  commitResourcePath: URI!
  commitUrl: URI!
  id: ID!
  oid: GitObjectID!
  repository: Repository!
}
scalar GitObjectID
scalar GitRefname @preview(toggledBy: "update-refs-preview")
scalar GitSSHRemote
interface GitSignature {
  email: String!
  isValid: Boolean!
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}
enum GitSignatureState {
  BAD_CERT
  BAD_EMAIL
  EXPIRED_KEY
  GPGVERIFY_ERROR
  GPGVERIFY_UNAVAILABLE
  INVALID
  MALFORMED_SIG
  NOT_SIGNING_KEY
  NO_USER
  OCSP_ERROR
  OCSP_PENDING
  OCSP_REVOKED
  UNKNOWN_KEY
  UNKNOWN_SIG_TYPE
  UNSIGNED
  UNVERIFIED_EMAIL
  VALID
}
scalar GitTimestamp
type GpgSignature implements GitSignature {
  email: String!
  isValid: Boolean!
  keyId: String
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}
input GrantEnterpriseOrganizationsMigratorRoleInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  login: String!
}
type GrantEnterpriseOrganizationsMigratorRolePayload {
  clientMutationId: String
  organizations(
    after: String
    before: String
    first: Int
    last: Int
  ): OrganizationConnection
}
input GrantMigratorRoleInput {
  actor: String!
  actorType: ActorType!
  clientMutationId: String
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type GrantMigratorRolePayload {
  clientMutationId: String
  success: Boolean
}
scalar HTML
type HeadRefDeletedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  headRef: Ref
  headRefName: String!
  id: ID!
  pullRequest: PullRequest!
}
type HeadRefForcePushedEvent implements Node {
  actor: Actor
  afterCommit: Commit
  beforeCommit: Commit
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  ref: Ref
}
type HeadRefRestoredEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
}
type Hovercard {
  contexts: [HovercardContext!]!
}
interface HovercardContext {
  message: String!
  octicon: String!
}
enum IdentityProviderConfigurationState {
  CONFIGURED
  ENFORCED
  UNCONFIGURED
}
input ImportProjectInput {
  body: String
  clientMutationId: String
  columnImports: [ProjectColumnImport!]!
  name: String!
  ownerName: String!
  public: Boolean = false
}
type ImportProjectPayload {
  clientMutationId: String
  project: Project
}
input InviteEnterpriseAdminInput {
  clientMutationId: String
  email: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  invitee: String
  role: EnterpriseAdministratorRole
}
type InviteEnterpriseAdminPayload {
  clientMutationId: String
  invitation: EnterpriseAdministratorInvitation
}
enum IpAllowListEnabledSettingValue {
  DISABLED
  ENABLED
}
type IpAllowListEntry implements Node {
  allowListValue: String!
  createdAt: DateTime!
  id: ID!
  isActive: Boolean!
  name: String
  owner: IpAllowListOwner!
  updatedAt: DateTime!
}
type IpAllowListEntryConnection {
  edges: [IpAllowListEntryEdge]
  nodes: [IpAllowListEntry]
  pageInfo: PageInfo!
  totalCount: Int!
}
type IpAllowListEntryEdge {
  cursor: String!
  node: IpAllowListEntry
}
input IpAllowListEntryOrder {
  direction: OrderDirection!
  field: IpAllowListEntryOrderField!
}
enum IpAllowListEntryOrderField {
  ALLOW_LIST_VALUE
  CREATED_AT
}
enum IpAllowListForInstalledAppsEnabledSettingValue {
  DISABLED
  ENABLED
}
union IpAllowListOwner = App | Enterprise | Organization
type Issue implements Assignable & Closable & Comment & Deletable & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & SubscribableThread & UniformResourceLocatable & Updatable & UpdatableComment {
  activeLockReason: LockReason
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyResourcePath: URI!
  bodyText: String!
  bodyUrl: URI!
  closed: Boolean!
  closedAt: DateTime
  comments(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: IssueCommentOrder
  ): IssueCommentConnection!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  fullDatabaseId: BigInt
  hovercard(
    includeNotificationContexts: Boolean = true
  ): Hovercard!
  id: ID!
  includesCreatedEdit: Boolean!
  isPinned: Boolean
  isReadByViewer: Boolean
  labels(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
  ): LabelConnection
  lastEditedAt: DateTime
  linkedBranches(
    after: String
    before: String
    first: Int
    last: Int
  ): LinkedBranchConnection!
  locked: Boolean!
  milestone: Milestone
  number: Int!
  participants(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  projectCards(
    after: String
    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]
    before: String
    first: Int
    last: Int
  ): ProjectCardConnection!
  projectItems(
    after: String
    before: String
    first: Int
    includeArchived: Boolean = true
    last: Int
  ): ProjectV2ItemConnection!
  projectV2(
    number: Int!
  ): ProjectV2
  projectsV2(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2Order = {field: NUMBER, direction: DESC}
    query: String
  ): ProjectV2Connection!
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  state: IssueState!
  stateReason: IssueStateReason
  timeline(
    after: String
    before: String
    first: Int
    last: Int
    since: DateTime
  ): IssueTimelineConnection!
    @deprecated(reason: "'timeline' will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.")
  timelineItems(
    after: String
    before: String
    first: Int
    itemTypes: [IssueTimelineItemsItemType!]
    last: Int
    since: DateTime
    skip: Int
  ): IssueTimelineItemsConnection!
  title: String!
  titleHTML: String!
  trackedInIssues(
    after: String
    before: String
    first: Int
    last: Int
  ): IssueConnection!
  trackedIssues(
    after: String
    before: String
    first: Int
    last: Int
  ): IssueConnection!
  trackedIssuesCount(
    states: [TrackedIssueStates]
  ): Int!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanClose: Boolean!
  viewerCanDelete: Boolean!
  viewerCanReact: Boolean!
  viewerCanReopen: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
  viewerSubscription: SubscriptionState
  viewerThreadSubscriptionFormAction: ThreadSubscriptionFormAction
  viewerThreadSubscriptionStatus: ThreadSubscriptionState
}
enum IssueClosedStateReason {
  COMPLETED
  NOT_PLANNED
}
type IssueComment implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  fullDatabaseId: BigInt
  id: ID!
  includesCreatedEdit: Boolean!
  isMinimized: Boolean!
  issue: Issue!
  lastEditedAt: DateTime
  minimizedReason: String
  publishedAt: DateTime
  pullRequest: PullRequest
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}
type IssueCommentConnection {
  edges: [IssueCommentEdge]
  nodes: [IssueComment]
  pageInfo: PageInfo!
  totalCount: Int!
}
type IssueCommentEdge {
  cursor: String!
  node: IssueComment
}
input IssueCommentOrder {
  direction: OrderDirection!
  field: IssueCommentOrderField!
}
enum IssueCommentOrderField {
  UPDATED_AT
}
type IssueConnection {
  edges: [IssueEdge]
  nodes: [Issue]
  pageInfo: PageInfo!
  totalCount: Int!
}
type IssueContributionsByRepository {
  contributions(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedIssueContributionConnection!
  repository: Repository!
}
type IssueEdge {
  cursor: String!
  node: Issue
}
input IssueFilters {
  assignee: String
  createdBy: String
  labels: [String!]
  mentioned: String
  milestone: String
  milestoneNumber: String
  since: DateTime
  states: [IssueState!]
  viewerSubscribed: Boolean = false
}
union IssueOrPullRequest = Issue | PullRequest
input IssueOrder {
  direction: OrderDirection!
  field: IssueOrderField!
}
enum IssueOrderField {
  COMMENTS
  CREATED_AT
  UPDATED_AT
}
enum IssueState {
  CLOSED
  OPEN
}
enum IssueStateReason {
  COMPLETED
  NOT_PLANNED
  REOPENED
}
type IssueTemplate {
  about: String
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  body: String
  filename: String!
  labels(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
  ): LabelConnection
  name: String!
  title: String
}
type IssueTimelineConnection {
  edges: [IssueTimelineItemEdge]
  nodes: [IssueTimelineItem]
  pageInfo: PageInfo!
  totalCount: Int!
}
union IssueTimelineItem =
    AssignedEvent
  | ClosedEvent
  | Commit
  | CrossReferencedEvent
  | DemilestonedEvent
  | IssueComment
  | LabeledEvent
  | LockedEvent
  | MilestonedEvent
  | ReferencedEvent
  | RenamedTitleEvent
  | ReopenedEvent
  | SubscribedEvent
  | TransferredEvent
  | UnassignedEvent
  | UnlabeledEvent
  | UnlockedEvent
  | UnsubscribedEvent
  | UserBlockedEvent
type IssueTimelineItemEdge {
  cursor: String!
  node: IssueTimelineItem
}
union IssueTimelineItems =
    AddedToProjectEvent
  | AssignedEvent
  | ClosedEvent
  | CommentDeletedEvent
  | ConnectedEvent
  | ConvertedNoteToIssueEvent
  | ConvertedToDiscussionEvent
  | CrossReferencedEvent
  | DemilestonedEvent
  | DisconnectedEvent
  | IssueComment
  | LabeledEvent
  | LockedEvent
  | MarkedAsDuplicateEvent
  | MentionedEvent
  | MilestonedEvent
  | MovedColumnsInProjectEvent
  | PinnedEvent
  | ReferencedEvent
  | RemovedFromProjectEvent
  | RenamedTitleEvent
  | ReopenedEvent
  | SubscribedEvent
  | TransferredEvent
  | UnassignedEvent
  | UnlabeledEvent
  | UnlockedEvent
  | UnmarkedAsDuplicateEvent
  | UnpinnedEvent
  | UnsubscribedEvent
  | UserBlockedEvent
type IssueTimelineItemsConnection {
  edges: [IssueTimelineItemsEdge]
  filteredCount: Int!
  nodes: [IssueTimelineItems]
  pageCount: Int!
  pageInfo: PageInfo!
  totalCount: Int!
  updatedAt: DateTime!
}
type IssueTimelineItemsEdge {
  cursor: String!
  node: IssueTimelineItems
}
enum IssueTimelineItemsItemType {
  ADDED_TO_PROJECT_EVENT
  ASSIGNED_EVENT
  CLOSED_EVENT
  COMMENT_DELETED_EVENT
  CONNECTED_EVENT
  CONVERTED_NOTE_TO_ISSUE_EVENT
  CONVERTED_TO_DISCUSSION_EVENT
  CROSS_REFERENCED_EVENT
  DEMILESTONED_EVENT
  DISCONNECTED_EVENT
  ISSUE_COMMENT
  LABELED_EVENT
  LOCKED_EVENT
  MARKED_AS_DUPLICATE_EVENT
  MENTIONED_EVENT
  MILESTONED_EVENT
  MOVED_COLUMNS_IN_PROJECT_EVENT
  PINNED_EVENT
  REFERENCED_EVENT
  REMOVED_FROM_PROJECT_EVENT
  RENAMED_TITLE_EVENT
  REOPENED_EVENT
  SUBSCRIBED_EVENT
  TRANSFERRED_EVENT
  UNASSIGNED_EVENT
  UNLABELED_EVENT
  UNLOCKED_EVENT
  UNMARKED_AS_DUPLICATE_EVENT
  UNPINNED_EVENT
  UNSUBSCRIBED_EVENT
  USER_BLOCKED_EVENT
}
type JoinedGitHubContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  resourcePath: URI!
  url: URI!
  user: User!
}
type Label implements Node {
  color: String!
  createdAt: DateTime
  description: String
  id: ID!
  isDefault: Boolean!
  issues(
    after: String
    before: String
    filterBy: IssueFilters
    first: Int
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [IssueState!]
  ): IssueConnection!
  name: String!
  pullRequests(
    after: String
    baseRefName: String
    before: String
    first: Int
    headRefName: String
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [PullRequestState!]
  ): PullRequestConnection!
  repository: Repository!
  resourcePath: URI!
  updatedAt: DateTime
  url: URI!
}
type LabelConnection {
  edges: [LabelEdge]
  nodes: [Label]
  pageInfo: PageInfo!
  totalCount: Int!
}
type LabelEdge {
  cursor: String!
  node: Label
}
input LabelOrder {
  direction: OrderDirection!
  field: LabelOrderField!
}
enum LabelOrderField {
  CREATED_AT
  NAME
}
interface Labelable {
  labels(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
  ): LabelConnection
}
type LabeledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  label: Label!
  labelable: Labelable!
}
type Language implements Node {
  color: String
  id: ID!
  name: String!
}
type LanguageConnection {
  edges: [LanguageEdge]
  nodes: [Language]
  pageInfo: PageInfo!
  totalCount: Int!
  totalSize: Int!
}
type LanguageEdge {
  cursor: String!
  node: Language!
  size: Int!
}
input LanguageOrder {
  direction: OrderDirection!
  field: LanguageOrderField!
}
enum LanguageOrderField {
  SIZE
}
type License implements Node {
  body: String!
  conditions: [LicenseRule]!
  description: String
  featured: Boolean!
  hidden: Boolean!
  id: ID!
  implementation: String
  key: String!
  limitations: [LicenseRule]!
  name: String!
  nickname: String
  permissions: [LicenseRule]!
  pseudoLicense: Boolean!
  spdxId: String
  url: URI
}
type LicenseRule {
  description: String!
  key: String!
  label: String!
}
input LinkProjectV2ToRepositoryInput {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type LinkProjectV2ToRepositoryPayload {
  clientMutationId: String
  repository: Repository
}
input LinkProjectV2ToTeamInput {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
  teamId: ID! @possibleTypes(concreteTypes: ["Team"])
}
type LinkProjectV2ToTeamPayload {
  clientMutationId: String
  team: Team
}
input LinkRepositoryToProjectInput {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type LinkRepositoryToProjectPayload {
  clientMutationId: String
  project: Project
  repository: Repository
}
type LinkedBranch implements Node {
  id: ID!
  ref: Ref
}
type LinkedBranchConnection {
  edges: [LinkedBranchEdge]
  nodes: [LinkedBranch]
  pageInfo: PageInfo!
  totalCount: Int!
}
type LinkedBranchEdge {
  cursor: String!
  node: LinkedBranch
}
input LockLockableInput {
  clientMutationId: String
  lockReason: LockReason
  lockableId: ID! @possibleTypes(concreteTypes: ["Discussion", "Issue", "PullRequest"], abstractType: "Lockable")
}
type LockLockablePayload {
  actor: Actor
  clientMutationId: String
  lockedRecord: Lockable
}
enum LockReason {
  OFF_TOPIC
  RESOLVED
  SPAM
  TOO_HEATED
}
interface Lockable {
  activeLockReason: LockReason
  locked: Boolean!
}
type LockedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  lockReason: LockReason
  lockable: Lockable!
}
type Mannequin implements Actor & Node & UniformResourceLocatable {
  avatarUrl(
    size: Int
  ): URI!
  claimant: User
  createdAt: DateTime!
  databaseId: Int
  email: String
  id: ID!
  login: String!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
}
type MannequinConnection {
  edges: [MannequinEdge]
  nodes: [Mannequin]
  pageInfo: PageInfo!
  totalCount: Int!
}
type MannequinEdge {
  cursor: String!
  node: Mannequin
}
input MannequinOrder {
  direction: OrderDirection!
  field: MannequinOrderField!
}
enum MannequinOrderField {
  CREATED_AT
  LOGIN
}
input MarkDiscussionCommentAsAnswerInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["DiscussionComment"])
}
type MarkDiscussionCommentAsAnswerPayload {
  clientMutationId: String
  discussion: Discussion
}
input MarkFileAsViewedInput {
  clientMutationId: String
  path: String!
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type MarkFileAsViewedPayload {
  clientMutationId: String
  pullRequest: PullRequest
}
input MarkProjectV2AsTemplateInput {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
type MarkProjectV2AsTemplatePayload {
  clientMutationId: String
  projectV2: ProjectV2
}
input MarkPullRequestReadyForReviewInput {
  clientMutationId: String
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type MarkPullRequestReadyForReviewPayload {
  clientMutationId: String
  pullRequest: PullRequest
}
type MarkedAsDuplicateEvent implements Node {
  actor: Actor
  canonical: IssueOrPullRequest
  createdAt: DateTime!
  duplicate: IssueOrPullRequest
  id: ID!
  isCrossRepository: Boolean!
}
type MarketplaceCategory implements Node {
  description: String
  howItWorks: String
  id: ID!
  name: String!
  primaryListingCount: Int!
  resourcePath: URI!
  secondaryListingCount: Int!
  slug: String!
  url: URI!
}
type MarketplaceListing implements Node {
  app: App
  companyUrl: URI
  configurationResourcePath: URI!
  configurationUrl: URI!
  documentationUrl: URI
  extendedDescription: String
  extendedDescriptionHTML: HTML!
  fullDescription: String!
  fullDescriptionHTML: HTML!
  hasPublishedFreeTrialPlans: Boolean!
  hasTermsOfService: Boolean!
  hasVerifiedOwner: Boolean!
  howItWorks: String
  howItWorksHTML: HTML!
  id: ID!
  installationUrl: URI
  installedForViewer: Boolean!
  isArchived: Boolean!
  isDraft: Boolean!
  isPaid: Boolean!
  isPublic: Boolean!
  isRejected: Boolean!
  isUnverified: Boolean!
  isUnverifiedPending: Boolean!
  isVerificationPendingFromDraft: Boolean!
  isVerificationPendingFromUnverified: Boolean!
  isVerified: Boolean!
  logoBackgroundColor: String!
  logoUrl(
    size: Int = 400
  ): URI
  name: String!
  normalizedShortDescription: String!
  pricingUrl: URI
  primaryCategory: MarketplaceCategory!
  privacyPolicyUrl: URI!
  resourcePath: URI!
  screenshotUrls: [String]!
  secondaryCategory: MarketplaceCategory
  shortDescription: String!
  slug: String!
  statusUrl: URI
  supportEmail: String
  supportUrl: URI!
  termsOfServiceUrl: URI
  url: URI!
  viewerCanAddPlans: Boolean!
  viewerCanApprove: Boolean!
  viewerCanDelist: Boolean!
  viewerCanEdit: Boolean!
  viewerCanEditCategories: Boolean!
  viewerCanEditPlans: Boolean!
  viewerCanRedraft: Boolean!
  viewerCanReject: Boolean!
  viewerCanRequestApproval: Boolean!
  viewerHasPurchased: Boolean!
  viewerHasPurchasedForAllOrganizations: Boolean!
  viewerIsListingAdmin: Boolean!
}
type MarketplaceListingConnection {
  edges: [MarketplaceListingEdge]
  nodes: [MarketplaceListing]
  pageInfo: PageInfo!
  totalCount: Int!
}
type MarketplaceListingEdge {
  cursor: String!
  node: MarketplaceListing
}
interface MemberStatusable {
  memberStatuses(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: UserStatusOrder = {field: UPDATED_AT, direction: DESC}
  ): UserStatusConnection!
}
type MembersCanDeleteReposClearAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type MembersCanDeleteReposDisableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type MembersCanDeleteReposEnableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type MentionedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
}
input MergeBranchInput {
  authorEmail: String
  base: String!
  clientMutationId: String
  commitMessage: String
  head: String!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type MergeBranchPayload {
  clientMutationId: String
  mergeCommit: Commit
}
enum MergeCommitMessage {
  BLANK
  PR_BODY
  PR_TITLE
}
enum MergeCommitTitle {
  MERGE_MESSAGE
  PR_TITLE
}
input MergePullRequestInput {
  authorEmail: String
  clientMutationId: String
  commitBody: String
  commitHeadline: String
  expectedHeadOid: GitObjectID
  mergeMethod: PullRequestMergeMethod = MERGE
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type MergePullRequestPayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
}
type MergeQueue implements Node {
  configuration: MergeQueueConfiguration
  entries(
    after: String
    before: String
    first: Int
    last: Int
  ): MergeQueueEntryConnection
  id: ID!
  nextEntryEstimatedTimeToMerge: Int
  repository: Repository
  resourcePath: URI!
  url: URI!
}
type MergeQueueConfiguration {
  checkResponseTimeout: Int
  maximumEntriesToBuild: Int
  maximumEntriesToMerge: Int
  mergeMethod: PullRequestMergeMethod
  mergingStrategy: MergeQueueMergingStrategy
  minimumEntriesToMerge: Int
  minimumEntriesToMergeWaitTime: Int
}
type MergeQueueEntry implements Node {
  baseCommit: Commit
  enqueuedAt: DateTime!
  enqueuer: Actor!
  estimatedTimeToMerge: Int
  headCommit: Commit
  id: ID!
  jump: Boolean!
  mergeQueue: MergeQueue
  position: Int!
  pullRequest: PullRequest
  solo: Boolean!
  state: MergeQueueEntryState!
}
type MergeQueueEntryConnection {
  edges: [MergeQueueEntryEdge]
  nodes: [MergeQueueEntry]
  pageInfo: PageInfo!
  totalCount: Int!
}
type MergeQueueEntryEdge {
  cursor: String!
  node: MergeQueueEntry
}
enum MergeQueueEntryState {
  AWAITING_CHECKS
  LOCKED
  MERGEABLE
  QUEUED
  UNMERGEABLE
}
enum MergeQueueMergingStrategy {
  ALLGREEN
  HEADGREEN
}
enum MergeStateStatus {
  BEHIND
  BLOCKED
  CLEAN
  DIRTY
  DRAFT
    @deprecated(
      reason: "DRAFT state will be removed from this enum and 'isDraft' should be used instead Use PullRequest.isDraft instead. Removal on 2021-01-01 UTC."
    )
  HAS_HOOKS
  UNKNOWN
  UNSTABLE
}
enum MergeableState {
  CONFLICTING
  MERGEABLE
  UNKNOWN
}
type MergedEvent implements Node & UniformResourceLocatable {
  actor: Actor
  commit: Commit
  createdAt: DateTime!
  id: ID!
  mergeRef: Ref
  mergeRefName: String!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
}
interface Migration {
  continueOnError: Boolean!
  createdAt: DateTime!
  databaseId: String
  failureReason: String
  id: ID!
  migrationLogUrl: URI
  migrationSource: MigrationSource!
  repositoryName: String!
  sourceUrl: URI!
  state: MigrationState!
  warningsCount: Int!
}
type MigrationSource implements Node {
  id: ID!
  name: String!
  type: MigrationSourceType!
  url: URI!
}
enum MigrationSourceType {
  AZURE_DEVOPS
  BITBUCKET_SERVER
  GITHUB_ARCHIVE
}
enum MigrationState {
  FAILED
  FAILED_VALIDATION
  IN_PROGRESS
  NOT_STARTED
  PENDING_VALIDATION
  QUEUED
  SUCCEEDED
}
type Milestone implements Closable & Node & UniformResourceLocatable {
  closed: Boolean!
  closedAt: DateTime
  createdAt: DateTime!
  creator: Actor
  description: String
  dueOn: DateTime
  id: ID!
  issues(
    after: String
    before: String
    filterBy: IssueFilters
    first: Int
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [IssueState!]
  ): IssueConnection!
  number: Int!
  progressPercentage: Float!
  pullRequests(
    after: String
    baseRefName: String
    before: String
    first: Int
    headRefName: String
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [PullRequestState!]
  ): PullRequestConnection!
  repository: Repository!
  resourcePath: URI!
  state: MilestoneState!
  title: String!
  updatedAt: DateTime!
  url: URI!
  viewerCanClose: Boolean!
  viewerCanReopen: Boolean!
}
type MilestoneConnection {
  edges: [MilestoneEdge]
  nodes: [Milestone]
  pageInfo: PageInfo!
  totalCount: Int!
}
type MilestoneEdge {
  cursor: String!
  node: Milestone
}
union MilestoneItem = Issue | PullRequest
input MilestoneOrder {
  direction: OrderDirection!
  field: MilestoneOrderField!
}
enum MilestoneOrderField {
  CREATED_AT
  DUE_DATE
  NUMBER
  UPDATED_AT
}
enum MilestoneState {
  CLOSED
  OPEN
}
type MilestonedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  milestoneTitle: String!
  subject: MilestoneItem!
}
interface Minimizable {
  isMinimized: Boolean!
  minimizedReason: String
  viewerCanMinimize: Boolean!
}
input MinimizeCommentInput {
  classifier: ReportedContentClassifiers!
  clientMutationId: String
  subjectId: ID!
    @possibleTypes(
      concreteTypes: ["CommitComment", "DiscussionComment", "GistComment", "IssueComment", "PullRequestReviewComment"]
      abstractType: "Minimizable"
    )
}
type MinimizeCommentPayload {
  clientMutationId: String
  minimizedComment: Minimizable
}
input MoveProjectCardInput {
  afterCardId: ID @possibleTypes(concreteTypes: ["ProjectCard"])
  cardId: ID! @possibleTypes(concreteTypes: ["ProjectCard"])
  clientMutationId: String
  columnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type MoveProjectCardPayload {
  cardEdge: ProjectCardEdge
  clientMutationId: String
}
input MoveProjectColumnInput {
  afterColumnId: ID @possibleTypes(concreteTypes: ["ProjectColumn"])
  clientMutationId: String
  columnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type MoveProjectColumnPayload {
  clientMutationId: String
  columnEdge: ProjectColumnEdge
}
type MovedColumnsInProjectEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  previousProjectColumnName: String! @preview(toggledBy: "starfox-preview")
  project: Project @preview(toggledBy: "starfox-preview")
  projectCard: ProjectCard @preview(toggledBy: "starfox-preview")
  projectColumnName: String! @preview(toggledBy: "starfox-preview")
}
type Mutation {
  abortQueuedMigrations(
    input: AbortQueuedMigrationsInput!
  ): AbortQueuedMigrationsPayload
  acceptEnterpriseAdministratorInvitation(
    input: AcceptEnterpriseAdministratorInvitationInput!
  ): AcceptEnterpriseAdministratorInvitationPayload
  acceptTopicSuggestion(
    input: AcceptTopicSuggestionInput!
  ): AcceptTopicSuggestionPayload
  addAssigneesToAssignable(
    input: AddAssigneesToAssignableInput!
  ): AddAssigneesToAssignablePayload
  addComment(
    input: AddCommentInput!
  ): AddCommentPayload
  addDiscussionComment(
    input: AddDiscussionCommentInput!
  ): AddDiscussionCommentPayload
  addDiscussionPollVote(
    input: AddDiscussionPollVoteInput!
  ): AddDiscussionPollVotePayload
  addEnterpriseOrganizationMember(
    input: AddEnterpriseOrganizationMemberInput!
  ): AddEnterpriseOrganizationMemberPayload
  addEnterpriseSupportEntitlement(
    input: AddEnterpriseSupportEntitlementInput!
  ): AddEnterpriseSupportEntitlementPayload
  addLabelsToLabelable(
    input: AddLabelsToLabelableInput!
  ): AddLabelsToLabelablePayload
  addProjectCard(
    input: AddProjectCardInput!
  ): AddProjectCardPayload
  addProjectColumn(
    input: AddProjectColumnInput!
  ): AddProjectColumnPayload
  addProjectV2DraftIssue(
    input: AddProjectV2DraftIssueInput!
  ): AddProjectV2DraftIssuePayload
  addProjectV2ItemById(
    input: AddProjectV2ItemByIdInput!
  ): AddProjectV2ItemByIdPayload
  addPullRequestReview(
    input: AddPullRequestReviewInput!
  ): AddPullRequestReviewPayload
  addPullRequestReviewComment(
    input: AddPullRequestReviewCommentInput!
  ): AddPullRequestReviewCommentPayload
  addPullRequestReviewThread(
    input: AddPullRequestReviewThreadInput!
  ): AddPullRequestReviewThreadPayload
  addReaction(
    input: AddReactionInput!
  ): AddReactionPayload
  addStar(
    input: AddStarInput!
  ): AddStarPayload
  addUpvote(
    input: AddUpvoteInput!
  ): AddUpvotePayload
  addVerifiableDomain(
    input: AddVerifiableDomainInput!
  ): AddVerifiableDomainPayload
  approveDeployments(
    input: ApproveDeploymentsInput!
  ): ApproveDeploymentsPayload
  approveVerifiableDomain(
    input: ApproveVerifiableDomainInput!
  ): ApproveVerifiableDomainPayload
  archiveProjectV2Item(
    input: ArchiveProjectV2ItemInput!
  ): ArchiveProjectV2ItemPayload
  archiveRepository(
    input: ArchiveRepositoryInput!
  ): ArchiveRepositoryPayload
  cancelEnterpriseAdminInvitation(
    input: CancelEnterpriseAdminInvitationInput!
  ): CancelEnterpriseAdminInvitationPayload
  cancelSponsorship(
    input: CancelSponsorshipInput!
  ): CancelSponsorshipPayload
  changeUserStatus(
    input: ChangeUserStatusInput!
  ): ChangeUserStatusPayload
  clearLabelsFromLabelable(
    input: ClearLabelsFromLabelableInput!
  ): ClearLabelsFromLabelablePayload
  clearProjectV2ItemFieldValue(
    input: ClearProjectV2ItemFieldValueInput!
  ): ClearProjectV2ItemFieldValuePayload
  cloneProject(
    input: CloneProjectInput!
  ): CloneProjectPayload
  cloneTemplateRepository(
    input: CloneTemplateRepositoryInput!
  ): CloneTemplateRepositoryPayload
  closeDiscussion(
    input: CloseDiscussionInput!
  ): CloseDiscussionPayload
  closeIssue(
    input: CloseIssueInput!
  ): CloseIssuePayload
  closePullRequest(
    input: ClosePullRequestInput!
  ): ClosePullRequestPayload
  convertProjectCardNoteToIssue(
    input: ConvertProjectCardNoteToIssueInput!
  ): ConvertProjectCardNoteToIssuePayload
  convertPullRequestToDraft(
    input: ConvertPullRequestToDraftInput!
  ): ConvertPullRequestToDraftPayload
  copyProjectV2(
    input: CopyProjectV2Input!
  ): CopyProjectV2Payload
  createAttributionInvitation(
    input: CreateAttributionInvitationInput!
  ): CreateAttributionInvitationPayload
  createBranchProtectionRule(
    input: CreateBranchProtectionRuleInput!
  ): CreateBranchProtectionRulePayload
  createCheckRun(
    input: CreateCheckRunInput!
  ): CreateCheckRunPayload
  createCheckSuite(
    input: CreateCheckSuiteInput!
  ): CreateCheckSuitePayload
  createCommitOnBranch(
    input: CreateCommitOnBranchInput!
  ): CreateCommitOnBranchPayload
  createDeployment(
    input: CreateDeploymentInput!
  ): CreateDeploymentPayload @preview(toggledBy: "flash-preview")
  createDeploymentStatus(
    input: CreateDeploymentStatusInput!
  ): CreateDeploymentStatusPayload @preview(toggledBy: "flash-preview")
  createDiscussion(
    input: CreateDiscussionInput!
  ): CreateDiscussionPayload
  createEnterpriseOrganization(
    input: CreateEnterpriseOrganizationInput!
  ): CreateEnterpriseOrganizationPayload
  createEnvironment(
    input: CreateEnvironmentInput!
  ): CreateEnvironmentPayload
  createIpAllowListEntry(
    input: CreateIpAllowListEntryInput!
  ): CreateIpAllowListEntryPayload
  createIssue(
    input: CreateIssueInput!
  ): CreateIssuePayload
  createLabel(
    input: CreateLabelInput!
  ): CreateLabelPayload @preview(toggledBy: "bane-preview")
  createLinkedBranch(
    input: CreateLinkedBranchInput!
  ): CreateLinkedBranchPayload
  createMigrationSource(
    input: CreateMigrationSourceInput!
  ): CreateMigrationSourcePayload
  createProject(
    input: CreateProjectInput!
  ): CreateProjectPayload
  createProjectV2(
    input: CreateProjectV2Input!
  ): CreateProjectV2Payload
  createProjectV2Field(
    input: CreateProjectV2FieldInput!
  ): CreateProjectV2FieldPayload
  createPullRequest(
    input: CreatePullRequestInput!
  ): CreatePullRequestPayload
  createRef(
    input: CreateRefInput!
  ): CreateRefPayload
  createRepository(
    input: CreateRepositoryInput!
  ): CreateRepositoryPayload
  createRepositoryRuleset(
    input: CreateRepositoryRulesetInput!
  ): CreateRepositoryRulesetPayload
  createSponsorsListing(
    input: CreateSponsorsListingInput!
  ): CreateSponsorsListingPayload
  createSponsorsTier(
    input: CreateSponsorsTierInput!
  ): CreateSponsorsTierPayload
  createSponsorship(
    input: CreateSponsorshipInput!
  ): CreateSponsorshipPayload
  createSponsorships(
    input: CreateSponsorshipsInput!
  ): CreateSponsorshipsPayload
  createTeamDiscussion(
    input: CreateTeamDiscussionInput!
  ): CreateTeamDiscussionPayload
  createTeamDiscussionComment(
    input: CreateTeamDiscussionCommentInput!
  ): CreateTeamDiscussionCommentPayload
  declineTopicSuggestion(
    input: DeclineTopicSuggestionInput!
  ): DeclineTopicSuggestionPayload
  deleteBranchProtectionRule(
    input: DeleteBranchProtectionRuleInput!
  ): DeleteBranchProtectionRulePayload
  deleteDeployment(
    input: DeleteDeploymentInput!
  ): DeleteDeploymentPayload
  deleteDiscussion(
    input: DeleteDiscussionInput!
  ): DeleteDiscussionPayload
  deleteDiscussionComment(
    input: DeleteDiscussionCommentInput!
  ): DeleteDiscussionCommentPayload
  deleteEnvironment(
    input: DeleteEnvironmentInput!
  ): DeleteEnvironmentPayload
  deleteIpAllowListEntry(
    input: DeleteIpAllowListEntryInput!
  ): DeleteIpAllowListEntryPayload
  deleteIssue(
    input: DeleteIssueInput!
  ): DeleteIssuePayload
  deleteIssueComment(
    input: DeleteIssueCommentInput!
  ): DeleteIssueCommentPayload
  deleteLabel(
    input: DeleteLabelInput!
  ): DeleteLabelPayload @preview(toggledBy: "bane-preview")
  deleteLinkedBranch(
    input: DeleteLinkedBranchInput!
  ): DeleteLinkedBranchPayload
  deletePackageVersion(
    input: DeletePackageVersionInput!
  ): DeletePackageVersionPayload @preview(toggledBy: "package-deletes-preview")
  deleteProject(
    input: DeleteProjectInput!
  ): DeleteProjectPayload
  deleteProjectCard(
    input: DeleteProjectCardInput!
  ): DeleteProjectCardPayload
  deleteProjectColumn(
    input: DeleteProjectColumnInput!
  ): DeleteProjectColumnPayload
  deleteProjectV2(
    input: DeleteProjectV2Input!
  ): DeleteProjectV2Payload
  deleteProjectV2Field(
    input: DeleteProjectV2FieldInput!
  ): DeleteProjectV2FieldPayload
  deleteProjectV2Item(
    input: DeleteProjectV2ItemInput!
  ): DeleteProjectV2ItemPayload
  deleteProjectV2Workflow(
    input: DeleteProjectV2WorkflowInput!
  ): DeleteProjectV2WorkflowPayload
  deletePullRequestReview(
    input: DeletePullRequestReviewInput!
  ): DeletePullRequestReviewPayload
  deletePullRequestReviewComment(
    input: DeletePullRequestReviewCommentInput!
  ): DeletePullRequestReviewCommentPayload
  deleteRef(
    input: DeleteRefInput!
  ): DeleteRefPayload
  deleteRepositoryRuleset(
    input: DeleteRepositoryRulesetInput!
  ): DeleteRepositoryRulesetPayload
  deleteTeamDiscussion(
    input: DeleteTeamDiscussionInput!
  ): DeleteTeamDiscussionPayload
  deleteTeamDiscussionComment(
    input: DeleteTeamDiscussionCommentInput!
  ): DeleteTeamDiscussionCommentPayload
  deleteVerifiableDomain(
    input: DeleteVerifiableDomainInput!
  ): DeleteVerifiableDomainPayload
  dequeuePullRequest(
    input: DequeuePullRequestInput!
  ): DequeuePullRequestPayload
  disablePullRequestAutoMerge(
    input: DisablePullRequestAutoMergeInput!
  ): DisablePullRequestAutoMergePayload
  dismissPullRequestReview(
    input: DismissPullRequestReviewInput!
  ): DismissPullRequestReviewPayload
  dismissRepositoryVulnerabilityAlert(
    input: DismissRepositoryVulnerabilityAlertInput!
  ): DismissRepositoryVulnerabilityAlertPayload
  enablePullRequestAutoMerge(
    input: EnablePullRequestAutoMergeInput!
  ): EnablePullRequestAutoMergePayload
  enqueuePullRequest(
    input: EnqueuePullRequestInput!
  ): EnqueuePullRequestPayload
  followOrganization(
    input: FollowOrganizationInput!
  ): FollowOrganizationPayload
  followUser(
    input: FollowUserInput!
  ): FollowUserPayload
  grantEnterpriseOrganizationsMigratorRole(
    input: GrantEnterpriseOrganizationsMigratorRoleInput!
  ): GrantEnterpriseOrganizationsMigratorRolePayload
  grantMigratorRole(
    input: GrantMigratorRoleInput!
  ): GrantMigratorRolePayload
  importProject(
    input: ImportProjectInput!
  ): ImportProjectPayload @preview(toggledBy: "slothette-preview")
  inviteEnterpriseAdmin(
    input: InviteEnterpriseAdminInput!
  ): InviteEnterpriseAdminPayload
  linkProjectV2ToRepository(
    input: LinkProjectV2ToRepositoryInput!
  ): LinkProjectV2ToRepositoryPayload
  linkProjectV2ToTeam(
    input: LinkProjectV2ToTeamInput!
  ): LinkProjectV2ToTeamPayload
  linkRepositoryToProject(
    input: LinkRepositoryToProjectInput!
  ): LinkRepositoryToProjectPayload
  lockLockable(
    input: LockLockableInput!
  ): LockLockablePayload
  markDiscussionCommentAsAnswer(
    input: MarkDiscussionCommentAsAnswerInput!
  ): MarkDiscussionCommentAsAnswerPayload
  markFileAsViewed(
    input: MarkFileAsViewedInput!
  ): MarkFileAsViewedPayload
  markProjectV2AsTemplate(
    input: MarkProjectV2AsTemplateInput!
  ): MarkProjectV2AsTemplatePayload
  markPullRequestReadyForReview(
    input: MarkPullRequestReadyForReviewInput!
  ): MarkPullRequestReadyForReviewPayload
  mergeBranch(
    input: MergeBranchInput!
  ): MergeBranchPayload
  mergePullRequest(
    input: MergePullRequestInput!
  ): MergePullRequestPayload
  minimizeComment(
    input: MinimizeCommentInput!
  ): MinimizeCommentPayload
  moveProjectCard(
    input: MoveProjectCardInput!
  ): MoveProjectCardPayload
  moveProjectColumn(
    input: MoveProjectColumnInput!
  ): MoveProjectColumnPayload
  pinIssue(
    input: PinIssueInput!
  ): PinIssuePayload
  publishSponsorsTier(
    input: PublishSponsorsTierInput!
  ): PublishSponsorsTierPayload
  regenerateEnterpriseIdentityProviderRecoveryCodes(
    input: RegenerateEnterpriseIdentityProviderRecoveryCodesInput!
  ): RegenerateEnterpriseIdentityProviderRecoveryCodesPayload
  regenerateVerifiableDomainToken(
    input: RegenerateVerifiableDomainTokenInput!
  ): RegenerateVerifiableDomainTokenPayload
  rejectDeployments(
    input: RejectDeploymentsInput!
  ): RejectDeploymentsPayload
  removeAssigneesFromAssignable(
    input: RemoveAssigneesFromAssignableInput!
  ): RemoveAssigneesFromAssignablePayload
  removeEnterpriseAdmin(
    input: RemoveEnterpriseAdminInput!
  ): RemoveEnterpriseAdminPayload
  removeEnterpriseIdentityProvider(
    input: RemoveEnterpriseIdentityProviderInput!
  ): RemoveEnterpriseIdentityProviderPayload
  removeEnterpriseMember(
    input: RemoveEnterpriseMemberInput!
  ): RemoveEnterpriseMemberPayload
  removeEnterpriseOrganization(
    input: RemoveEnterpriseOrganizationInput!
  ): RemoveEnterpriseOrganizationPayload
  removeEnterpriseSupportEntitlement(
    input: RemoveEnterpriseSupportEntitlementInput!
  ): RemoveEnterpriseSupportEntitlementPayload
  removeLabelsFromLabelable(
    input: RemoveLabelsFromLabelableInput!
  ): RemoveLabelsFromLabelablePayload
  removeOutsideCollaborator(
    input: RemoveOutsideCollaboratorInput!
  ): RemoveOutsideCollaboratorPayload
  removeReaction(
    input: RemoveReactionInput!
  ): RemoveReactionPayload
  removeStar(
    input: RemoveStarInput!
  ): RemoveStarPayload
  removeUpvote(
    input: RemoveUpvoteInput!
  ): RemoveUpvotePayload
  reopenDiscussion(
    input: ReopenDiscussionInput!
  ): ReopenDiscussionPayload
  reopenIssue(
    input: ReopenIssueInput!
  ): ReopenIssuePayload
  reopenPullRequest(
    input: ReopenPullRequestInput!
  ): ReopenPullRequestPayload
  requestReviews(
    input: RequestReviewsInput!
  ): RequestReviewsPayload
  rerequestCheckSuite(
    input: RerequestCheckSuiteInput!
  ): RerequestCheckSuitePayload
  resolveReviewThread(
    input: ResolveReviewThreadInput!
  ): ResolveReviewThreadPayload
  retireSponsorsTier(
    input: RetireSponsorsTierInput!
  ): RetireSponsorsTierPayload
  revertPullRequest(
    input: RevertPullRequestInput!
  ): RevertPullRequestPayload
  revokeEnterpriseOrganizationsMigratorRole(
    input: RevokeEnterpriseOrganizationsMigratorRoleInput!
  ): RevokeEnterpriseOrganizationsMigratorRolePayload
  revokeMigratorRole(
    input: RevokeMigratorRoleInput!
  ): RevokeMigratorRolePayload
  setEnterpriseIdentityProvider(
    input: SetEnterpriseIdentityProviderInput!
  ): SetEnterpriseIdentityProviderPayload
  setOrganizationInteractionLimit(
    input: SetOrganizationInteractionLimitInput!
  ): SetOrganizationInteractionLimitPayload
  setRepositoryInteractionLimit(
    input: SetRepositoryInteractionLimitInput!
  ): SetRepositoryInteractionLimitPayload
  setUserInteractionLimit(
    input: SetUserInteractionLimitInput!
  ): SetUserInteractionLimitPayload
  startOrganizationMigration(
    input: StartOrganizationMigrationInput!
  ): StartOrganizationMigrationPayload
  startRepositoryMigration(
    input: StartRepositoryMigrationInput!
  ): StartRepositoryMigrationPayload
  submitPullRequestReview(
    input: SubmitPullRequestReviewInput!
  ): SubmitPullRequestReviewPayload
  transferEnterpriseOrganization(
    input: TransferEnterpriseOrganizationInput!
  ): TransferEnterpriseOrganizationPayload
  transferIssue(
    input: TransferIssueInput!
  ): TransferIssuePayload
  unarchiveProjectV2Item(
    input: UnarchiveProjectV2ItemInput!
  ): UnarchiveProjectV2ItemPayload
  unarchiveRepository(
    input: UnarchiveRepositoryInput!
  ): UnarchiveRepositoryPayload
  unfollowOrganization(
    input: UnfollowOrganizationInput!
  ): UnfollowOrganizationPayload
  unfollowUser(
    input: UnfollowUserInput!
  ): UnfollowUserPayload
  unlinkProjectV2FromRepository(
    input: UnlinkProjectV2FromRepositoryInput!
  ): UnlinkProjectV2FromRepositoryPayload
  unlinkProjectV2FromTeam(
    input: UnlinkProjectV2FromTeamInput!
  ): UnlinkProjectV2FromTeamPayload
  unlinkRepositoryFromProject(
    input: UnlinkRepositoryFromProjectInput!
  ): UnlinkRepositoryFromProjectPayload
  unlockLockable(
    input: UnlockLockableInput!
  ): UnlockLockablePayload
  unmarkDiscussionCommentAsAnswer(
    input: UnmarkDiscussionCommentAsAnswerInput!
  ): UnmarkDiscussionCommentAsAnswerPayload
  unmarkFileAsViewed(
    input: UnmarkFileAsViewedInput!
  ): UnmarkFileAsViewedPayload
  unmarkIssueAsDuplicate(
    input: UnmarkIssueAsDuplicateInput!
  ): UnmarkIssueAsDuplicatePayload
  unmarkProjectV2AsTemplate(
    input: UnmarkProjectV2AsTemplateInput!
  ): UnmarkProjectV2AsTemplatePayload
  unminimizeComment(
    input: UnminimizeCommentInput!
  ): UnminimizeCommentPayload
  unpinIssue(
    input: UnpinIssueInput!
  ): UnpinIssuePayload
  unresolveReviewThread(
    input: UnresolveReviewThreadInput!
  ): UnresolveReviewThreadPayload
  updateBranchProtectionRule(
    input: UpdateBranchProtectionRuleInput!
  ): UpdateBranchProtectionRulePayload
  updateCheckRun(
    input: UpdateCheckRunInput!
  ): UpdateCheckRunPayload
  updateCheckSuitePreferences(
    input: UpdateCheckSuitePreferencesInput!
  ): UpdateCheckSuitePreferencesPayload
  updateDiscussion(
    input: UpdateDiscussionInput!
  ): UpdateDiscussionPayload
  updateDiscussionComment(
    input: UpdateDiscussionCommentInput!
  ): UpdateDiscussionCommentPayload
  updateEnterpriseAdministratorRole(
    input: UpdateEnterpriseAdministratorRoleInput!
  ): UpdateEnterpriseAdministratorRolePayload
  updateEnterpriseAllowPrivateRepositoryForkingSetting(
    input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput!
  ): UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload
  updateEnterpriseDefaultRepositoryPermissionSetting(
    input: UpdateEnterpriseDefaultRepositoryPermissionSettingInput!
  ): UpdateEnterpriseDefaultRepositoryPermissionSettingPayload
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting(
    input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput!
  ): UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload
  updateEnterpriseMembersCanCreateRepositoriesSetting(
    input: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput!
  ): UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload
  updateEnterpriseMembersCanDeleteIssuesSetting(
    input: UpdateEnterpriseMembersCanDeleteIssuesSettingInput!
  ): UpdateEnterpriseMembersCanDeleteIssuesSettingPayload
  updateEnterpriseMembersCanDeleteRepositoriesSetting(
    input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput!
  ): UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload
  updateEnterpriseMembersCanInviteCollaboratorsSetting(
    input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput!
  ): UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload
  updateEnterpriseMembersCanMakePurchasesSetting(
    input: UpdateEnterpriseMembersCanMakePurchasesSettingInput!
  ): UpdateEnterpriseMembersCanMakePurchasesSettingPayload
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting(
    input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput!
  ): UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload
  updateEnterpriseMembersCanViewDependencyInsightsSetting(
    input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput!
  ): UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload
  updateEnterpriseOrganizationProjectsSetting(
    input: UpdateEnterpriseOrganizationProjectsSettingInput!
  ): UpdateEnterpriseOrganizationProjectsSettingPayload
  updateEnterpriseOwnerOrganizationRole(
    input: UpdateEnterpriseOwnerOrganizationRoleInput!
  ): UpdateEnterpriseOwnerOrganizationRolePayload
  updateEnterpriseProfile(
    input: UpdateEnterpriseProfileInput!
  ): UpdateEnterpriseProfilePayload
  updateEnterpriseRepositoryProjectsSetting(
    input: UpdateEnterpriseRepositoryProjectsSettingInput!
  ): UpdateEnterpriseRepositoryProjectsSettingPayload
  updateEnterpriseTeamDiscussionsSetting(
    input: UpdateEnterpriseTeamDiscussionsSettingInput!
  ): UpdateEnterpriseTeamDiscussionsSettingPayload
  updateEnterpriseTwoFactorAuthenticationRequiredSetting(
    input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput!
  ): UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload
  updateEnvironment(
    input: UpdateEnvironmentInput!
  ): UpdateEnvironmentPayload
  updateIpAllowListEnabledSetting(
    input: UpdateIpAllowListEnabledSettingInput!
  ): UpdateIpAllowListEnabledSettingPayload
  updateIpAllowListEntry(
    input: UpdateIpAllowListEntryInput!
  ): UpdateIpAllowListEntryPayload
  updateIpAllowListForInstalledAppsEnabledSetting(
    input: UpdateIpAllowListForInstalledAppsEnabledSettingInput!
  ): UpdateIpAllowListForInstalledAppsEnabledSettingPayload
  updateIssue(
    input: UpdateIssueInput!
  ): UpdateIssuePayload
  updateIssueComment(
    input: UpdateIssueCommentInput!
  ): UpdateIssueCommentPayload
  updateLabel(
    input: UpdateLabelInput!
  ): UpdateLabelPayload @preview(toggledBy: "bane-preview")
  updateNotificationRestrictionSetting(
    input: UpdateNotificationRestrictionSettingInput!
  ): UpdateNotificationRestrictionSettingPayload
  updateOrganizationAllowPrivateRepositoryForkingSetting(
    input: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput!
  ): UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload
  updateOrganizationWebCommitSignoffSetting(
    input: UpdateOrganizationWebCommitSignoffSettingInput!
  ): UpdateOrganizationWebCommitSignoffSettingPayload
  updateProject(
    input: UpdateProjectInput!
  ): UpdateProjectPayload
  updateProjectCard(
    input: UpdateProjectCardInput!
  ): UpdateProjectCardPayload
  updateProjectColumn(
    input: UpdateProjectColumnInput!
  ): UpdateProjectColumnPayload
  updateProjectV2(
    input: UpdateProjectV2Input!
  ): UpdateProjectV2Payload
  updateProjectV2Collaborators(
    input: UpdateProjectV2CollaboratorsInput!
  ): UpdateProjectV2CollaboratorsPayload
  updateProjectV2DraftIssue(
    input: UpdateProjectV2DraftIssueInput!
  ): UpdateProjectV2DraftIssuePayload
  updateProjectV2ItemFieldValue(
    input: UpdateProjectV2ItemFieldValueInput!
  ): UpdateProjectV2ItemFieldValuePayload
  updateProjectV2ItemPosition(
    input: UpdateProjectV2ItemPositionInput!
  ): UpdateProjectV2ItemPositionPayload
  updatePullRequest(
    input: UpdatePullRequestInput!
  ): UpdatePullRequestPayload
  updatePullRequestBranch(
    input: UpdatePullRequestBranchInput!
  ): UpdatePullRequestBranchPayload
  updatePullRequestReview(
    input: UpdatePullRequestReviewInput!
  ): UpdatePullRequestReviewPayload
  updatePullRequestReviewComment(
    input: UpdatePullRequestReviewCommentInput!
  ): UpdatePullRequestReviewCommentPayload
  updateRef(
    input: UpdateRefInput!
  ): UpdateRefPayload
  updateRefs(
    input: UpdateRefsInput!
  ): UpdateRefsPayload @preview(toggledBy: "update-refs-preview")
  updateRepository(
    input: UpdateRepositoryInput!
  ): UpdateRepositoryPayload
  updateRepositoryRuleset(
    input: UpdateRepositoryRulesetInput!
  ): UpdateRepositoryRulesetPayload
  updateRepositoryWebCommitSignoffSetting(
    input: UpdateRepositoryWebCommitSignoffSettingInput!
  ): UpdateRepositoryWebCommitSignoffSettingPayload
  updateSponsorshipPreferences(
    input: UpdateSponsorshipPreferencesInput!
  ): UpdateSponsorshipPreferencesPayload
  updateSubscription(
    input: UpdateSubscriptionInput!
  ): UpdateSubscriptionPayload
  updateTeamDiscussion(
    input: UpdateTeamDiscussionInput!
  ): UpdateTeamDiscussionPayload
  updateTeamDiscussionComment(
    input: UpdateTeamDiscussionCommentInput!
  ): UpdateTeamDiscussionCommentPayload
  updateTeamReviewAssignment(
    input: UpdateTeamReviewAssignmentInput!
  ): UpdateTeamReviewAssignmentPayload @preview(toggledBy: "stone-crop-preview")
  updateTeamsRepository(
    input: UpdateTeamsRepositoryInput!
  ): UpdateTeamsRepositoryPayload
  updateTopics(
    input: UpdateTopicsInput!
  ): UpdateTopicsPayload
  verifyVerifiableDomain(
    input: VerifyVerifiableDomainInput!
  ): VerifyVerifiableDomainPayload
}
interface Node {
  id: ID!
}
enum NotificationRestrictionSettingValue {
  DISABLED
  ENABLED
}
type OIDCProvider implements Node {
  enterprise: Enterprise
  externalIdentities(
    after: String
    before: String
    first: Int
    last: Int
    login: String
    membersOnly: Boolean
    userName: String
  ): ExternalIdentityConnection!
  id: ID!
  providerType: OIDCProviderType!
  tenantId: String!
}
enum OIDCProviderType {
  AAD
}
interface OauthApplicationAuditEntryData {
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
}
type OauthApplicationCreateAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  applicationUrl: URI
  callbackUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  rateLimit: Int
  state: OauthApplicationCreateAuditEntryState
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum OauthApplicationCreateAuditEntryState {
  ACTIVE
  PENDING_DELETION
  SUSPENDED
}
enum OperationType {
  ACCESS
  AUTHENTICATION
  CREATE
  MODIFY
  REMOVE
  RESTORE
  TRANSFER
}
enum OrderDirection {
  ASC
  DESC
}
type OrgAddBillingManagerAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  invitationEmail: String
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgAddMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  permission: OrgAddMemberAuditEntryPermission
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum OrgAddMemberAuditEntryPermission {
  ADMIN
  READ
}
type OrgBlockUserAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  blockedUser: User
  blockedUserName: String
  blockedUserResourcePath: URI
  blockedUserUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgConfigDisableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgConfigEnableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgCreateAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  billingPlan: OrgCreateAuditEntryBillingPlan
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum OrgCreateAuditEntryBillingPlan {
  BUSINESS
  BUSINESS_PLUS
  FREE
  TIERED_PER_SEAT
  UNLIMITED
}
type OrgDisableOauthAppRestrictionsAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgDisableSamlAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  digestMethodUrl: URI
  id: ID!
  issuerUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  signatureMethodUrl: URI
  singleSignOnUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgDisableTwoFactorRequirementAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgEnableOauthAppRestrictionsAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgEnableSamlAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  digestMethodUrl: URI
  id: ID!
  issuerUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  signatureMethodUrl: URI
  singleSignOnUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgEnableTwoFactorRequirementAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
input OrgEnterpriseOwnerOrder {
  direction: OrderDirection!
  field: OrgEnterpriseOwnerOrderField!
}
enum OrgEnterpriseOwnerOrderField {
  LOGIN
}
type OrgInviteMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  email: String
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationInvitation: OrganizationInvitation
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgInviteToBusinessAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgOauthAppAccessApprovedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgOauthAppAccessBlockedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgOauthAppAccessDeniedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgOauthAppAccessRequestedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgOauthAppAccessUnblockedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgRemoveBillingManagerAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  reason: OrgRemoveBillingManagerAuditEntryReason
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum OrgRemoveBillingManagerAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE
}
type OrgRemoveMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  membershipTypes: [OrgRemoveMemberAuditEntryMembershipType!]
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  reason: OrgRemoveMemberAuditEntryReason
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum OrgRemoveMemberAuditEntryMembershipType {
  ADMIN
  BILLING_MANAGER
  DIRECT_MEMBER
  OUTSIDE_COLLABORATOR
  SUSPENDED
  UNAFFILIATED
}
enum OrgRemoveMemberAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY
  TWO_FACTOR_ACCOUNT_RECOVERY
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE
  USER_ACCOUNT_DELETED
}
type OrgRemoveOutsideCollaboratorAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  membershipTypes: [OrgRemoveOutsideCollaboratorAuditEntryMembershipType!]
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  reason: OrgRemoveOutsideCollaboratorAuditEntryReason
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  BILLING_MANAGER
  OUTSIDE_COLLABORATOR
  UNAFFILIATED
}
enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE
}
type OrgRestoreMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  restoredCustomEmailRoutingsCount: Int
  restoredIssueAssignmentsCount: Int
  restoredMemberships: [OrgRestoreMemberAuditEntryMembership!]
  restoredMembershipsCount: Int
  restoredRepositoriesCount: Int
  restoredRepositoryStarsCount: Int
  restoredRepositoryWatchesCount: Int
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
union OrgRestoreMemberAuditEntryMembership =
    OrgRestoreMemberMembershipOrganizationAuditEntryData
  | OrgRestoreMemberMembershipRepositoryAuditEntryData
  | OrgRestoreMemberMembershipTeamAuditEntryData
type OrgRestoreMemberMembershipOrganizationAuditEntryData implements OrganizationAuditEntryData {
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
}
type OrgRestoreMemberMembershipRepositoryAuditEntryData implements RepositoryAuditEntryData {
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
}
type OrgRestoreMemberMembershipTeamAuditEntryData implements TeamAuditEntryData {
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
}
type OrgUnblockUserAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  blockedUser: User
  blockedUserName: String
  blockedUserResourcePath: URI
  blockedUserUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type OrgUpdateDefaultRepositoryPermissionAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  permission: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
  permissionWas: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  ADMIN
  NONE
  READ
  WRITE
}
type OrgUpdateMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  permission: OrgUpdateMemberAuditEntryPermission
  permissionWas: OrgUpdateMemberAuditEntryPermission
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum OrgUpdateMemberAuditEntryPermission {
  ADMIN
  READ
}
type OrgUpdateMemberRepositoryCreationPermissionAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  canCreateRepositories: Boolean
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
}
enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  ALL
  INTERNAL
  NONE
  PRIVATE
  PRIVATE_INTERNAL
  PUBLIC
  PUBLIC_INTERNAL
  PUBLIC_PRIVATE
}
type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  canInviteOutsideCollaboratorsToRepositories: Boolean
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type Organization implements Actor & AnnouncementBanner & MemberStatusable & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable {
  announcement: String
  announcementExpiresAt: DateTime
  announcementUserDismissible: Boolean
  anyPinnableItems(
    type: PinnableItemType
  ): Boolean!
  auditLog(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: AuditLogOrder = {field: CREATED_AT, direction: DESC}
    query: String
  ): OrganizationAuditEntryConnection!
  avatarUrl(
    size: Int
  ): URI!
  createdAt: DateTime!
  databaseId: Int
  description: String
  descriptionHTML: String
  domains(
    after: String
    before: String
    first: Int
    isApproved: Boolean = null
    isVerified: Boolean = null
    last: Int
    orderBy: VerifiableDomainOrder = {field: DOMAIN, direction: ASC}
  ): VerifiableDomainConnection
  email: String
  enterpriseOwners(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrgEnterpriseOwnerOrder = {field: LOGIN, direction: ASC}
    organizationRole: RoleInOrganization
    query: String
  ): OrganizationEnterpriseOwnerConnection!
  estimatedNextSponsorsPayoutInCents: Int!
  hasSponsorsListing: Boolean!
  id: ID!
  interactionAbility: RepositoryInteractionAbility
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue!
  ipAllowListEntries(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: IpAllowListEntryOrder = {field: ALLOW_LIST_VALUE, direction: ASC}
  ): IpAllowListEntryConnection!
  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue!
  isSponsoredBy(
    accountLogin: String!
  ): Boolean!
  isSponsoringViewer: Boolean!
  isVerified: Boolean!
  itemShowcase: ProfileItemShowcase!
  location: String
  login: String!
  mannequins(
    after: String
    before: String
    first: Int
    last: Int
    login: String
    orderBy: MannequinOrder = {field: CREATED_AT, direction: ASC}
  ): MannequinConnection!
  memberStatuses(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: UserStatusOrder = {field: UPDATED_AT, direction: DESC}
  ): UserStatusConnection!
  membersCanForkPrivateRepositories: Boolean!
  membersWithRole(
    after: String
    before: String
    first: Int
    last: Int
  ): OrganizationMemberConnection!
  monthlyEstimatedSponsorsIncomeInCents: Int!
  name: String
  newTeamResourcePath: URI!
  newTeamUrl: URI!
  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue!
  organizationBillingEmail: String
  packages(
    after: String
    before: String
    first: Int
    last: Int
    names: [String]
    orderBy: PackageOrder = {field: CREATED_AT, direction: DESC}
    packageType: PackageType
    repositoryId: ID
  ): PackageConnection!
  pendingMembers(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  pinnableItems(
    after: String
    before: String
    first: Int
    last: Int
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  pinnedItems(
    after: String
    before: String
    first: Int
    last: Int
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  pinnedItemsRemaining: Int!
  project(
    number: Int!
  ): Project
  projectV2(
    number: Int!
  ): ProjectV2
  projects(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectOrder
    search: String
    states: [ProjectState!]
  ): ProjectConnection!
  projectsResourcePath: URI!
  projectsUrl: URI!
  projectsV2(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2Order = {field: NUMBER, direction: DESC}
    query: String
  ): ProjectV2Connection!
  recentProjects(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2Connection!
  repositories(
    affiliations: [RepositoryAffiliation]
    after: String
    before: String
    first: Int
    hasIssuesEnabled: Boolean
    isArchived: Boolean
    isFork: Boolean
    isLocked: Boolean
    last: Int
    orderBy: RepositoryOrder
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  repository(
    followRenames: Boolean = true
    name: String!
  ): Repository
  repositoryDiscussionComments(
    after: String
    before: String
    first: Int
    last: Int
    onlyAnswers: Boolean = false
    repositoryId: ID
  ): DiscussionCommentConnection!
  repositoryDiscussions(
    after: String
    answered: Boolean = null
    before: String
    first: Int
    last: Int
    orderBy: DiscussionOrder = {field: CREATED_AT, direction: DESC}
    repositoryId: ID
    states: [DiscussionState!] = []
  ): DiscussionConnection!
  repositoryMigrations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: RepositoryMigrationOrder = {field: CREATED_AT, direction: ASC}
    repositoryName: String
    state: MigrationState
  ): RepositoryMigrationConnection!
  requiresTwoFactorAuthentication: Boolean
  resourcePath: URI!
  ruleset(
    databaseId: Int!
  ): RepositoryRuleset
  rulesets(
    after: String
    before: String
    first: Int
    includeParents: Boolean = true
    last: Int
  ): RepositoryRulesetConnection
  samlIdentityProvider: OrganizationIdentityProvider
  sponsoring(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SponsorOrder = {field: RELEVANCE, direction: DESC}
  ): SponsorConnection!
  sponsors(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SponsorOrder = {field: RELEVANCE, direction: DESC}
    tierId: ID
  ): SponsorConnection!
  sponsorsActivities(
    actions: [SponsorsActivityAction!] = []
    after: String
    before: String
    first: Int
    includeAsSponsor: Boolean = false
    includePrivate: Boolean = true
    last: Int
    orderBy: SponsorsActivityOrder = {field: TIMESTAMP, direction: DESC}
    period: SponsorsActivityPeriod = MONTH
    since: DateTime
    until: DateTime
  ): SponsorsActivityConnection!
  sponsorsListing: SponsorsListing
  sponsorshipForViewerAsSponsor(
    activeOnly: Boolean = true
  ): Sponsorship
  sponsorshipForViewerAsSponsorable(
    activeOnly: Boolean = true
  ): Sponsorship
  sponsorshipNewsletters(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SponsorshipNewsletterOrder = {field: CREATED_AT, direction: DESC}
  ): SponsorshipNewsletterConnection!
  sponsorshipsAsMaintainer(
    activeOnly: Boolean = true
    after: String
    before: String
    first: Int
    includePrivate: Boolean = false
    last: Int
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  sponsorshipsAsSponsor(
    activeOnly: Boolean = true
    after: String
    before: String
    first: Int
    last: Int
    maintainerLogins: [String!]
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  team(
    slug: String!
  ): Team
  teams(
    after: String
    before: String
    first: Int
    last: Int
    ldapMapped: Boolean
    notificationSetting: TeamNotificationSetting
    orderBy: TeamOrder
    privacy: TeamPrivacy
    query: String
    role: TeamRole
    rootTeamsOnly: Boolean = false
    userLogins: [String!]
  ): TeamConnection!
  teamsResourcePath: URI!
  teamsUrl: URI!
  totalSponsorshipAmountAsSponsorInCents(
    since: DateTime
    sponsorableLogins: [String!] = []
    until: DateTime
  ): Int
  twitterUsername: String
  updatedAt: DateTime!
  url: URI!
  viewerCanAdminister: Boolean!
  viewerCanChangePinnedItems: Boolean!
  viewerCanCreateProjects: Boolean!
  viewerCanCreateRepositories: Boolean!
  viewerCanCreateTeams: Boolean!
  viewerCanSponsor: Boolean!
  viewerIsAMember: Boolean!
  viewerIsFollowing: Boolean!
  viewerIsSponsoring: Boolean!
  webCommitSignoffRequired: Boolean!
  websiteUrl: URI
}
union OrganizationAuditEntry =
    MembersCanDeleteReposClearAuditEntry
  | MembersCanDeleteReposDisableAuditEntry
  | MembersCanDeleteReposEnableAuditEntry
  | OauthApplicationCreateAuditEntry
  | OrgAddBillingManagerAuditEntry
  | OrgAddMemberAuditEntry
  | OrgBlockUserAuditEntry
  | OrgConfigDisableCollaboratorsOnlyAuditEntry
  | OrgConfigEnableCollaboratorsOnlyAuditEntry
  | OrgCreateAuditEntry
  | OrgDisableOauthAppRestrictionsAuditEntry
  | OrgDisableSamlAuditEntry
  | OrgDisableTwoFactorRequirementAuditEntry
  | OrgEnableOauthAppRestrictionsAuditEntry
  | OrgEnableSamlAuditEntry
  | OrgEnableTwoFactorRequirementAuditEntry
  | OrgInviteMemberAuditEntry
  | OrgInviteToBusinessAuditEntry
  | OrgOauthAppAccessApprovedAuditEntry
  | OrgOauthAppAccessBlockedAuditEntry
  | OrgOauthAppAccessDeniedAuditEntry
  | OrgOauthAppAccessRequestedAuditEntry
  | OrgOauthAppAccessUnblockedAuditEntry
  | OrgRemoveBillingManagerAuditEntry
  | OrgRemoveMemberAuditEntry
  | OrgRemoveOutsideCollaboratorAuditEntry
  | OrgRestoreMemberAuditEntry
  | OrgUnblockUserAuditEntry
  | OrgUpdateDefaultRepositoryPermissionAuditEntry
  | OrgUpdateMemberAuditEntry
  | OrgUpdateMemberRepositoryCreationPermissionAuditEntry
  | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry
  | PrivateRepositoryForkingDisableAuditEntry
  | PrivateRepositoryForkingEnableAuditEntry
  | RepoAccessAuditEntry
  | RepoAddMemberAuditEntry
  | RepoAddTopicAuditEntry
  | RepoArchivedAuditEntry
  | RepoChangeMergeSettingAuditEntry
  | RepoConfigDisableAnonymousGitAccessAuditEntry
  | RepoConfigDisableCollaboratorsOnlyAuditEntry
  | RepoConfigDisableContributorsOnlyAuditEntry
  | RepoConfigDisableSockpuppetDisallowedAuditEntry
  | RepoConfigEnableAnonymousGitAccessAuditEntry
  | RepoConfigEnableCollaboratorsOnlyAuditEntry
  | RepoConfigEnableContributorsOnlyAuditEntry
  | RepoConfigEnableSockpuppetDisallowedAuditEntry
  | RepoConfigLockAnonymousGitAccessAuditEntry
  | RepoConfigUnlockAnonymousGitAccessAuditEntry
  | RepoCreateAuditEntry
  | RepoDestroyAuditEntry
  | RepoRemoveMemberAuditEntry
  | RepoRemoveTopicAuditEntry
  | RepositoryVisibilityChangeDisableAuditEntry
  | RepositoryVisibilityChangeEnableAuditEntry
  | TeamAddMemberAuditEntry
  | TeamAddRepositoryAuditEntry
  | TeamChangeParentTeamAuditEntry
  | TeamRemoveMemberAuditEntry
  | TeamRemoveRepositoryAuditEntry
type OrganizationAuditEntryConnection {
  edges: [OrganizationAuditEntryEdge]
  nodes: [OrganizationAuditEntry]
  pageInfo: PageInfo!
  totalCount: Int!
}
interface OrganizationAuditEntryData {
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
}
type OrganizationAuditEntryEdge {
  cursor: String!
  node: OrganizationAuditEntry
}
type OrganizationConnection {
  edges: [OrganizationEdge]
  nodes: [Organization]
  pageInfo: PageInfo!
  totalCount: Int!
}
type OrganizationEdge {
  cursor: String!
  node: Organization
}
type OrganizationEnterpriseOwnerConnection {
  edges: [OrganizationEnterpriseOwnerEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type OrganizationEnterpriseOwnerEdge {
  cursor: String!
  node: User
  organizationRole: RoleInOrganization!
}
type OrganizationIdentityProvider implements Node {
  digestMethod: URI
  externalIdentities(
    after: String
    before: String
    first: Int
    last: Int
    login: String
    membersOnly: Boolean
    userName: String
  ): ExternalIdentityConnection!
  id: ID!
  idpCertificate: X509Certificate
  issuer: String
  organization: Organization
  signatureMethod: URI
  ssoUrl: URI
}
type OrganizationInvitation implements Node {
  createdAt: DateTime!
  email: String
  id: ID!
  invitationSource: OrganizationInvitationSource!
  invitationType: OrganizationInvitationType!
  invitee: User
  inviter: User!
  organization: Organization!
  role: OrganizationInvitationRole!
}
type OrganizationInvitationConnection {
  edges: [OrganizationInvitationEdge]
  nodes: [OrganizationInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
}
type OrganizationInvitationEdge {
  cursor: String!
  node: OrganizationInvitation
}
enum OrganizationInvitationRole {
  ADMIN
  BILLING_MANAGER
  DIRECT_MEMBER
  REINSTATE
}
enum OrganizationInvitationSource {
  MEMBER
  SCIM
  UNKNOWN
}
enum OrganizationInvitationType {
  EMAIL
  USER
}
type OrganizationMemberConnection {
  edges: [OrganizationMemberEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type OrganizationMemberEdge {
  cursor: String!
  hasTwoFactorEnabled: Boolean
  node: User
  role: OrganizationMemberRole
}
enum OrganizationMemberRole {
  ADMIN
  MEMBER
}
enum OrganizationMembersCanCreateRepositoriesSettingValue {
  ALL
  DISABLED
  INTERNAL
  PRIVATE
}
type OrganizationMigration implements Node {
  createdAt: DateTime!
  databaseId: String
  failureReason: String
  id: ID!
  remainingRepositoriesCount: Int
  sourceOrgName: String!
  sourceOrgUrl: URI!
  state: OrganizationMigrationState!
  targetOrgName: String!
  totalRepositoriesCount: Int
}
enum OrganizationMigrationState {
  FAILED
  FAILED_VALIDATION
  IN_PROGRESS
  NOT_STARTED
  PENDING_VALIDATION
  POST_REPO_MIGRATION
  PRE_REPO_MIGRATION
  QUEUED
  REPO_MIGRATION
  SUCCEEDED
}
union OrganizationOrUser = Organization | User
input OrganizationOrder {
  direction: OrderDirection!
  field: OrganizationOrderField!
}
enum OrganizationOrderField {
  CREATED_AT
  LOGIN
}
type OrganizationTeamsHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
  relevantTeams(
    after: String
    before: String
    first: Int
    last: Int
  ): TeamConnection!
  teamsResourcePath: URI!
  teamsUrl: URI!
  totalTeamCount: Int!
}
type OrganizationsHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
  relevantOrganizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = null
  ): OrganizationConnection!
  totalOrganizationCount: Int!
}
type Package implements Node {
  id: ID!
  latestVersion: PackageVersion
  name: String!
  packageType: PackageType!
  repository: Repository
  statistics: PackageStatistics
  version(
    version: String!
  ): PackageVersion
  versions(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PackageVersionOrder = {field: CREATED_AT, direction: DESC}
  ): PackageVersionConnection!
}
type PackageConnection {
  edges: [PackageEdge]
  nodes: [Package]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PackageEdge {
  cursor: String!
  node: Package
}
type PackageFile implements Node {
  id: ID!
  md5: String
  name: String!
  packageVersion: PackageVersion
  sha1: String
  sha256: String
  size: Int
  updatedAt: DateTime!
  url: URI
}
type PackageFileConnection {
  edges: [PackageFileEdge]
  nodes: [PackageFile]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PackageFileEdge {
  cursor: String!
  node: PackageFile
}
input PackageFileOrder {
  direction: OrderDirection
  field: PackageFileOrderField
}
enum PackageFileOrderField {
  CREATED_AT
}
input PackageOrder {
  direction: OrderDirection
  field: PackageOrderField
}
enum PackageOrderField {
  CREATED_AT
}
interface PackageOwner {
  id: ID!
  packages(
    after: String
    before: String
    first: Int
    last: Int
    names: [String]
    orderBy: PackageOrder = {field: CREATED_AT, direction: DESC}
    packageType: PackageType
    repositoryId: ID
  ): PackageConnection!
}
type PackageStatistics {
  downloadsTotalCount: Int!
}
type PackageTag implements Node {
  id: ID!
  name: String!
  version: PackageVersion
}
enum PackageType {
  DEBIAN
  DOCKER
    @deprecated(
      reason: "DOCKER will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2021-06-21 UTC."
    )
  MAVEN
    @deprecated(
      reason: "MAVEN will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2023-02-10 UTC."
    )
  NPM
    @deprecated(
      reason: "NPM will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC."
    )
  NUGET
    @deprecated(
      reason: "NUGET will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC."
    )
  PYPI
  RUBYGEMS
    @deprecated(
      reason: "RUBYGEMS will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-12-28 UTC."
    )
}
type PackageVersion implements Node {
  files(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PackageFileOrder = {field: CREATED_AT, direction: ASC}
  ): PackageFileConnection!
  id: ID!
  package: Package
  platform: String
  preRelease: Boolean!
  readme: String
  release: Release
  statistics: PackageVersionStatistics
  summary: String
  version: String!
}
type PackageVersionConnection {
  edges: [PackageVersionEdge]
  nodes: [PackageVersion]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PackageVersionEdge {
  cursor: String!
  node: PackageVersion
}
input PackageVersionOrder {
  direction: OrderDirection
  field: PackageVersionOrderField
}
enum PackageVersionOrderField {
  CREATED_AT
}
type PackageVersionStatistics {
  downloadsTotalCount: Int!
}
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}
enum PatchStatus {
  ADDED
  CHANGED
  COPIED
  DELETED
  MODIFIED
  RENAMED
}
union PermissionGranter = Organization | Repository | Team
type PermissionSource {
  organization: Organization!
  permission: DefaultRepositoryPermissionField!
  source: PermissionGranter!
}
input PinIssueInput {
  clientMutationId: String
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
}
type PinIssuePayload {
  clientMutationId: String
  issue: Issue
}
union PinnableItem = Gist | Repository
type PinnableItemConnection {
  edges: [PinnableItemEdge]
  nodes: [PinnableItem]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PinnableItemEdge {
  cursor: String!
  node: PinnableItem
}
enum PinnableItemType {
  GIST
  ISSUE
  ORGANIZATION
  PROJECT
  PULL_REQUEST
  REPOSITORY
  TEAM
  USER
}
type PinnedDiscussion implements Node & RepositoryNode {
  createdAt: DateTime!
  databaseId: Int
  discussion: Discussion!
  gradientStopColors: [String!]!
  id: ID!
  pattern: PinnedDiscussionPattern!
  pinnedBy: Actor!
  preconfiguredGradient: PinnedDiscussionGradient
  repository: Repository!
  updatedAt: DateTime!
}
type PinnedDiscussionConnection {
  edges: [PinnedDiscussionEdge]
  nodes: [PinnedDiscussion]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PinnedDiscussionEdge {
  cursor: String!
  node: PinnedDiscussion
}
enum PinnedDiscussionGradient {
  BLUE_MINT
  BLUE_PURPLE
  PINK_BLUE
  PURPLE_CORAL
  RED_ORANGE
}
enum PinnedDiscussionPattern {
  CHEVRON_UP
  DOT
  DOT_FILL
  HEART_FILL
  PLUS
  ZAP
}
type PinnedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  issue: Issue!
}
type PinnedIssue implements Node {
  databaseId: Int
  fullDatabaseId: BigInt
  id: ID!
  issue: Issue!
  pinnedBy: Actor!
  repository: Repository!
}
type PinnedIssueConnection {
  edges: [PinnedIssueEdge]
  nodes: [PinnedIssue]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PinnedIssueEdge {
  cursor: String!
  node: PinnedIssue
}
scalar PreciseDateTime
type PrivateRepositoryForkingDisableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type PrivateRepositoryForkingEnableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type ProfileItemShowcase {
  hasPinnedItems: Boolean!
  items(
    after: String
    before: String
    first: Int
    last: Int
  ): PinnableItemConnection!
}
interface ProfileOwner {
  anyPinnableItems(
    type: PinnableItemType
  ): Boolean!
  email: String
  id: ID!
  itemShowcase: ProfileItemShowcase!
  location: String
  login: String!
  name: String
  pinnableItems(
    after: String
    before: String
    first: Int
    last: Int
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  pinnedItems(
    after: String
    before: String
    first: Int
    last: Int
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  pinnedItemsRemaining: Int!
  viewerCanChangePinnedItems: Boolean!
  websiteUrl: URI
}
type Project implements Closable & Node & Updatable {
  body: String
  bodyHTML: HTML!
  closed: Boolean!
  closedAt: DateTime
  columns(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectColumnConnection!
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  id: ID!
  name: String!
  number: Int!
  owner: ProjectOwner!
  pendingCards(
    after: String
    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]
    before: String
    first: Int
    last: Int
  ): ProjectCardConnection!
  progress: ProjectProgress!
  resourcePath: URI!
  state: ProjectState!
  updatedAt: DateTime!
  url: URI!
  viewerCanClose: Boolean!
  viewerCanReopen: Boolean!
  viewerCanUpdate: Boolean!
}
type ProjectCard implements Node {
  column: ProjectColumn
  content: ProjectCardItem
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  id: ID!
  isArchived: Boolean!
  note: String
  project: Project!
  resourcePath: URI!
  state: ProjectCardState
  updatedAt: DateTime!
  url: URI!
}
enum ProjectCardArchivedState {
  ARCHIVED
  NOT_ARCHIVED
}
type ProjectCardConnection {
  edges: [ProjectCardEdge]
  nodes: [ProjectCard]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectCardEdge {
  cursor: String!
  node: ProjectCard
}
input ProjectCardImport {
  number: Int!
  repository: String!
}
union ProjectCardItem = Issue | PullRequest
enum ProjectCardState {
  CONTENT_ONLY
  NOTE_ONLY
  REDACTED
}
type ProjectColumn implements Node {
  cards(
    after: String
    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]
    before: String
    first: Int
    last: Int
  ): ProjectCardConnection!
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  name: String!
  project: Project!
  purpose: ProjectColumnPurpose
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
}
type ProjectColumnConnection {
  edges: [ProjectColumnEdge]
  nodes: [ProjectColumn]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectColumnEdge {
  cursor: String!
  node: ProjectColumn
}
input ProjectColumnImport {
  columnName: String!
  issues: [ProjectCardImport!]
  position: Int!
}
enum ProjectColumnPurpose {
  DONE
  IN_PROGRESS
  TODO
}
type ProjectConnection {
  edges: [ProjectEdge]
  nodes: [Project]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectEdge {
  cursor: String!
  node: Project
}
input ProjectOrder {
  direction: OrderDirection!
  field: ProjectOrderField!
}
enum ProjectOrderField {
  CREATED_AT
  NAME
  UPDATED_AT
}
interface ProjectOwner {
  id: ID!
  project(
    number: Int!
  ): Project
  projects(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectOrder
    search: String
    states: [ProjectState!]
  ): ProjectConnection!
  projectsResourcePath: URI!
  projectsUrl: URI!
  viewerCanCreateProjects: Boolean!
}
type ProjectProgress {
  doneCount: Int!
  donePercentage: Float!
  enabled: Boolean!
  inProgressCount: Int!
  inProgressPercentage: Float!
  todoCount: Int!
  todoPercentage: Float!
}
enum ProjectState {
  CLOSED
  OPEN
}
enum ProjectTemplate {
  AUTOMATED_KANBAN_V2
  AUTOMATED_REVIEWS_KANBAN
  BASIC_KANBAN
  BUG_TRIAGE
}
type ProjectV2 implements Closable & Node & Updatable {
  closed: Boolean!
  closedAt: DateTime
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  field(
    name: String!
  ): ProjectV2FieldConfiguration
  fields(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2FieldOrder = {field: POSITION, direction: ASC}
  ): ProjectV2FieldConfigurationConnection!
  id: ID!
  items(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2ItemOrder = {field: POSITION, direction: ASC}
  ): ProjectV2ItemConnection!
  number: Int!
  owner: ProjectV2Owner!
  public: Boolean!
  readme: String
  repositories(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: RepositoryOrder = {field: CREATED_AT, direction: DESC}
  ): RepositoryConnection!
  resourcePath: URI!
  shortDescription: String
  teams(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: TeamOrder = {field: NAME, direction: ASC}
  ): TeamConnection!
  template: Boolean!
  title: String!
  updatedAt: DateTime!
  url: URI!
  view(
    number: Int!
  ): ProjectV2View
  viewerCanClose: Boolean!
  viewerCanReopen: Boolean!
  viewerCanUpdate: Boolean!
  views(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2ViewOrder = {field: POSITION, direction: ASC}
  ): ProjectV2ViewConnection!
  workflow(
    number: Int!
  ): ProjectV2Workflow
  workflows(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2WorkflowOrder = {field: NAME, direction: ASC}
  ): ProjectV2WorkflowConnection!
}
union ProjectV2Actor = Team | User
type ProjectV2ActorConnection {
  edges: [ProjectV2ActorEdge]
  nodes: [ProjectV2Actor]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectV2ActorEdge {
  cursor: String!
  node: ProjectV2Actor
}
input ProjectV2Collaborator {
  role: ProjectV2Roles!
  teamId: ID @possibleTypes(concreteTypes: ["Team"])
  userId: ID @possibleTypes(concreteTypes: ["User"])
}
type ProjectV2Connection {
  edges: [ProjectV2Edge]
  nodes: [ProjectV2]
  pageInfo: PageInfo!
  totalCount: Int!
}
enum ProjectV2CustomFieldType {
  DATE
  NUMBER
  SINGLE_SELECT
  TEXT
}
type ProjectV2Edge {
  cursor: String!
  node: ProjectV2
}
type ProjectV2Field implements Node & ProjectV2FieldCommon {
  createdAt: DateTime!
  dataType: ProjectV2FieldType!
  databaseId: Int
  id: ID!
  name: String!
  project: ProjectV2!
  updatedAt: DateTime!
}
interface ProjectV2FieldCommon {
  createdAt: DateTime!
  dataType: ProjectV2FieldType!
  databaseId: Int
  id: ID!
  name: String!
  project: ProjectV2!
  updatedAt: DateTime!
}
union ProjectV2FieldConfiguration = ProjectV2Field | ProjectV2IterationField | ProjectV2SingleSelectField
type ProjectV2FieldConfigurationConnection {
  edges: [ProjectV2FieldConfigurationEdge]
  nodes: [ProjectV2FieldConfiguration]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectV2FieldConfigurationEdge {
  cursor: String!
  node: ProjectV2FieldConfiguration
}
type ProjectV2FieldConnection {
  edges: [ProjectV2FieldEdge]
  nodes: [ProjectV2Field]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectV2FieldEdge {
  cursor: String!
  node: ProjectV2Field
}
input ProjectV2FieldOrder {
  direction: OrderDirection!
  field: ProjectV2FieldOrderField!
}
enum ProjectV2FieldOrderField {
  CREATED_AT
  NAME
  POSITION
}
enum ProjectV2FieldType {
  ASSIGNEES
  DATE
  ITERATION
  LABELS
  LINKED_PULL_REQUESTS
  MILESTONE
  NUMBER
  REPOSITORY
  REVIEWERS
  SINGLE_SELECT
  TEXT
  TITLE
  TRACKED_BY
  TRACKS
}
input ProjectV2FieldValue {
  date: Date
  iterationId: String
  number: Float
  singleSelectOptionId: String
  text: String
}
input ProjectV2Filters {
  state: ProjectV2State
}
type ProjectV2Item implements Node {
  content: ProjectV2ItemContent
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  fieldValueByName(
    name: String!
  ): ProjectV2ItemFieldValue
  fieldValues(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2ItemFieldValueOrder = {field: POSITION, direction: ASC}
  ): ProjectV2ItemFieldValueConnection!
  id: ID!
  isArchived: Boolean!
  project: ProjectV2!
  type: ProjectV2ItemType!
  updatedAt: DateTime!
}
type ProjectV2ItemConnection {
  edges: [ProjectV2ItemEdge]
  nodes: [ProjectV2Item]
  pageInfo: PageInfo!
  totalCount: Int!
}
union ProjectV2ItemContent = DraftIssue | Issue | PullRequest
type ProjectV2ItemEdge {
  cursor: String!
  node: ProjectV2Item
}
type ProjectV2ItemFieldDateValue implements Node & ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  date: Date
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  updatedAt: DateTime!
}
type ProjectV2ItemFieldIterationValue implements Node & ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  duration: Int!
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  iterationId: String!
  startDate: Date!
  title: String!
  titleHTML: String!
  updatedAt: DateTime!
}
type ProjectV2ItemFieldLabelValue {
  field: ProjectV2FieldConfiguration!
  labels(
    after: String
    before: String
    first: Int
    last: Int
  ): LabelConnection
}
type ProjectV2ItemFieldMilestoneValue {
  field: ProjectV2FieldConfiguration!
  milestone: Milestone
}
type ProjectV2ItemFieldNumberValue implements Node & ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  number: Float
  updatedAt: DateTime!
}
type ProjectV2ItemFieldPullRequestValue {
  field: ProjectV2FieldConfiguration!
  pullRequests(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PullRequestOrder = {field: CREATED_AT, direction: ASC}
  ): PullRequestConnection
}
type ProjectV2ItemFieldRepositoryValue {
  field: ProjectV2FieldConfiguration!
  repository: Repository
}
type ProjectV2ItemFieldReviewerValue {
  field: ProjectV2FieldConfiguration!
  reviewers(
    after: String
    before: String
    first: Int
    last: Int
  ): RequestedReviewerConnection
}
type ProjectV2ItemFieldSingleSelectValue implements Node & ProjectV2ItemFieldValueCommon {
  color: ProjectV2SingleSelectFieldOptionColor!
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  description: String
  descriptionHTML: String
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  name: String
  nameHTML: String
  optionId: String
  updatedAt: DateTime!
}
type ProjectV2ItemFieldTextValue implements Node & ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  text: String
  updatedAt: DateTime!
}
type ProjectV2ItemFieldUserValue {
  field: ProjectV2FieldConfiguration!
  users(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection
}
union ProjectV2ItemFieldValue =
    ProjectV2ItemFieldDateValue
  | ProjectV2ItemFieldIterationValue
  | ProjectV2ItemFieldLabelValue
  | ProjectV2ItemFieldMilestoneValue
  | ProjectV2ItemFieldNumberValue
  | ProjectV2ItemFieldPullRequestValue
  | ProjectV2ItemFieldRepositoryValue
  | ProjectV2ItemFieldReviewerValue
  | ProjectV2ItemFieldSingleSelectValue
  | ProjectV2ItemFieldTextValue
  | ProjectV2ItemFieldUserValue
interface ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  updatedAt: DateTime!
}
type ProjectV2ItemFieldValueConnection {
  edges: [ProjectV2ItemFieldValueEdge]
  nodes: [ProjectV2ItemFieldValue]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectV2ItemFieldValueEdge {
  cursor: String!
  node: ProjectV2ItemFieldValue
}
input ProjectV2ItemFieldValueOrder {
  direction: OrderDirection!
  field: ProjectV2ItemFieldValueOrderField!
}
enum ProjectV2ItemFieldValueOrderField {
  POSITION
}
input ProjectV2ItemOrder {
  direction: OrderDirection!
  field: ProjectV2ItemOrderField!
}
enum ProjectV2ItemOrderField {
  POSITION
}
enum ProjectV2ItemType {
  DRAFT_ISSUE
  ISSUE
  PULL_REQUEST
  REDACTED
}
type ProjectV2IterationField implements Node & ProjectV2FieldCommon {
  configuration: ProjectV2IterationFieldConfiguration!
  createdAt: DateTime!
  dataType: ProjectV2FieldType!
  databaseId: Int
  id: ID!
  name: String!
  project: ProjectV2!
  updatedAt: DateTime!
}
type ProjectV2IterationFieldConfiguration {
  completedIterations: [ProjectV2IterationFieldIteration!]!
  duration: Int!
  iterations: [ProjectV2IterationFieldIteration!]!
  startDay: Int!
}
type ProjectV2IterationFieldIteration {
  duration: Int!
  id: String!
  startDate: Date!
  title: String!
  titleHTML: String!
}
input ProjectV2Order {
  direction: OrderDirection!
  field: ProjectV2OrderField!
}
enum ProjectV2OrderField {
  CREATED_AT
  NUMBER
  TITLE
  UPDATED_AT
}
interface ProjectV2Owner {
  id: ID!
  projectV2(
    number: Int!
  ): ProjectV2
  projectsV2(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2Order = {field: NUMBER, direction: DESC}
    query: String
  ): ProjectV2Connection!
}
interface ProjectV2Recent {
  recentProjects(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2Connection!
}
enum ProjectV2Roles {
  ADMIN
  NONE
  READER
  WRITER
}
type ProjectV2SingleSelectField implements Node & ProjectV2FieldCommon {
  createdAt: DateTime!
  dataType: ProjectV2FieldType!
  databaseId: Int
  id: ID!
  name: String!
  options(
    names: [String!]
  ): [ProjectV2SingleSelectFieldOption!]!
  project: ProjectV2!
  updatedAt: DateTime!
}
type ProjectV2SingleSelectFieldOption {
  color: ProjectV2SingleSelectFieldOptionColor!
  description: String!
  descriptionHTML: String!
  id: String!
  name: String!
  nameHTML: String!
}
enum ProjectV2SingleSelectFieldOptionColor {
  BLUE
  GRAY
  GREEN
  ORANGE
  PINK
  PURPLE
  RED
  YELLOW
}
input ProjectV2SingleSelectFieldOptionInput {
  color: ProjectV2SingleSelectFieldOptionColor!
  description: String!
  name: String!
}
type ProjectV2SortBy {
  direction: OrderDirection!
  field: ProjectV2Field!
}
type ProjectV2SortByConnection {
  edges: [ProjectV2SortByEdge]
  nodes: [ProjectV2SortBy]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectV2SortByEdge {
  cursor: String!
  node: ProjectV2SortBy
}
type ProjectV2SortByField {
  direction: OrderDirection!
  field: ProjectV2FieldConfiguration!
}
type ProjectV2SortByFieldConnection {
  edges: [ProjectV2SortByFieldEdge]
  nodes: [ProjectV2SortByField]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectV2SortByFieldEdge {
  cursor: String!
  node: ProjectV2SortByField
}
enum ProjectV2State {
  CLOSED
  OPEN
}
type ProjectV2View implements Node {
  createdAt: DateTime!
  databaseId: Int
  fields(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2FieldOrder = {field: POSITION, direction: ASC}
  ): ProjectV2FieldConfigurationConnection
  filter: String
  groupBy(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2FieldOrder = {field: POSITION, direction: ASC}
  ): ProjectV2FieldConnection
    @deprecated(
      reason: "The 'ProjectV2View
    )
  groupByFields(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2FieldOrder = {field: POSITION, direction: ASC}
  ): ProjectV2FieldConfigurationConnection
  id: ID!
  layout: ProjectV2ViewLayout!
  name: String!
  number: Int!
  project: ProjectV2!
  sortBy(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2SortByConnection
    @deprecated(
      reason: "The 'ProjectV2View
    )
  sortByFields(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2SortByFieldConnection
  updatedAt: DateTime!
  verticalGroupBy(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2FieldOrder = {field: POSITION, direction: ASC}
  ): ProjectV2FieldConnection
    @deprecated(
      reason: "The 'ProjectV2View
    )
  verticalGroupByFields(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2FieldOrder = {field: POSITION, direction: ASC}
  ): ProjectV2FieldConfigurationConnection
  visibleFields(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2FieldOrder = {field: POSITION, direction: ASC}
  ): ProjectV2FieldConnection
    @deprecated(
      reason: "The 'ProjectV2View
    )
}
type ProjectV2ViewConnection {
  edges: [ProjectV2ViewEdge]
  nodes: [ProjectV2View]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectV2ViewEdge {
  cursor: String!
  node: ProjectV2View
}
enum ProjectV2ViewLayout {
  BOARD_LAYOUT
  ROADMAP_LAYOUT
  TABLE_LAYOUT
}
input ProjectV2ViewOrder {
  direction: OrderDirection!
  field: ProjectV2ViewOrderField!
}
enum ProjectV2ViewOrderField {
  CREATED_AT
  NAME
  POSITION
}
type ProjectV2Workflow implements Node {
  createdAt: DateTime!
  databaseId: Int
  enabled: Boolean!
  id: ID!
  name: String!
  number: Int!
  project: ProjectV2!
  updatedAt: DateTime!
}
type ProjectV2WorkflowConnection {
  edges: [ProjectV2WorkflowEdge]
  nodes: [ProjectV2Workflow]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ProjectV2WorkflowEdge {
  cursor: String!
  node: ProjectV2Workflow
}
input ProjectV2WorkflowOrder {
  direction: OrderDirection!
  field: ProjectV2WorkflowsOrderField!
}
enum ProjectV2WorkflowsOrderField {
  CREATED_AT
  NAME
  NUMBER
  UPDATED_AT
}
type PublicKey implements Node {
  accessedAt: DateTime
  createdAt: DateTime
  fingerprint: String!
  id: ID!
  isReadOnly: Boolean
  key: String!
  updatedAt: DateTime
}
type PublicKeyConnection {
  edges: [PublicKeyEdge]
  nodes: [PublicKey]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PublicKeyEdge {
  cursor: String!
  node: PublicKey
}
input PublishSponsorsTierInput {
  clientMutationId: String
  tierId: ID! @possibleTypes(concreteTypes: ["SponsorsTier"])
}
type PublishSponsorsTierPayload {
  clientMutationId: String
  sponsorsTier: SponsorsTier
}
type PullRequest implements Assignable & Closable & Comment & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment {
  activeLockReason: LockReason
  additions: Int!
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  autoMergeRequest: AutoMergeRequest
  baseRef: Ref
  baseRefName: String!
  baseRefOid: GitObjectID!
  baseRepository: Repository
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  canBeRebased: Boolean! @preview(toggledBy: "merge-info-preview")
  changedFiles: Int!
  checksResourcePath: URI!
  checksUrl: URI!
  closed: Boolean!
  closedAt: DateTime
  closingIssuesReferences(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: IssueOrder
    userLinkedOnly: Boolean = false
  ): IssueConnection
  comments(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: IssueCommentOrder
  ): IssueCommentConnection!
  commits(
    after: String
    before: String
    first: Int
    last: Int
  ): PullRequestCommitConnection!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  deletions: Int!
  editor: Actor
  files(
    after: String
    before: String
    first: Int
    last: Int
  ): PullRequestChangedFileConnection
  headRef: Ref
  headRefName: String!
  headRefOid: GitObjectID!
  headRepository: Repository
  headRepositoryOwner: RepositoryOwner
  hovercard(
    includeNotificationContexts: Boolean = true
  ): Hovercard!
  id: ID!
  includesCreatedEdit: Boolean!
  isCrossRepository: Boolean!
  isDraft: Boolean!
  isReadByViewer: Boolean
  labels(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
  ): LabelConnection
  lastEditedAt: DateTime
  latestOpinionatedReviews(
    after: String
    before: String
    first: Int
    last: Int
    writersOnly: Boolean = false
  ): PullRequestReviewConnection
  latestReviews(
    after: String
    before: String
    first: Int
    last: Int
  ): PullRequestReviewConnection
  locked: Boolean!
  maintainerCanModify: Boolean!
  mergeCommit: Commit
  mergeQueueEntry: MergeQueueEntry
  mergeStateStatus: MergeStateStatus! @preview(toggledBy: "merge-info-preview")
  mergeable: MergeableState!
  merged: Boolean!
  mergedAt: DateTime
  mergedBy: Actor
  milestone: Milestone
  number: Int!
  participants(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  permalink: URI!
  potentialMergeCommit: Commit
  projectCards(
    after: String
    archivedStates: [ProjectCardArchivedState] = [ARCHIVED, NOT_ARCHIVED]
    before: String
    first: Int
    last: Int
  ): ProjectCardConnection!
  projectItems(
    after: String
    before: String
    first: Int
    includeArchived: Boolean = true
    last: Int
  ): ProjectV2ItemConnection!
  projectV2(
    number: Int!
  ): ProjectV2
  projectsV2(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2Order = {field: NUMBER, direction: DESC}
    query: String
  ): ProjectV2Connection!
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  revertResourcePath: URI!
  revertUrl: URI!
  reviewDecision: PullRequestReviewDecision
  reviewRequests(
    after: String
    before: String
    first: Int
    last: Int
  ): ReviewRequestConnection
  reviewThreads(
    after: String
    before: String
    first: Int
    last: Int
  ): PullRequestReviewThreadConnection!
  reviews(
    after: String
    author: String
    before: String
    first: Int
    last: Int
    states: [PullRequestReviewState!]
  ): PullRequestReviewConnection
  state: PullRequestState!
  suggestedReviewers: [SuggestedReviewer]!
  timeline(
    after: String
    before: String
    first: Int
    last: Int
    since: DateTime
  ): PullRequestTimelineConnection!
    @deprecated(reason: "'timeline' will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.")
  timelineItems(
    after: String
    before: String
    first: Int
    itemTypes: [PullRequestTimelineItemsItemType!]
    last: Int
    since: DateTime
    skip: Int
  ): PullRequestTimelineItemsConnection!
  title: String!
  titleHTML: HTML!
  totalCommentsCount: Int
  updatedAt: DateTime!
  url: URI!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanApplySuggestion: Boolean!
  viewerCanClose: Boolean!
  viewerCanDeleteHeadRef: Boolean!
  viewerCanDisableAutoMerge: Boolean!
  viewerCanEditFiles: Boolean!
  viewerCanEnableAutoMerge: Boolean!
  viewerCanMergeAsAdmin: Boolean!
  viewerCanReact: Boolean!
  viewerCanReopen: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdate: Boolean!
  viewerCanUpdateBranch: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
  viewerLatestReview: PullRequestReview
  viewerLatestReviewRequest: ReviewRequest
  viewerMergeBodyText(
    mergeType: PullRequestMergeMethod
  ): String!
  viewerMergeHeadlineText(
    mergeType: PullRequestMergeMethod
  ): String!
  viewerSubscription: SubscriptionState
}
type PullRequestChangedFile {
  additions: Int!
  changeType: PatchStatus!
  deletions: Int!
  path: String!
  viewerViewedState: FileViewedState!
}
type PullRequestChangedFileConnection {
  edges: [PullRequestChangedFileEdge]
  nodes: [PullRequestChangedFile]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PullRequestChangedFileEdge {
  cursor: String!
  node: PullRequestChangedFile
}
type PullRequestCommit implements Node & UniformResourceLocatable {
  commit: Commit!
  id: ID!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
}
type PullRequestCommitCommentThread implements Node & RepositoryNode {
  comments(
    after: String
    before: String
    first: Int
    last: Int
  ): CommitCommentConnection!
  commit: Commit!
  id: ID!
  path: String
  position: Int
  pullRequest: PullRequest!
  repository: Repository!
}
type PullRequestCommitConnection {
  edges: [PullRequestCommitEdge]
  nodes: [PullRequestCommit]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PullRequestCommitEdge {
  cursor: String!
  node: PullRequestCommit
}
type PullRequestConnection {
  edges: [PullRequestEdge]
  nodes: [PullRequest]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PullRequestContributionsByRepository {
  contributions(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedPullRequestContributionConnection!
  repository: Repository!
}
type PullRequestEdge {
  cursor: String!
  node: PullRequest
}
enum PullRequestMergeMethod {
  MERGE
  REBASE
  SQUASH
}
input PullRequestOrder {
  direction: OrderDirection!
  field: PullRequestOrderField!
}
enum PullRequestOrderField {
  CREATED_AT
  UPDATED_AT
}
type PullRequestParameters {
  dismissStaleReviewsOnPush: Boolean!
  requireCodeOwnerReview: Boolean!
  requireLastPushApproval: Boolean!
  requiredApprovingReviewCount: Int!
  requiredReviewThreadResolution: Boolean!
}
input PullRequestParametersInput {
  dismissStaleReviewsOnPush: Boolean!
  requireCodeOwnerReview: Boolean!
  requireLastPushApproval: Boolean!
  requiredApprovingReviewCount: Int!
  requiredReviewThreadResolution: Boolean!
}
type PullRequestReview implements Comment & Deletable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  authorCanPushToRepository: Boolean!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  comments(
    after: String
    before: String
    first: Int
    last: Int
  ): PullRequestReviewCommentConnection!
  commit: Commit
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  lastEditedAt: DateTime
  onBehalfOf(
    after: String
    before: String
    first: Int
    last: Int
  ): TeamConnection!
  publishedAt: DateTime
  pullRequest: PullRequest!
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  state: PullRequestReviewState!
  submittedAt: DateTime
  updatedAt: DateTime!
  url: URI!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}
type PullRequestReviewComment implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  commit: Commit
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  diffHunk: String!
  draftedAt: DateTime!
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  isMinimized: Boolean!
  lastEditedAt: DateTime
  line: Int
  minimizedReason: String
  originalCommit: Commit
  originalLine: Int
  originalPosition: Int!
    @deprecated(reason: "We are phasing out diff-relative positioning for PR comments Removal on 2023-10-01 UTC.")
  originalStartLine: Int
  outdated: Boolean!
  path: String!
  position: Int
    @deprecated(
      reason: "We are phasing out diff-relative positioning for PR comments Use the 'line' and 'startLine' fields instead, which are file line numbers instead of diff line numbers Removal on 2023-10-01 UTC."
    )
  publishedAt: DateTime
  pullRequest: PullRequest!
  pullRequestReview: PullRequestReview
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  replyTo: PullRequestReviewComment
  repository: Repository!
  resourcePath: URI!
  startLine: Int
  state: PullRequestReviewCommentState!
  subjectType: PullRequestReviewThreadSubjectType!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}
type PullRequestReviewCommentConnection {
  edges: [PullRequestReviewCommentEdge]
  nodes: [PullRequestReviewComment]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PullRequestReviewCommentEdge {
  cursor: String!
  node: PullRequestReviewComment
}
enum PullRequestReviewCommentState {
  PENDING
  SUBMITTED
}
type PullRequestReviewConnection {
  edges: [PullRequestReviewEdge]
  nodes: [PullRequestReview]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PullRequestReviewContributionsByRepository {
  contributions(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ContributionOrder = {direction: DESC}
  ): CreatedPullRequestReviewContributionConnection!
  repository: Repository!
}
enum PullRequestReviewDecision {
  APPROVED
  CHANGES_REQUESTED
  REVIEW_REQUIRED
}
type PullRequestReviewEdge {
  cursor: String!
  node: PullRequestReview
}
enum PullRequestReviewEvent {
  APPROVE
  COMMENT
  DISMISS
  REQUEST_CHANGES
}
enum PullRequestReviewState {
  APPROVED
  CHANGES_REQUESTED
  COMMENTED
  DISMISSED
  PENDING
}
type PullRequestReviewThread implements Node {
  comments(
    after: String
    before: String
    first: Int
    last: Int
    skip: Int
  ): PullRequestReviewCommentConnection!
  diffSide: DiffSide!
  id: ID!
  isCollapsed: Boolean!
  isOutdated: Boolean!
  isResolved: Boolean!
  line: Int
  originalLine: Int
  originalStartLine: Int
  path: String!
  pullRequest: PullRequest!
  repository: Repository!
  resolvedBy: User
  startDiffSide: DiffSide
  startLine: Int
  subjectType: PullRequestReviewThreadSubjectType!
  viewerCanReply: Boolean!
  viewerCanResolve: Boolean!
  viewerCanUnresolve: Boolean!
}
type PullRequestReviewThreadConnection {
  edges: [PullRequestReviewThreadEdge]
  nodes: [PullRequestReviewThread]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PullRequestReviewThreadEdge {
  cursor: String!
  node: PullRequestReviewThread
}
enum PullRequestReviewThreadSubjectType {
  FILE
  LINE
}
type PullRequestRevisionMarker {
  createdAt: DateTime!
  lastSeenCommit: Commit!
  pullRequest: PullRequest!
}
enum PullRequestState {
  CLOSED
  MERGED
  OPEN
}
type PullRequestTemplate {
  body: String
  filename: String
  repository: Repository!
}
type PullRequestThread implements Node {
  comments(
    after: String
    before: String
    first: Int
    last: Int
    skip: Int
  ): PullRequestReviewCommentConnection!
  diffSide: DiffSide!
  id: ID!
  isCollapsed: Boolean!
  isOutdated: Boolean!
  isResolved: Boolean!
  line: Int
  path: String!
  pullRequest: PullRequest!
  repository: Repository!
  resolvedBy: User
  startDiffSide: DiffSide
  startLine: Int
  subjectType: PullRequestReviewThreadSubjectType!
  viewerCanReply: Boolean!
  viewerCanResolve: Boolean!
  viewerCanUnresolve: Boolean!
}
type PullRequestTimelineConnection {
  edges: [PullRequestTimelineItemEdge]
  nodes: [PullRequestTimelineItem]
  pageInfo: PageInfo!
  totalCount: Int!
}
union PullRequestTimelineItem =
    AssignedEvent
  | BaseRefDeletedEvent
  | BaseRefForcePushedEvent
  | ClosedEvent
  | Commit
  | CommitCommentThread
  | CrossReferencedEvent
  | DemilestonedEvent
  | DeployedEvent
  | DeploymentEnvironmentChangedEvent
  | HeadRefDeletedEvent
  | HeadRefForcePushedEvent
  | HeadRefRestoredEvent
  | IssueComment
  | LabeledEvent
  | LockedEvent
  | MergedEvent
  | MilestonedEvent
  | PullRequestReview
  | PullRequestReviewComment
  | PullRequestReviewThread
  | ReferencedEvent
  | RenamedTitleEvent
  | ReopenedEvent
  | ReviewDismissedEvent
  | ReviewRequestRemovedEvent
  | ReviewRequestedEvent
  | SubscribedEvent
  | UnassignedEvent
  | UnlabeledEvent
  | UnlockedEvent
  | UnsubscribedEvent
  | UserBlockedEvent
type PullRequestTimelineItemEdge {
  cursor: String!
  node: PullRequestTimelineItem
}
union PullRequestTimelineItems =
    AddedToMergeQueueEvent
  | AddedToProjectEvent
  | AssignedEvent
  | AutoMergeDisabledEvent
  | AutoMergeEnabledEvent
  | AutoRebaseEnabledEvent
  | AutoSquashEnabledEvent
  | AutomaticBaseChangeFailedEvent
  | AutomaticBaseChangeSucceededEvent
  | BaseRefChangedEvent
  | BaseRefDeletedEvent
  | BaseRefForcePushedEvent
  | ClosedEvent
  | CommentDeletedEvent
  | ConnectedEvent
  | ConvertToDraftEvent
  | ConvertedNoteToIssueEvent
  | ConvertedToDiscussionEvent
  | CrossReferencedEvent
  | DemilestonedEvent
  | DeployedEvent
  | DeploymentEnvironmentChangedEvent
  | DisconnectedEvent
  | HeadRefDeletedEvent
  | HeadRefForcePushedEvent
  | HeadRefRestoredEvent
  | IssueComment
  | LabeledEvent
  | LockedEvent
  | MarkedAsDuplicateEvent
  | MentionedEvent
  | MergedEvent
  | MilestonedEvent
  | MovedColumnsInProjectEvent
  | PinnedEvent
  | PullRequestCommit
  | PullRequestCommitCommentThread
  | PullRequestReview
  | PullRequestReviewThread
  | PullRequestRevisionMarker
  | ReadyForReviewEvent
  | ReferencedEvent
  | RemovedFromMergeQueueEvent
  | RemovedFromProjectEvent
  | RenamedTitleEvent
  | ReopenedEvent
  | ReviewDismissedEvent
  | ReviewRequestRemovedEvent
  | ReviewRequestedEvent
  | SubscribedEvent
  | TransferredEvent
  | UnassignedEvent
  | UnlabeledEvent
  | UnlockedEvent
  | UnmarkedAsDuplicateEvent
  | UnpinnedEvent
  | UnsubscribedEvent
  | UserBlockedEvent
type PullRequestTimelineItemsConnection {
  edges: [PullRequestTimelineItemsEdge]
  filteredCount: Int!
  nodes: [PullRequestTimelineItems]
  pageCount: Int!
  pageInfo: PageInfo!
  totalCount: Int!
  updatedAt: DateTime!
}
type PullRequestTimelineItemsEdge {
  cursor: String!
  node: PullRequestTimelineItems
}
enum PullRequestTimelineItemsItemType {
  ADDED_TO_MERGE_QUEUE_EVENT
  ADDED_TO_PROJECT_EVENT
  ASSIGNED_EVENT
  AUTOMATIC_BASE_CHANGE_FAILED_EVENT
  AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT
  AUTO_MERGE_DISABLED_EVENT
  AUTO_MERGE_ENABLED_EVENT
  AUTO_REBASE_ENABLED_EVENT
  AUTO_SQUASH_ENABLED_EVENT
  BASE_REF_CHANGED_EVENT
  BASE_REF_DELETED_EVENT
  BASE_REF_FORCE_PUSHED_EVENT
  CLOSED_EVENT
  COMMENT_DELETED_EVENT
  CONNECTED_EVENT
  CONVERTED_NOTE_TO_ISSUE_EVENT
  CONVERTED_TO_DISCUSSION_EVENT
  CONVERT_TO_DRAFT_EVENT
  CROSS_REFERENCED_EVENT
  DEMILESTONED_EVENT
  DEPLOYED_EVENT
  DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT
  DISCONNECTED_EVENT
  HEAD_REF_DELETED_EVENT
  HEAD_REF_FORCE_PUSHED_EVENT
  HEAD_REF_RESTORED_EVENT
  ISSUE_COMMENT
  LABELED_EVENT
  LOCKED_EVENT
  MARKED_AS_DUPLICATE_EVENT
  MENTIONED_EVENT
  MERGED_EVENT
  MILESTONED_EVENT
  MOVED_COLUMNS_IN_PROJECT_EVENT
  PINNED_EVENT
  PULL_REQUEST_COMMIT
  PULL_REQUEST_COMMIT_COMMENT_THREAD
  PULL_REQUEST_REVIEW
  PULL_REQUEST_REVIEW_THREAD
  PULL_REQUEST_REVISION_MARKER
  READY_FOR_REVIEW_EVENT
  REFERENCED_EVENT
  REMOVED_FROM_MERGE_QUEUE_EVENT
  REMOVED_FROM_PROJECT_EVENT
  RENAMED_TITLE_EVENT
  REOPENED_EVENT
  REVIEW_DISMISSED_EVENT
  REVIEW_REQUESTED_EVENT
  REVIEW_REQUEST_REMOVED_EVENT
  SUBSCRIBED_EVENT
  TRANSFERRED_EVENT
  UNASSIGNED_EVENT
  UNLABELED_EVENT
  UNLOCKED_EVENT
  UNMARKED_AS_DUPLICATE_EVENT
  UNPINNED_EVENT
  UNSUBSCRIBED_EVENT
  USER_BLOCKED_EVENT
}
enum PullRequestUpdateState {
  CLOSED
  OPEN
}
type Push implements Node {
  id: ID!
  nextSha: GitObjectID
  permalink: URI!
  previousSha: GitObjectID
  pusher: Actor!
  repository: Repository!
}
type PushAllowance implements Node {
  actor: PushAllowanceActor
  branchProtectionRule: BranchProtectionRule
  id: ID!
}
union PushAllowanceActor = App | Team | User
type PushAllowanceConnection {
  edges: [PushAllowanceEdge]
  nodes: [PushAllowance]
  pageInfo: PageInfo!
  totalCount: Int!
}
type PushAllowanceEdge {
  cursor: String!
  node: PushAllowance
}
type Query {
  codeOfConduct(
    key: String!
  ): CodeOfConduct
  codesOfConduct: [CodeOfConduct]
  enterprise(
    invitationToken: String
    slug: String!
  ): Enterprise
  enterpriseAdministratorInvitation(
    enterpriseSlug: String!
    role: EnterpriseAdministratorRole!
    userLogin: String!
  ): EnterpriseAdministratorInvitation
  enterpriseAdministratorInvitationByToken(
    invitationToken: String!
  ): EnterpriseAdministratorInvitation
  license(
    key: String!
  ): License
  licenses: [License]!
  marketplaceCategories(
    excludeEmpty: Boolean
    excludeSubcategories: Boolean
    includeCategories: [String!]
  ): [MarketplaceCategory!]!
  marketplaceCategory(
    slug: String!
    useTopicAliases: Boolean
  ): MarketplaceCategory
  marketplaceListing(
    slug: String!
  ): MarketplaceListing
  marketplaceListings(
    adminId: ID
    after: String
    allStates: Boolean
    before: String
    categorySlug: String
    first: Int
    last: Int
    organizationId: ID
    primaryCategoryOnly: Boolean = false
    slugs: [String]
    useTopicAliases: Boolean
    viewerCanAdmin: Boolean
    withFreeTrialsOnly: Boolean = false
  ): MarketplaceListingConnection!
  meta: GitHubMetadata!
  node(
    id: ID!
  ): Node
  nodes(
    ids: [ID!]!
  ): [Node]!
  organization(
    login: String!
  ): Organization
  rateLimit(
    dryRun: Boolean = false
  ): RateLimit
  relay: Query!
  repository(
    followRenames: Boolean = true
    name: String!
    owner: String!
  ): Repository
  repositoryOwner(
    login: String!
  ): RepositoryOwner
  resource(
    url: URI!
  ): UniformResourceLocatable
  search(
    after: String
    before: String
    first: Int
    last: Int
    query: String!
    type: SearchType!
  ): SearchResultItemConnection!
  securityAdvisories(
    after: String
    before: String
    classifications: [SecurityAdvisoryClassification!]
    first: Int
    identifier: SecurityAdvisoryIdentifierFilter
    last: Int
    orderBy: SecurityAdvisoryOrder = {field: UPDATED_AT, direction: DESC}
    publishedSince: DateTime
    updatedSince: DateTime
  ): SecurityAdvisoryConnection!
  securityAdvisory(
    ghsaId: String!
  ): SecurityAdvisory
  securityVulnerabilities(
    after: String
    before: String
    classifications: [SecurityAdvisoryClassification!]
    ecosystem: SecurityAdvisoryEcosystem
    first: Int
    last: Int
    orderBy: SecurityVulnerabilityOrder = {field: UPDATED_AT, direction: DESC}
    package: String
    severities: [SecurityAdvisorySeverity!]
  ): SecurityVulnerabilityConnection!
  sponsorables(
    after: String
    before: String
    dependencyEcosystem: SecurityAdvisoryEcosystem
    ecosystem: DependencyGraphEcosystem
    first: Int
    last: Int
    onlyDependencies: Boolean = false
    orderBy: SponsorableOrder = {field: LOGIN, direction: ASC}
    orgLoginForDependencies: String
  ): SponsorableItemConnection!
  topic(
    name: String!
  ): Topic
  user(
    login: String!
  ): User
  viewer: User!
}
type RateLimit {
  cost: Int!
  limit: Int!
  nodeCount: Int!
  remaining: Int!
  resetAt: DateTime!
  used: Int!
}
interface Reactable {
  databaseId: Int
  id: ID!
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  viewerCanReact: Boolean!
}
type ReactingUserConnection {
  edges: [ReactingUserEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ReactingUserEdge {
  cursor: String!
  node: User!
  reactedAt: DateTime!
}
type Reaction implements Node {
  content: ReactionContent!
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  reactable: Reactable!
  user: User
}
type ReactionConnection {
  edges: [ReactionEdge]
  nodes: [Reaction]
  pageInfo: PageInfo!
  totalCount: Int!
  viewerHasReacted: Boolean!
}
enum ReactionContent {
  CONFUSED
  EYES
  HEART
  HOORAY
  LAUGH
  ROCKET
  THUMBS_DOWN
  THUMBS_UP
}
type ReactionEdge {
  cursor: String!
  node: Reaction
}
type ReactionGroup {
  content: ReactionContent!
  createdAt: DateTime
  reactors(
    after: String
    before: String
    first: Int
    last: Int
  ): ReactorConnection!
  subject: Reactable!
  users(
    after: String
    before: String
    first: Int
    last: Int
  ): ReactingUserConnection!
    @deprecated(
      reason: "Reactors can now be mannequins, bots, and organizations. Use the 'reactors' field instead. Removal on 2021-10-01 UTC."
    )
  viewerHasReacted: Boolean!
}
input ReactionOrder {
  direction: OrderDirection!
  field: ReactionOrderField!
}
enum ReactionOrderField {
  CREATED_AT
}
union Reactor = Bot | Mannequin | Organization | User
type ReactorConnection {
  edges: [ReactorEdge]
  nodes: [Reactor]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ReactorEdge {
  cursor: String!
  node: Reactor!
  reactedAt: DateTime!
}
type ReadyForReviewEvent implements Node & UniformResourceLocatable {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
}
type Ref implements Node {
  associatedPullRequests(
    after: String
    baseRefName: String
    before: String
    first: Int
    headRefName: String
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [PullRequestState!]
  ): PullRequestConnection!
  branchProtectionRule: BranchProtectionRule
  compare(
    headRef: String!
  ): Comparison
  id: ID!
  name: String!
  prefix: String!
  refUpdateRule: RefUpdateRule
  repository: Repository!
  target: GitObject
}
type RefConnection {
  edges: [RefEdge]
  nodes: [Ref]
  pageInfo: PageInfo!
  totalCount: Int!
}
type RefEdge {
  cursor: String!
  node: Ref
}
type RefNameConditionTarget {
  exclude: [String!]!
  include: [String!]!
}
input RefNameConditionTargetInput {
  exclude: [String!]!
  include: [String!]!
}
input RefOrder {
  direction: OrderDirection!
  field: RefOrderField!
}
enum RefOrderField {
  ALPHABETICAL
  TAG_COMMIT_DATE
}
input RefUpdate @preview(toggledBy: "update-refs-preview") {
  afterOid: GitObjectID!
  beforeOid: GitObjectID
  force: Boolean = false
  name: GitRefname!
}
type RefUpdateRule {
  allowsDeletions: Boolean!
  allowsForcePushes: Boolean!
  blocksCreations: Boolean!
  pattern: String!
  requiredApprovingReviewCount: Int
  requiredStatusCheckContexts: [String]
  requiresCodeOwnerReviews: Boolean!
  requiresConversationResolution: Boolean!
  requiresLinearHistory: Boolean!
  requiresSignatures: Boolean!
  viewerAllowedToDismissReviews: Boolean!
  viewerCanPush: Boolean!
}
type ReferencedEvent implements Node {
  actor: Actor
  commit: Commit
  commitRepository: Repository!
  createdAt: DateTime!
  id: ID!
  isCrossRepository: Boolean!
  isDirectReference: Boolean!
  subject: ReferencedSubject!
}
union ReferencedSubject = Issue | PullRequest
input RegenerateEnterpriseIdentityProviderRecoveryCodesInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
}
type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload {
  clientMutationId: String
  identityProvider: EnterpriseIdentityProvider
}
input RegenerateVerifiableDomainTokenInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["VerifiableDomain"])
}
type RegenerateVerifiableDomainTokenPayload {
  clientMutationId: String
  verificationToken: String
}
input RejectDeploymentsInput {
  clientMutationId: String
  comment: String = ""
  environmentIds: [ID!]!
  workflowRunId: ID! @possibleTypes(concreteTypes: ["WorkflowRun"])
}
type RejectDeploymentsPayload {
  clientMutationId: String
  deployments: [Deployment!]
}
type Release implements Node & Reactable & UniformResourceLocatable {
  author: User
  createdAt: DateTime!
  databaseId: Int
  description: String
  descriptionHTML: HTML
  id: ID!
  isDraft: Boolean!
  isLatest: Boolean!
  isPrerelease: Boolean!
  mentions(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection
  name: String
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  releaseAssets(
    after: String
    before: String
    first: Int
    last: Int
    name: String
  ): ReleaseAssetConnection!
  repository: Repository!
  resourcePath: URI!
  shortDescriptionHTML(
    limit: Int = 200
  ): HTML
  tag: Ref
  tagCommit: Commit
  tagName: String!
  updatedAt: DateTime!
  url: URI!
  viewerCanReact: Boolean!
}
type ReleaseAsset implements Node {
  contentType: String!
  createdAt: DateTime!
  downloadCount: Int!
  downloadUrl: URI!
  id: ID!
  name: String!
  release: Release
  size: Int!
  updatedAt: DateTime!
  uploadedBy: User!
  url: URI!
}
type ReleaseAssetConnection {
  edges: [ReleaseAssetEdge]
  nodes: [ReleaseAsset]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ReleaseAssetEdge {
  cursor: String!
  node: ReleaseAsset
}
type ReleaseConnection {
  edges: [ReleaseEdge]
  nodes: [Release]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ReleaseEdge {
  cursor: String!
  node: Release
}
input ReleaseOrder {
  direction: OrderDirection!
  field: ReleaseOrderField!
}
enum ReleaseOrderField {
  CREATED_AT
  NAME
}
input RemoveAssigneesFromAssignableInput {
  assignableId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "Assignable")
  assigneeIds: [ID!]! @possibleTypes(concreteTypes: ["User"])
  clientMutationId: String
}
type RemoveAssigneesFromAssignablePayload {
  assignable: Assignable
  clientMutationId: String
}
input RemoveEnterpriseAdminInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  login: String!
}
type RemoveEnterpriseAdminPayload {
  admin: User
  clientMutationId: String
  enterprise: Enterprise
  message: String
  viewer: User
}
input RemoveEnterpriseIdentityProviderInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
}
type RemoveEnterpriseIdentityProviderPayload {
  clientMutationId: String
  identityProvider: EnterpriseIdentityProvider
}
input RemoveEnterpriseMemberInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  userId: ID! @possibleTypes(concreteTypes: ["User"])
}
type RemoveEnterpriseMemberPayload {
  clientMutationId: String
  enterprise: Enterprise
  user: User
  viewer: User
}
input RemoveEnterpriseOrganizationInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type RemoveEnterpriseOrganizationPayload {
  clientMutationId: String
  enterprise: Enterprise
  organization: Organization
  viewer: User
}
input RemoveEnterpriseSupportEntitlementInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  login: String!
}
type RemoveEnterpriseSupportEntitlementPayload {
  clientMutationId: String
  message: String
}
input RemoveLabelsFromLabelableInput {
  clientMutationId: String
  labelIds: [ID!]! @possibleTypes(concreteTypes: ["Label"])
  labelableId: ID! @possibleTypes(concreteTypes: ["Discussion", "Issue", "PullRequest"], abstractType: "Labelable")
}
type RemoveLabelsFromLabelablePayload {
  clientMutationId: String
  labelable: Labelable
}
input RemoveOutsideCollaboratorInput {
  clientMutationId: String
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
  userId: ID! @possibleTypes(concreteTypes: ["User"])
}
type RemoveOutsideCollaboratorPayload {
  clientMutationId: String
  removedUser: User
}
input RemoveReactionInput {
  clientMutationId: String
  content: ReactionContent!
  subjectId: ID!
    @possibleTypes(
      concreteTypes: [
        "CommitComment"
        "Discussion"
        "DiscussionComment"
        "Issue"
        "IssueComment"
        "PullRequest"
        "PullRequestReview"
        "PullRequestReviewComment"
        "Release"
        "TeamDiscussion"
        "TeamDiscussionComment"
      ]
      abstractType: "Reactable"
    )
}
type RemoveReactionPayload {
  clientMutationId: String
  reaction: Reaction
  reactionGroups: [ReactionGroup!]
  subject: Reactable
}
input RemoveStarInput {
  clientMutationId: String
  starrableId: ID! @possibleTypes(concreteTypes: ["Gist", "Repository", "Topic"], abstractType: "Starrable")
}
type RemoveStarPayload {
  clientMutationId: String
  starrable: Starrable
}
input RemoveUpvoteInput {
  clientMutationId: String
  subjectId: ID! @possibleTypes(concreteTypes: ["Discussion", "DiscussionComment"], abstractType: "Votable")
}
type RemoveUpvotePayload {
  clientMutationId: String
  subject: Votable
}
type RemovedFromMergeQueueEvent implements Node {
  actor: Actor
  beforeCommit: Commit
  createdAt: DateTime!
  enqueuer: User
  id: ID!
  mergeQueue: MergeQueue
  pullRequest: PullRequest
  reason: String
}
type RemovedFromProjectEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  project: Project @preview(toggledBy: "starfox-preview")
  projectColumnName: String! @preview(toggledBy: "starfox-preview")
}
type RenamedTitleEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  currentTitle: String!
  id: ID!
  previousTitle: String!
  subject: RenamedTitleSubject!
}
union RenamedTitleSubject = Issue | PullRequest
input ReopenDiscussionInput {
  clientMutationId: String
  discussionId: ID! @possibleTypes(concreteTypes: ["Discussion"])
}
type ReopenDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}
input ReopenIssueInput {
  clientMutationId: String
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
}
type ReopenIssuePayload {
  clientMutationId: String
  issue: Issue
}
input ReopenPullRequestInput {
  clientMutationId: String
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type ReopenPullRequestPayload {
  clientMutationId: String
  pullRequest: PullRequest
}
type ReopenedEvent implements Node {
  actor: Actor
  closable: Closable!
  createdAt: DateTime!
  id: ID!
  stateReason: IssueStateReason
}
type RepoAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoAccessAuditEntryVisibility
}
enum RepoAccessAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}
type RepoAddMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoAddMemberAuditEntryVisibility
}
enum RepoAddMemberAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}
type RepoAddTopicAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  topic: Topic
  topicName: String
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoArchivedAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoArchivedAuditEntryVisibility
}
enum RepoArchivedAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}
type RepoChangeMergeSettingAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isEnabled: Boolean
  mergeType: RepoChangeMergeSettingAuditEntryMergeType
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum RepoChangeMergeSettingAuditEntryMergeType {
  MERGE
  REBASE
  SQUASH
}
type RepoConfigDisableAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoConfigDisableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoConfigDisableContributorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoConfigDisableSockpuppetDisallowedAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoConfigEnableAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoConfigEnableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoConfigEnableContributorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoConfigEnableSockpuppetDisallowedAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoConfigLockAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoConfigUnlockAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepoCreateAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  forkParentName: String
  forkSourceName: String
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoCreateAuditEntryVisibility
}
enum RepoCreateAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}
type RepoDestroyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoDestroyAuditEntryVisibility
}
enum RepoDestroyAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}
type RepoRemoveMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoRemoveMemberAuditEntryVisibility
}
enum RepoRemoveMemberAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}
type RepoRemoveTopicAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  topic: Topic
  topicName: String
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
enum ReportedContentClassifiers {
  ABUSE
  DUPLICATE
  OFF_TOPIC
  OUTDATED
  RESOLVED
  SPAM
}
type Repository implements Node & PackageOwner & ProjectOwner & ProjectV2Recent & RepositoryInfo & Starrable & Subscribable & UniformResourceLocatable {
  allowUpdateBranch: Boolean!
  archivedAt: DateTime
  assignableUsers(
    after: String
    before: String
    first: Int
    last: Int
    query: String
  ): UserConnection!
  autoMergeAllowed: Boolean!
  branchProtectionRules(
    after: String
    before: String
    first: Int
    last: Int
  ): BranchProtectionRuleConnection!
  codeOfConduct: CodeOfConduct
  codeowners(
    refName: String
  ): RepositoryCodeowners
  collaborators(
    affiliation: CollaboratorAffiliation
    after: String
    before: String
    first: Int
    last: Int
    login: String
    query: String
  ): RepositoryCollaboratorConnection
  commitComments(
    after: String
    before: String
    first: Int
    last: Int
  ): CommitCommentConnection!
  contactLinks: [RepositoryContactLink!]
  createdAt: DateTime!
  databaseId: Int
  defaultBranchRef: Ref
  deleteBranchOnMerge: Boolean!
  dependencyGraphManifests(
    after: String
    before: String
    dependenciesAfter: String
    dependenciesFirst: Int
    first: Int
    last: Int
    withDependencies: Boolean
  ): DependencyGraphManifestConnection @preview(toggledBy: "hawkgirl-preview")
  deployKeys(
    after: String
    before: String
    first: Int
    last: Int
  ): DeployKeyConnection!
  deployments(
    after: String
    before: String
    environments: [String!]
    first: Int
    last: Int
    orderBy: DeploymentOrder = {field: CREATED_AT, direction: ASC}
  ): DeploymentConnection!
  description: String
  descriptionHTML: HTML!
  discussion(
    number: Int!
  ): Discussion
  discussionCategories(
    after: String
    before: String
    filterByAssignable: Boolean = false
    first: Int
    last: Int
  ): DiscussionCategoryConnection!
  discussionCategory(
    slug: String!
  ): DiscussionCategory
  discussions(
    after: String
    before: String
    categoryId: ID = null
    first: Int
    last: Int
    orderBy: DiscussionOrder = {field: UPDATED_AT, direction: DESC}
    states: [DiscussionState!] = []
  ): DiscussionConnection!
  diskUsage: Int
  environment(
    name: String!
  ): Environment
  environments(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: Environments = {field: NAME, direction: ASC}
  ): EnvironmentConnection!
  forkCount: Int!
  forkingAllowed: Boolean!
  forks(
    affiliations: [RepositoryAffiliation]
    after: String
    before: String
    first: Int
    hasIssuesEnabled: Boolean
    isLocked: Boolean
    last: Int
    orderBy: RepositoryOrder
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  fundingLinks: [FundingLink!]!
  hasDiscussionsEnabled: Boolean!
  hasIssuesEnabled: Boolean!
  hasProjectsEnabled: Boolean!
  hasVulnerabilityAlertsEnabled: Boolean!
  hasWikiEnabled: Boolean!
  homepageUrl: URI
  id: ID!
  interactionAbility: RepositoryInteractionAbility
  isArchived: Boolean!
  isBlankIssuesEnabled: Boolean!
  isDisabled: Boolean!
  isEmpty: Boolean!
  isFork: Boolean!
  isInOrganization: Boolean!
  isLocked: Boolean!
  isMirror: Boolean!
  isPrivate: Boolean!
  isSecurityPolicyEnabled: Boolean
  isTemplate: Boolean!
  isUserConfigurationRepository: Boolean!
  issue(
    number: Int!
  ): Issue
  issueOrPullRequest(
    number: Int!
  ): IssueOrPullRequest
  issueTemplates: [IssueTemplate!]
  issues(
    after: String
    before: String
    filterBy: IssueFilters
    first: Int
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [IssueState!]
  ): IssueConnection!
  label(
    name: String!
  ): Label
  labels(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: LabelOrder = {field: CREATED_AT, direction: ASC}
    query: String
  ): LabelConnection
  languages(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: LanguageOrder
  ): LanguageConnection
  latestRelease: Release
  licenseInfo: License
  lockReason: RepositoryLockReason
  mentionableUsers(
    after: String
    before: String
    first: Int
    last: Int
    query: String
  ): UserConnection!
  mergeCommitAllowed: Boolean!
  mergeCommitMessage: MergeCommitMessage!
  mergeCommitTitle: MergeCommitTitle!
  mergeQueue(
    branch: String
  ): MergeQueue
  milestone(
    number: Int!
  ): Milestone
  milestones(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MilestoneOrder
    query: String
    states: [MilestoneState!]
  ): MilestoneConnection
  mirrorUrl: URI
  name: String!
  nameWithOwner: String!
  object(
    expression: String
    oid: GitObjectID
  ): GitObject
  openGraphImageUrl: URI!
  owner: RepositoryOwner!
  packages(
    after: String
    before: String
    first: Int
    last: Int
    names: [String]
    orderBy: PackageOrder = {field: CREATED_AT, direction: DESC}
    packageType: PackageType
    repositoryId: ID
  ): PackageConnection!
  parent: Repository
  pinnedDiscussions(
    after: String
    before: String
    first: Int
    last: Int
  ): PinnedDiscussionConnection!
  pinnedIssues(
    after: String
    before: String
    first: Int
    last: Int
  ): PinnedIssueConnection
  primaryLanguage: Language
  project(
    number: Int!
  ): Project
  projectV2(
    number: Int!
  ): ProjectV2
  projects(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectOrder
    search: String
    states: [ProjectState!]
  ): ProjectConnection!
  projectsResourcePath: URI!
  projectsUrl: URI!
  projectsV2(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2Order = {field: NUMBER, direction: DESC}
    query: String
  ): ProjectV2Connection!
  pullRequest(
    number: Int!
  ): PullRequest
  pullRequestTemplates: [PullRequestTemplate!]
  pullRequests(
    after: String
    baseRefName: String
    before: String
    first: Int
    headRefName: String
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [PullRequestState!]
  ): PullRequestConnection!
  pushedAt: DateTime
  rebaseMergeAllowed: Boolean!
  recentProjects(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2Connection!
  ref(
    qualifiedName: String!
  ): Ref
  refs(
    after: String
    before: String
    direction: OrderDirection
    first: Int
    last: Int
    orderBy: RefOrder
    query: String
    refPrefix: String!
  ): RefConnection
  release(
    tagName: String!
  ): Release
  releases(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ReleaseOrder
  ): ReleaseConnection!
  repositoryTopics(
    after: String
    before: String
    first: Int
    last: Int
  ): RepositoryTopicConnection!
  resourcePath: URI!
  ruleset(
    databaseId: Int!
    includeParents: Boolean = true
  ): RepositoryRuleset
  rulesets(
    after: String
    before: String
    first: Int
    includeParents: Boolean = true
    last: Int
  ): RepositoryRulesetConnection
  securityPolicyUrl: URI
  shortDescriptionHTML(
    limit: Int = 200
  ): HTML!
  squashMergeAllowed: Boolean!
  squashMergeCommitMessage: SquashMergeCommitMessage!
  squashMergeCommitTitle: SquashMergeCommitTitle!
  squashPrTitleUsedAsDefault: Boolean!
    @deprecated(
      reason: "'squashPrTitleUsedAsDefault' will be removed. Use 'Repository.squashMergeCommitTitle' instead. Removal on 2023-04-01 UTC."
    )
  sshUrl: GitSSHRemote!
  stargazerCount: Int!
  stargazers(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: StarOrder
  ): StargazerConnection!
  submodules(
    after: String
    before: String
    first: Int
    last: Int
  ): SubmoduleConnection!
  tempCloneToken: String
  templateRepository: Repository
  updatedAt: DateTime!
  url: URI!
  usesCustomOpenGraphImage: Boolean!
  viewerCanAdminister: Boolean!
  viewerCanCreateProjects: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdateTopics: Boolean!
  viewerDefaultCommitEmail: String
  viewerDefaultMergeMethod: PullRequestMergeMethod!
  viewerHasStarred: Boolean!
  viewerPermission: RepositoryPermission
  viewerPossibleCommitEmails: [String!]
  viewerSubscription: SubscriptionState
  visibility: RepositoryVisibility!
  vulnerabilityAlert(
    number: Int!
  ): RepositoryVulnerabilityAlert
  vulnerabilityAlerts(
    after: String
    before: String
    dependencyScopes: [RepositoryVulnerabilityAlertDependencyScope!]
    first: Int
    last: Int
    states: [RepositoryVulnerabilityAlertState!]
  ): RepositoryVulnerabilityAlertConnection
  watchers(
    after: String
    before: String
    first: Int
    last: Int
  ): UserConnection!
  webCommitSignoffRequired: Boolean!
}
enum RepositoryAffiliation {
  COLLABORATOR
  ORGANIZATION_MEMBER
  OWNER
}
interface RepositoryAuditEntryData {
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
}
type RepositoryCodeowners {
  errors: [RepositoryCodeownersError!]!
}
type RepositoryCodeownersError {
  column: Int!
  kind: String!
  line: Int!
  message: String!
  path: String!
  source: String!
  suggestion: String
}
type RepositoryCollaboratorConnection {
  edges: [RepositoryCollaboratorEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type RepositoryCollaboratorEdge {
  cursor: String!
  node: User!
  permission: RepositoryPermission!
  permissionSources: [PermissionSource!]
}
type RepositoryConnection {
  edges: [RepositoryEdge]
  nodes: [Repository]
  pageInfo: PageInfo!
  totalCount: Int!
  totalDiskUsage: Int!
}
type RepositoryContactLink {
  about: String!
  name: String!
  url: URI!
}
enum RepositoryContributionType {
  COMMIT
  ISSUE
  PULL_REQUEST
  PULL_REQUEST_REVIEW
  REPOSITORY
}
interface RepositoryDiscussionAuthor {
  repositoryDiscussions(
    after: String
    answered: Boolean = null
    before: String
    first: Int
    last: Int
    orderBy: DiscussionOrder = {field: CREATED_AT, direction: DESC}
    repositoryId: ID
    states: [DiscussionState!] = []
  ): DiscussionConnection!
}
interface RepositoryDiscussionCommentAuthor {
  repositoryDiscussionComments(
    after: String
    before: String
    first: Int
    last: Int
    onlyAnswers: Boolean = false
    repositoryId: ID
  ): DiscussionCommentConnection!
}
type RepositoryEdge {
  cursor: String!
  node: Repository
}
type RepositoryIdConditionTarget {
  repositoryIds: [ID!]!
}
input RepositoryIdConditionTargetInput {
  repositoryIds: [ID!]!
}
interface RepositoryInfo {
  archivedAt: DateTime
  createdAt: DateTime!
  description: String
  descriptionHTML: HTML!
  forkCount: Int!
  hasDiscussionsEnabled: Boolean!
  hasIssuesEnabled: Boolean!
  hasProjectsEnabled: Boolean!
  hasWikiEnabled: Boolean!
  homepageUrl: URI
  isArchived: Boolean!
  isFork: Boolean!
  isInOrganization: Boolean!
  isLocked: Boolean!
  isMirror: Boolean!
  isPrivate: Boolean!
  isTemplate: Boolean!
  licenseInfo: License
  lockReason: RepositoryLockReason
  mirrorUrl: URI
  name: String!
  nameWithOwner: String!
  openGraphImageUrl: URI!
  owner: RepositoryOwner!
  pushedAt: DateTime
  resourcePath: URI!
  shortDescriptionHTML(
    limit: Int = 200
  ): HTML!
  updatedAt: DateTime!
  url: URI!
  usesCustomOpenGraphImage: Boolean!
  visibility: RepositoryVisibility!
}
type RepositoryInteractionAbility {
  expiresAt: DateTime
  limit: RepositoryInteractionLimit!
  origin: RepositoryInteractionLimitOrigin!
}
enum RepositoryInteractionLimit {
  COLLABORATORS_ONLY
  CONTRIBUTORS_ONLY
  EXISTING_USERS
  NO_LIMIT
}
enum RepositoryInteractionLimitExpiry {
  ONE_DAY
  ONE_MONTH
  ONE_WEEK
  SIX_MONTHS
  THREE_DAYS
}
enum RepositoryInteractionLimitOrigin {
  ORGANIZATION
  REPOSITORY
  USER
}
type RepositoryInvitation implements Node {
  email: String
  id: ID!
  invitee: User
  inviter: User!
  permalink: URI!
  permission: RepositoryPermission!
  repository: RepositoryInfo
}
type RepositoryInvitationConnection {
  edges: [RepositoryInvitationEdge]
  nodes: [RepositoryInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
}
type RepositoryInvitationEdge {
  cursor: String!
  node: RepositoryInvitation
}
input RepositoryInvitationOrder {
  direction: OrderDirection!
  field: RepositoryInvitationOrderField!
}
enum RepositoryInvitationOrderField {
  CREATED_AT
}
enum RepositoryLockReason {
  BILLING
  MIGRATING
  MOVING
  RENAME
  TRADE_RESTRICTION
}
type RepositoryMigration implements Migration & Node {
  continueOnError: Boolean!
  createdAt: DateTime!
  databaseId: String
  failureReason: String
  id: ID!
  migrationLogUrl: URI
  migrationSource: MigrationSource!
  repositoryName: String!
  sourceUrl: URI!
  state: MigrationState!
  warningsCount: Int!
}
type RepositoryMigrationConnection {
  edges: [RepositoryMigrationEdge]
  nodes: [RepositoryMigration]
  pageInfo: PageInfo!
  totalCount: Int!
}
type RepositoryMigrationEdge {
  cursor: String!
  node: RepositoryMigration
}
input RepositoryMigrationOrder {
  direction: RepositoryMigrationOrderDirection!
  field: RepositoryMigrationOrderField!
}
enum RepositoryMigrationOrderDirection {
  ASC
  DESC
}
enum RepositoryMigrationOrderField {
  CREATED_AT
}
type RepositoryNameConditionTarget {
  exclude: [String!]!
  include: [String!]!
  protected: Boolean!
}
input RepositoryNameConditionTargetInput {
  exclude: [String!]!
  include: [String!]!
  protected: Boolean
}
interface RepositoryNode {
  repository: Repository!
}
input RepositoryOrder {
  direction: OrderDirection!
  field: RepositoryOrderField!
}
enum RepositoryOrderField {
  CREATED_AT
  NAME
  PUSHED_AT
  STARGAZERS
  UPDATED_AT
}
interface RepositoryOwner {
  avatarUrl(
    size: Int
  ): URI!
  id: ID!
  login: String!
  repositories(
    affiliations: [RepositoryAffiliation]
    after: String
    before: String
    first: Int
    hasIssuesEnabled: Boolean
    isArchived: Boolean
    isFork: Boolean
    isLocked: Boolean
    last: Int
    orderBy: RepositoryOrder
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  repository(
    followRenames: Boolean = true
    name: String!
  ): Repository
  resourcePath: URI!
  url: URI!
}
enum RepositoryPermission {
  ADMIN
  MAINTAIN
  READ
  TRIAGE
  WRITE
}
enum RepositoryPrivacy {
  PRIVATE
  PUBLIC
}
type RepositoryRule implements Node {
  id: ID!
  parameters: RuleParameters
  type: RepositoryRuleType!
}
type RepositoryRuleConditions {
  refName: RefNameConditionTarget
  repositoryId: RepositoryIdConditionTarget
  repositoryName: RepositoryNameConditionTarget
}
input RepositoryRuleConditionsInput {
  refName: RefNameConditionTargetInput
  repositoryId: RepositoryIdConditionTargetInput
  repositoryName: RepositoryNameConditionTargetInput
}
type RepositoryRuleConnection {
  edges: [RepositoryRuleEdge]
  nodes: [RepositoryRule]
  pageInfo: PageInfo!
  totalCount: Int!
}
type RepositoryRuleEdge {
  cursor: String!
  node: RepositoryRule
}
input RepositoryRuleInput {
  id: ID @possibleTypes(concreteTypes: ["RepositoryRule"])
  parameters: RuleParametersInput
  type: RepositoryRuleType!
}
enum RepositoryRuleType {
  BRANCH_NAME_PATTERN
  COMMITTER_EMAIL_PATTERN
  COMMIT_AUTHOR_EMAIL_PATTERN
  COMMIT_MESSAGE_PATTERN
  CREATION
  DELETION
  NON_FAST_FORWARD
  PULL_REQUEST
  REQUIRED_DEPLOYMENTS
  REQUIRED_LINEAR_HISTORY
  REQUIRED_SIGNATURES
  REQUIRED_STATUS_CHECKS
  TAG_NAME_PATTERN
  UPDATE
}
type RepositoryRuleset implements Node {
  bypassActors(
    after: String
    before: String
    first: Int
    last: Int
  ): RepositoryRulesetBypassActorConnection
  conditions: RepositoryRuleConditions!
  createdAt: DateTime!
  databaseId: Int
  enforcement: RuleEnforcement!
  id: ID!
  name: String!
  rules(
    after: String
    before: String
    first: Int
    last: Int
    type: RepositoryRuleType
  ): RepositoryRuleConnection
  source: RuleSource!
  target: RepositoryRulesetTarget
  updatedAt: DateTime!
}
type RepositoryRulesetBypassActor implements Node {
  actor: BypassActor
  bypassMode: RepositoryRulesetBypassActorBypassMode
  id: ID!
  organizationAdmin: Boolean!
  repositoryRoleDatabaseId: Int
  repositoryRoleName: String
  repositoryRuleset: RepositoryRuleset
}
enum RepositoryRulesetBypassActorBypassMode {
  ALWAYS
  PULL_REQUEST
}
type RepositoryRulesetBypassActorConnection {
  edges: [RepositoryRulesetBypassActorEdge]
  nodes: [RepositoryRulesetBypassActor]
  pageInfo: PageInfo!
  totalCount: Int!
}
type RepositoryRulesetBypassActorEdge {
  cursor: String!
  node: RepositoryRulesetBypassActor
}
input RepositoryRulesetBypassActorInput {
  actorId: ID
  bypassMode: RepositoryRulesetBypassActorBypassMode!
  organizationAdmin: Boolean
  repositoryRoleDatabaseId: Int
}
type RepositoryRulesetConnection {
  edges: [RepositoryRulesetEdge]
  nodes: [RepositoryRuleset]
  pageInfo: PageInfo!
  totalCount: Int!
}
type RepositoryRulesetEdge {
  cursor: String!
  node: RepositoryRuleset
}
enum RepositoryRulesetTarget {
  BRANCH
  TAG
}
type RepositoryTopic implements Node & UniformResourceLocatable {
  id: ID!
  resourcePath: URI!
  topic: Topic!
  url: URI!
}
type RepositoryTopicConnection {
  edges: [RepositoryTopicEdge]
  nodes: [RepositoryTopic]
  pageInfo: PageInfo!
  totalCount: Int!
}
type RepositoryTopicEdge {
  cursor: String!
  node: RepositoryTopic
}
enum RepositoryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}
type RepositoryVisibilityChangeDisableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepositoryVisibilityChangeEnableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type RepositoryVulnerabilityAlert implements Node & RepositoryNode {
  autoDismissedAt: DateTime
  createdAt: DateTime!
  dependabotUpdate: DependabotUpdate
  dependencyScope: RepositoryVulnerabilityAlertDependencyScope
  dismissComment: String
  dismissReason: String
  dismissedAt: DateTime
  dismisser: User
  fixedAt: DateTime
  id: ID!
  number: Int!
  repository: Repository!
  securityAdvisory: SecurityAdvisory
  securityVulnerability: SecurityVulnerability
  state: RepositoryVulnerabilityAlertState!
  vulnerableManifestFilename: String!
  vulnerableManifestPath: String!
  vulnerableRequirements: String
}
type RepositoryVulnerabilityAlertConnection {
  edges: [RepositoryVulnerabilityAlertEdge]
  nodes: [RepositoryVulnerabilityAlert]
  pageInfo: PageInfo!
  totalCount: Int!
}
enum RepositoryVulnerabilityAlertDependencyScope {
  DEVELOPMENT
  RUNTIME
}
type RepositoryVulnerabilityAlertEdge {
  cursor: String!
  node: RepositoryVulnerabilityAlert
}
enum RepositoryVulnerabilityAlertState {
  AUTO_DISMISSED
  DISMISSED
  FIXED
  OPEN
}
input RequestReviewsInput {
  clientMutationId: String
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
  teamIds: [ID!] @possibleTypes(concreteTypes: ["Team"])
  union: Boolean = false
  userIds: [ID!] @possibleTypes(concreteTypes: ["User"])
}
type RequestReviewsPayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
  requestedReviewersEdge: UserEdge
}
enum RequestableCheckStatusState {
  COMPLETED
  IN_PROGRESS
  PENDING
  QUEUED
  WAITING
}
union RequestedReviewer = Bot | Mannequin | Team | User
type RequestedReviewerConnection {
  edges: [RequestedReviewerEdge]
  nodes: [RequestedReviewer]
  pageInfo: PageInfo!
  totalCount: Int!
}
type RequestedReviewerEdge {
  cursor: String!
  node: RequestedReviewer
}
interface RequirableByPullRequest {
  isRequired(
    pullRequestId: ID
    pullRequestNumber: Int
  ): Boolean!
}
type RequiredDeploymentsParameters {
  requiredDeploymentEnvironments: [String!]!
}
input RequiredDeploymentsParametersInput {
  requiredDeploymentEnvironments: [String!]!
}
type RequiredStatusCheckDescription {
  app: App
  context: String!
}
input RequiredStatusCheckInput {
  appId: ID
  context: String!
}
type RequiredStatusChecksParameters {
  requiredStatusChecks: [StatusCheckConfiguration!]!
  strictRequiredStatusChecksPolicy: Boolean!
}
input RequiredStatusChecksParametersInput {
  requiredStatusChecks: [StatusCheckConfigurationInput!]!
  strictRequiredStatusChecksPolicy: Boolean!
}
input RerequestCheckSuiteInput {
  checkSuiteId: ID! @possibleTypes(concreteTypes: ["CheckSuite"])
  clientMutationId: String
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type RerequestCheckSuitePayload {
  checkSuite: CheckSuite
  clientMutationId: String
}
input ResolveReviewThreadInput {
  clientMutationId: String
  threadId: ID! @possibleTypes(concreteTypes: ["PullRequestReviewThread"])
}
type ResolveReviewThreadPayload {
  clientMutationId: String
  thread: PullRequestReviewThread
}
type RestrictedContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  resourcePath: URI!
  url: URI!
  user: User!
}
input RetireSponsorsTierInput {
  clientMutationId: String
  tierId: ID! @possibleTypes(concreteTypes: ["SponsorsTier"])
}
type RetireSponsorsTierPayload {
  clientMutationId: String
  sponsorsTier: SponsorsTier
}
input RevertPullRequestInput {
  body: String
  clientMutationId: String
  draft: Boolean = false
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
  title: String
}
type RevertPullRequestPayload {
  clientMutationId: String
  pullRequest: PullRequest
  revertPullRequest: PullRequest
}
type ReviewDismissalAllowance implements Node {
  actor: ReviewDismissalAllowanceActor
  branchProtectionRule: BranchProtectionRule
  id: ID!
}
union ReviewDismissalAllowanceActor = App | Team | User
type ReviewDismissalAllowanceConnection {
  edges: [ReviewDismissalAllowanceEdge]
  nodes: [ReviewDismissalAllowance]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ReviewDismissalAllowanceEdge {
  cursor: String!
  node: ReviewDismissalAllowance
}
type ReviewDismissedEvent implements Node & UniformResourceLocatable {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  dismissalMessage: String
  dismissalMessageHTML: String
  id: ID!
  previousReviewState: PullRequestReviewState!
  pullRequest: PullRequest!
  pullRequestCommit: PullRequestCommit
  resourcePath: URI!
  review: PullRequestReview
  url: URI!
}
type ReviewRequest implements Node {
  asCodeOwner: Boolean!
  databaseId: Int
  id: ID!
  pullRequest: PullRequest!
  requestedReviewer: RequestedReviewer
}
type ReviewRequestConnection {
  edges: [ReviewRequestEdge]
  nodes: [ReviewRequest]
  pageInfo: PageInfo!
  totalCount: Int!
}
type ReviewRequestEdge {
  cursor: String!
  node: ReviewRequest
}
type ReviewRequestRemovedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  requestedReviewer: RequestedReviewer
}
type ReviewRequestedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  requestedReviewer: RequestedReviewer
}
type ReviewStatusHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
  reviewDecision: PullRequestReviewDecision
}
input RevokeEnterpriseOrganizationsMigratorRoleInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  login: String!
}
type RevokeEnterpriseOrganizationsMigratorRolePayload {
  clientMutationId: String
  organizations(
    after: String
    before: String
    first: Int
    last: Int
  ): OrganizationConnection
}
input RevokeMigratorRoleInput {
  actor: String!
  actorType: ActorType!
  clientMutationId: String
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type RevokeMigratorRolePayload {
  clientMutationId: String
  success: Boolean
}
enum RoleInOrganization {
  DIRECT_MEMBER
  OWNER
  UNAFFILIATED
}
enum RuleEnforcement {
  ACTIVE
  DISABLED
  EVALUATE
}
union RuleParameters =
    BranchNamePatternParameters
  | CommitAuthorEmailPatternParameters
  | CommitMessagePatternParameters
  | CommitterEmailPatternParameters
  | PullRequestParameters
  | RequiredDeploymentsParameters
  | RequiredStatusChecksParameters
  | TagNamePatternParameters
  | UpdateParameters
input RuleParametersInput {
  branchNamePattern: BranchNamePatternParametersInput
  commitAuthorEmailPattern: CommitAuthorEmailPatternParametersInput
  commitMessagePattern: CommitMessagePatternParametersInput
  committerEmailPattern: CommitterEmailPatternParametersInput
  pullRequest: PullRequestParametersInput
  requiredDeployments: RequiredDeploymentsParametersInput
  requiredStatusChecks: RequiredStatusChecksParametersInput
  tagNamePattern: TagNamePatternParametersInput
  update: UpdateParametersInput
}
union RuleSource = Organization | Repository
enum SamlDigestAlgorithm {
  SHA1
  SHA256
  SHA384
  SHA512
}
enum SamlSignatureAlgorithm {
  RSA_SHA1
  RSA_SHA256
  RSA_SHA384
  RSA_SHA512
}
type SavedReply implements Node {
  body: String!
  bodyHTML: HTML!
  databaseId: Int
  id: ID!
  title: String!
  user: Actor
}
type SavedReplyConnection {
  edges: [SavedReplyEdge]
  nodes: [SavedReply]
  pageInfo: PageInfo!
  totalCount: Int!
}
type SavedReplyEdge {
  cursor: String!
  node: SavedReply
}
input SavedReplyOrder {
  direction: OrderDirection!
  field: SavedReplyOrderField!
}
enum SavedReplyOrderField {
  UPDATED_AT
}
union SearchResultItem = App | Discussion | Issue | MarketplaceListing | Organization | PullRequest | Repository | User
type SearchResultItemConnection {
  codeCount: Int!
  discussionCount: Int!
  edges: [SearchResultItemEdge]
  issueCount: Int!
  nodes: [SearchResultItem]
  pageInfo: PageInfo!
  repositoryCount: Int!
  userCount: Int!
  wikiCount: Int!
}
type SearchResultItemEdge {
  cursor: String!
  node: SearchResultItem
  textMatches: [TextMatch]
}
enum SearchType {
  DISCUSSION
  ISSUE
  REPOSITORY
  USER
}
type SecurityAdvisory implements Node {
  classification: SecurityAdvisoryClassification!
  cvss: CVSS!
  cwes(
    after: String
    before: String
    first: Int
    last: Int
  ): CWEConnection!
  databaseId: Int
  description: String!
  ghsaId: String!
  id: ID!
  identifiers: [SecurityAdvisoryIdentifier!]!
  notificationsPermalink: URI
  origin: String!
  permalink: URI
  publishedAt: DateTime!
  references: [SecurityAdvisoryReference!]!
  severity: SecurityAdvisorySeverity!
  summary: String!
  updatedAt: DateTime!
  vulnerabilities(
    after: String
    before: String
    classifications: [SecurityAdvisoryClassification!]
    ecosystem: SecurityAdvisoryEcosystem
    first: Int
    last: Int
    orderBy: SecurityVulnerabilityOrder = {field: UPDATED_AT, direction: DESC}
    package: String
    severities: [SecurityAdvisorySeverity!]
  ): SecurityVulnerabilityConnection!
  withdrawnAt: DateTime
}
enum SecurityAdvisoryClassification {
  GENERAL
  MALWARE
}
type SecurityAdvisoryConnection {
  edges: [SecurityAdvisoryEdge]
  nodes: [SecurityAdvisory]
  pageInfo: PageInfo!
  totalCount: Int!
}
enum SecurityAdvisoryEcosystem {
  ACTIONS
  COMPOSER
  ERLANG
  GO
  MAVEN
  NPM
  NUGET
  PIP
  PUB
  RUBYGEMS
  RUST
  SWIFT
}
type SecurityAdvisoryEdge {
  cursor: String!
  node: SecurityAdvisory
}
type SecurityAdvisoryIdentifier {
  type: String!
  value: String!
}
input SecurityAdvisoryIdentifierFilter {
  type: SecurityAdvisoryIdentifierType!
  value: String!
}
enum SecurityAdvisoryIdentifierType {
  CVE
  GHSA
}
input SecurityAdvisoryOrder {
  direction: OrderDirection!
  field: SecurityAdvisoryOrderField!
}
enum SecurityAdvisoryOrderField {
  PUBLISHED_AT
  UPDATED_AT
}
type SecurityAdvisoryPackage {
  ecosystem: SecurityAdvisoryEcosystem!
  name: String!
}
type SecurityAdvisoryPackageVersion {
  identifier: String!
}
type SecurityAdvisoryReference {
  url: URI!
}
enum SecurityAdvisorySeverity {
  CRITICAL
  HIGH
  LOW
  MODERATE
}
type SecurityVulnerability {
  advisory: SecurityAdvisory!
  firstPatchedVersion: SecurityAdvisoryPackageVersion
  package: SecurityAdvisoryPackage!
  severity: SecurityAdvisorySeverity!
  updatedAt: DateTime!
  vulnerableVersionRange: String!
}
type SecurityVulnerabilityConnection {
  edges: [SecurityVulnerabilityEdge]
  nodes: [SecurityVulnerability]
  pageInfo: PageInfo!
  totalCount: Int!
}
type SecurityVulnerabilityEdge {
  cursor: String!
  node: SecurityVulnerability
}
input SecurityVulnerabilityOrder {
  direction: OrderDirection!
  field: SecurityVulnerabilityOrderField!
}
enum SecurityVulnerabilityOrderField {
  UPDATED_AT
}
input SetEnterpriseIdentityProviderInput {
  clientMutationId: String
  digestMethod: SamlDigestAlgorithm!
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  idpCertificate: String!
  issuer: String
  signatureMethod: SamlSignatureAlgorithm!
  ssoUrl: URI!
}
type SetEnterpriseIdentityProviderPayload {
  clientMutationId: String
  identityProvider: EnterpriseIdentityProvider
}
input SetOrganizationInteractionLimitInput {
  clientMutationId: String
  expiry: RepositoryInteractionLimitExpiry
  limit: RepositoryInteractionLimit!
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type SetOrganizationInteractionLimitPayload {
  clientMutationId: String
  organization: Organization
}
input SetRepositoryInteractionLimitInput {
  clientMutationId: String
  expiry: RepositoryInteractionLimitExpiry
  limit: RepositoryInteractionLimit!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type SetRepositoryInteractionLimitPayload {
  clientMutationId: String
  repository: Repository
}
input SetUserInteractionLimitInput {
  clientMutationId: String
  expiry: RepositoryInteractionLimitExpiry
  limit: RepositoryInteractionLimit!
  userId: ID! @possibleTypes(concreteTypes: ["User"])
}
type SetUserInteractionLimitPayload {
  clientMutationId: String
  user: User
}
type SmimeSignature implements GitSignature {
  email: String!
  isValid: Boolean!
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}
type SocialAccount {
  displayName: String!
  provider: SocialAccountProvider!
  url: URI!
}
type SocialAccountConnection {
  edges: [SocialAccountEdge]
  nodes: [SocialAccount]
  pageInfo: PageInfo!
  totalCount: Int!
}
type SocialAccountEdge {
  cursor: String!
  node: SocialAccount
}
enum SocialAccountProvider {
  FACEBOOK
  GENERIC
  HOMETOWN
  INSTAGRAM
  LINKEDIN
  MASTODON
  REDDIT
  TWITCH
  TWITTER
  YOUTUBE
}
union Sponsor = Organization | User
type SponsorConnection {
  edges: [SponsorEdge]
  nodes: [Sponsor]
  pageInfo: PageInfo!
  totalCount: Int!
}
type SponsorEdge {
  cursor: String!
  node: Sponsor
}
input SponsorOrder {
  direction: OrderDirection!
  field: SponsorOrderField!
}
enum SponsorOrderField {
  LOGIN
  RELEVANCE
}
interface Sponsorable {
  estimatedNextSponsorsPayoutInCents: Int!
  hasSponsorsListing: Boolean!
  isSponsoredBy(
    accountLogin: String!
  ): Boolean!
  isSponsoringViewer: Boolean!
  monthlyEstimatedSponsorsIncomeInCents: Int!
  sponsoring(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SponsorOrder = {field: RELEVANCE, direction: DESC}
  ): SponsorConnection!
  sponsors(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SponsorOrder = {field: RELEVANCE, direction: DESC}
    tierId: ID
  ): SponsorConnection!
  sponsorsActivities(
    actions: [SponsorsActivityAction!] = []
    after: String
    before: String
    first: Int
    includeAsSponsor: Boolean = false
    includePrivate: Boolean = true
    last: Int
    orderBy: SponsorsActivityOrder = {field: TIMESTAMP, direction: DESC}
    period: SponsorsActivityPeriod = MONTH
    since: DateTime
    until: DateTime
  ): SponsorsActivityConnection!
  sponsorsListing: SponsorsListing
  sponsorshipForViewerAsSponsor(
    activeOnly: Boolean = true
  ): Sponsorship
  sponsorshipForViewerAsSponsorable(
    activeOnly: Boolean = true
  ): Sponsorship
  sponsorshipNewsletters(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SponsorshipNewsletterOrder = {field: CREATED_AT, direction: DESC}
  ): SponsorshipNewsletterConnection!
  sponsorshipsAsMaintainer(
    activeOnly: Boolean = true
    after: String
    before: String
    first: Int
    includePrivate: Boolean = false
    last: Int
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  sponsorshipsAsSponsor(
    activeOnly: Boolean = true
    after: String
    before: String
    first: Int
    last: Int
    maintainerLogins: [String!]
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  totalSponsorshipAmountAsSponsorInCents(
    since: DateTime
    sponsorableLogins: [String!] = []
    until: DateTime
  ): Int
  viewerCanSponsor: Boolean!
  viewerIsSponsoring: Boolean!
}
union SponsorableItem = Organization | User
type SponsorableItemConnection {
  edges: [SponsorableItemEdge]
  nodes: [SponsorableItem]
  pageInfo: PageInfo!
  totalCount: Int!
}
type SponsorableItemEdge {
  cursor: String!
  node: SponsorableItem
}
input SponsorableOrder {
  direction: OrderDirection!
  field: SponsorableOrderField!
}
enum SponsorableOrderField {
  LOGIN
}
type SponsorsActivity implements Node {
  action: SponsorsActivityAction!
  currentPrivacyLevel: SponsorshipPrivacy
  id: ID!
  previousSponsorsTier: SponsorsTier
  sponsor: Sponsor
  sponsorable: Sponsorable!
  sponsorsTier: SponsorsTier
  timestamp: DateTime
  viaBulkSponsorship: Boolean!
}
enum SponsorsActivityAction {
  CANCELLED_SPONSORSHIP
  NEW_SPONSORSHIP
  PENDING_CHANGE
  REFUND
  SPONSOR_MATCH_DISABLED
  TIER_CHANGE
}
type SponsorsActivityConnection {
  edges: [SponsorsActivityEdge]
  nodes: [SponsorsActivity]
  pageInfo: PageInfo!
  totalCount: Int!
}
type SponsorsActivityEdge {
  cursor: String!
  node: SponsorsActivity
}
input SponsorsActivityOrder {
  direction: OrderDirection!
  field: SponsorsActivityOrderField!
}
enum SponsorsActivityOrderField {
  TIMESTAMP
}
enum SponsorsActivityPeriod {
  ALL
  DAY
  MONTH
  WEEK
}
enum SponsorsCountryOrRegionCode {
  AD
  AE
  AF
  AG
  AI
  AL
  AM
  AO
  AQ
  AR
  AS
  AT
  AU
  AW
  AX
  AZ
  BA
  BB
  BD
  BE
  BF
  BG
  BH
  BI
  BJ
  BL
  BM
  BN
  BO
  BQ
  BR
  BS
  BT
  BV
  BW
  BY
  BZ
  CA
  CC
  CD
  CF
  CG
  CH
  CI
  CK
  CL
  CM
  CN
  CO
  CR
  CV
  CW
  CX
  CY
  CZ
  DE
  DJ
  DK
  DM
  DO
  DZ
  EC
  EE
  EG
  EH
  ER
  ES
  ET
  FI
  FJ
  FK
  FM
  FO
  FR
  GA
  GB
  GD
  GE
  GF
  GG
  GH
  GI
  GL
  GM
  GN
  GP
  GQ
  GR
  GS
  GT
  GU
  GW
  GY
  HK
  HM
  HN
  HR
  HT
  HU
  ID
  IE
  IL
  IM
  IN
  IO
  IQ
  IR
  IS
  IT
  JE
  JM
  JO
  JP
  KE
  KG
  KH
  KI
  KM
  KN
  KR
  KW
  KY
  KZ
  LA
  LB
  LC
  LI
  LK
  LR
  LS
  LT
  LU
  LV
  LY
  MA
  MC
  MD
  ME
  MF
  MG
  MH
  MK
  ML
  MM
  MN
  MO
  MP
  MQ
  MR
  MS
  MT
  MU
  MV
  MW
  MX
  MY
  MZ
  NA
  NC
  NE
  NF
  NG
  NI
  NL
  NO
  NP
  NR
  NU
  NZ
  OM
  PA
  PE
  PF
  PG
  PH
  PK
  PL
  PM
  PN
  PR
  PS
  PT
  PW
  PY
  QA
  RE
  RO
  RS
  RU
  RW
  SA
  SB
  SC
  SD
  SE
  SG
  SH
  SI
  SJ
  SK
  SL
  SM
  SN
  SO
  SR
  SS
  ST
  SV
  SX
  SZ
  TC
  TD
  TF
  TG
  TH
  TJ
  TK
  TL
  TM
  TN
  TO
  TR
  TT
  TV
  TW
  TZ
  UA
  UG
  UM
  US
  UY
  UZ
  VA
  VC
  VE
  VG
  VI
  VN
  VU
  WF
  WS
  YE
  YT
  ZA
  ZM
  ZW
}
type SponsorsGoal {
  description: String
  kind: SponsorsGoalKind!
  percentComplete: Int!
  targetValue: Int!
  title: String!
}
enum SponsorsGoalKind {
  MONTHLY_SPONSORSHIP_AMOUNT
  TOTAL_SPONSORS_COUNT
}
type SponsorsListing implements Node {
  activeGoal: SponsorsGoal
  activeStripeConnectAccount: StripeConnectAccount
  billingCountryOrRegion: String
  contactEmailAddress: String
  createdAt: DateTime!
  dashboardResourcePath: URI!
  dashboardUrl: URI!
  featuredItems(
    featureableTypes: [SponsorsListingFeaturedItemFeatureableType!] = [REPOSITORY, USER]
  ): [SponsorsListingFeaturedItem!]!
  fiscalHost: Organization
  fullDescription: String!
  fullDescriptionHTML: HTML!
  id: ID!
  isPublic: Boolean!
  name: String!
  nextPayoutDate: Date
  residenceCountryOrRegion: String
  resourcePath: URI!
  shortDescription: String!
  slug: String!
  sponsorable: Sponsorable!
  tiers(
    after: String
    before: String
    first: Int
    includeUnpublished: Boolean = false
    last: Int
    orderBy: SponsorsTierOrder = {field: MONTHLY_PRICE_IN_CENTS, direction: ASC}
  ): SponsorsTierConnection
  url: URI!
}
union SponsorsListingFeatureableItem = Repository | User
type SponsorsListingFeaturedItem implements Node {
  createdAt: DateTime!
  description: String
  featureable: SponsorsListingFeatureableItem!
  id: ID!
  position: Int!
  sponsorsListing: SponsorsListing!
  updatedAt: DateTime!
}
enum SponsorsListingFeaturedItemFeatureableType {
  REPOSITORY
  USER
}
type SponsorsTier implements Node {
  adminInfo: SponsorsTierAdminInfo
  closestLesserValueTier: SponsorsTier
  createdAt: DateTime!
  description: String!
  descriptionHTML: HTML!
  id: ID!
  isCustomAmount: Boolean!
  isOneTime: Boolean!
  monthlyPriceInCents: Int!
  monthlyPriceInDollars: Int!
  name: String!
  sponsorsListing: SponsorsListing!
  updatedAt: DateTime!
}
type SponsorsTierAdminInfo {
  isDraft: Boolean!
  isPublished: Boolean!
  isRetired: Boolean!
  sponsorships(
    after: String
    before: String
    first: Int
    includePrivate: Boolean = false
    last: Int
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
}
type SponsorsTierConnection {
  edges: [SponsorsTierEdge]
  nodes: [SponsorsTier]
  pageInfo: PageInfo!
  totalCount: Int!
}
type SponsorsTierEdge {
  cursor: String!
  node: SponsorsTier
}
input SponsorsTierOrder {
  direction: OrderDirection!
  field: SponsorsTierOrderField!
}
enum SponsorsTierOrderField {
  CREATED_AT
  MONTHLY_PRICE_IN_CENTS
}
type Sponsorship implements Node {
  createdAt: DateTime!
  id: ID!
  isActive: Boolean!
  isOneTimePayment: Boolean!
  isSponsorOptedIntoEmail: Boolean
  maintainer: User!
    @deprecated(
      reason: "'Sponsorship.maintainer' will be removed. Use 'Sponsorship.sponsorable' instead. Removal on 2020-04-01 UTC."
    )
  privacyLevel: SponsorshipPrivacy!
  sponsor: User
    @deprecated(
      reason: "'Sponsorship.sponsor' will be removed. Use 'Sponsorship.sponsorEntity' instead. Removal on 2020-10-01 UTC."
    )
  sponsorEntity: Sponsor
  sponsorable: Sponsorable!
  tier: SponsorsTier
  tierSelectedAt: DateTime
}
type SponsorshipConnection {
  edges: [SponsorshipEdge]
  nodes: [Sponsorship]
  pageInfo: PageInfo!
  totalCount: Int!
  totalRecurringMonthlyPriceInCents: Int!
  totalRecurringMonthlyPriceInDollars: Int!
}
type SponsorshipEdge {
  cursor: String!
  node: Sponsorship
}
type SponsorshipNewsletter implements Node {
  author: User
  body: String!
  createdAt: DateTime!
  id: ID!
  isPublished: Boolean!
  sponsorable: Sponsorable!
  subject: String!
  updatedAt: DateTime!
}
type SponsorshipNewsletterConnection {
  edges: [SponsorshipNewsletterEdge]
  nodes: [SponsorshipNewsletter]
  pageInfo: PageInfo!
  totalCount: Int!
}
type SponsorshipNewsletterEdge {
  cursor: String!
  node: SponsorshipNewsletter
}
input SponsorshipNewsletterOrder {
  direction: OrderDirection!
  field: SponsorshipNewsletterOrderField!
}
enum SponsorshipNewsletterOrderField {
  CREATED_AT
}
input SponsorshipOrder {
  direction: OrderDirection!
  field: SponsorshipOrderField!
}
enum SponsorshipOrderField {
  CREATED_AT
}
enum SponsorshipPrivacy {
  PRIVATE
  PUBLIC
}
enum SquashMergeCommitMessage {
  BLANK
  COMMIT_MESSAGES
  PR_BODY
}
enum SquashMergeCommitTitle {
  COMMIT_OR_PR_TITLE
  PR_TITLE
}
type SshSignature implements GitSignature {
  email: String!
  isValid: Boolean!
  keyFingerprint: String
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}
input StarOrder {
  direction: OrderDirection!
  field: StarOrderField!
}
enum StarOrderField {
  STARRED_AT
}
type StargazerConnection {
  edges: [StargazerEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type StargazerEdge {
  cursor: String!
  node: User!
  starredAt: DateTime!
}
interface Starrable {
  id: ID!
  stargazerCount: Int!
  stargazers(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: StarOrder
  ): StargazerConnection!
  viewerHasStarred: Boolean!
}
type StarredRepositoryConnection {
  edges: [StarredRepositoryEdge]
  isOverLimit: Boolean!
  nodes: [Repository]
  pageInfo: PageInfo!
  totalCount: Int!
}
type StarredRepositoryEdge {
  cursor: String!
  node: Repository!
  starredAt: DateTime!
}
input StartOrganizationMigrationInput {
  clientMutationId: String
  sourceAccessToken: String!
  sourceOrgUrl: URI!
  targetEnterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  targetOrgName: String!
}
type StartOrganizationMigrationPayload {
  clientMutationId: String
  orgMigration: OrganizationMigration
}
input StartRepositoryMigrationInput {
  accessToken: String
  clientMutationId: String
  continueOnError: Boolean
  gitArchiveUrl: String
  githubPat: String
  lockSource: Boolean
  metadataArchiveUrl: String
  ownerId: ID! @possibleTypes(concreteTypes: ["Organization"])
  repositoryName: String!
  skipReleases: Boolean
  sourceId: ID! @possibleTypes(concreteTypes: ["MigrationSource"])
  sourceRepositoryUrl: URI
  targetRepoVisibility: String
}
type StartRepositoryMigrationPayload {
  clientMutationId: String
  repositoryMigration: RepositoryMigration
}
type Status implements Node {
  combinedContexts(
    after: String
    before: String
    first: Int
    last: Int
  ): StatusCheckRollupContextConnection!
  commit: Commit
  context(
    name: String!
  ): StatusContext
  contexts: [StatusContext!]!
  id: ID!
  state: StatusState!
}
type StatusCheckConfiguration {
  context: String!
  integrationId: Int
}
input StatusCheckConfigurationInput {
  context: String!
  integrationId: Int
}
type StatusCheckRollup implements Node {
  commit: Commit
  contexts(
    after: String
    before: String
    first: Int
    last: Int
  ): StatusCheckRollupContextConnection!
  id: ID!
  state: StatusState!
}
union StatusCheckRollupContext = CheckRun | StatusContext
type StatusCheckRollupContextConnection {
  checkRunCount: Int!
  checkRunCountsByState: [CheckRunStateCount!]
  edges: [StatusCheckRollupContextEdge]
  nodes: [StatusCheckRollupContext]
  pageInfo: PageInfo!
  statusContextCount: Int!
  statusContextCountsByState: [StatusContextStateCount!]
  totalCount: Int!
}
type StatusCheckRollupContextEdge {
  cursor: String!
  node: StatusCheckRollupContext
}
type StatusContext implements Node & RequirableByPullRequest {
  avatarUrl(
    size: Int = 40
  ): URI
  commit: Commit
  context: String!
  createdAt: DateTime!
  creator: Actor
  description: String
  id: ID!
  isRequired(
    pullRequestId: ID
    pullRequestNumber: Int
  ): Boolean!
  state: StatusState!
  targetUrl: URI
}
type StatusContextStateCount {
  count: Int!
  state: StatusState!
}
enum StatusState {
  ERROR
  EXPECTED
  FAILURE
  PENDING
  SUCCESS
}
type StripeConnectAccount {
  accountId: String!
  billingCountryOrRegion: String
  countryOrRegion: String
  isActive: Boolean!
  sponsorsListing: SponsorsListing!
  stripeDashboardUrl: URI!
}
input SubmitPullRequestReviewInput {
  body: String
  clientMutationId: String
  event: PullRequestReviewEvent!
  pullRequestId: ID @possibleTypes(concreteTypes: ["PullRequest"])
  pullRequestReviewId: ID @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type SubmitPullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
}
type Submodule {
  branch: String
  gitUrl: URI!
  name: String!
  nameRaw: Base64String!
  path: String!
  pathRaw: Base64String!
  subprojectCommitOid: GitObjectID
}
type SubmoduleConnection {
  edges: [SubmoduleEdge]
  nodes: [Submodule]
  pageInfo: PageInfo!
  totalCount: Int!
}
type SubmoduleEdge {
  cursor: String!
  node: Submodule
}
interface Subscribable {
  id: ID!
  viewerCanSubscribe: Boolean!
  viewerSubscription: SubscriptionState
}
interface SubscribableThread {
  id: ID!
  viewerThreadSubscriptionFormAction: ThreadSubscriptionFormAction
  viewerThreadSubscriptionStatus: ThreadSubscriptionState
}
type SubscribedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  subscribable: Subscribable!
}
enum SubscriptionState {
  IGNORED
  SUBSCRIBED
  UNSUBSCRIBED
}
type SuggestedReviewer {
  isAuthor: Boolean!
  isCommenter: Boolean!
  reviewer: User!
}
type Tag implements GitObject & Node {
  abbreviatedOid: String!
  commitResourcePath: URI!
  commitUrl: URI!
  id: ID!
  message: String
  name: String!
  oid: GitObjectID!
  repository: Repository!
  tagger: GitActor
  target: GitObject!
}
type TagNamePatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}
input TagNamePatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}
type Team implements MemberStatusable & Node & Subscribable {
  ancestors(
    after: String
    before: String
    first: Int
    last: Int
  ): TeamConnection!
  avatarUrl(
    size: Int = 400
  ): URI
  childTeams(
    after: String
    before: String
    first: Int
    immediateOnly: Boolean = true
    last: Int
    orderBy: TeamOrder
    userLogins: [String!]
  ): TeamConnection!
  combinedSlug: String!
  createdAt: DateTime!
  databaseId: Int
  description: String
  discussion(
    number: Int!
  ): TeamDiscussion
  discussions(
    after: String
    before: String
    first: Int
    isPinned: Boolean
    last: Int
    orderBy: TeamDiscussionOrder
  ): TeamDiscussionConnection!
  discussionsResourcePath: URI!
  discussionsUrl: URI!
  editTeamResourcePath: URI!
  editTeamUrl: URI!
  id: ID!
  invitations(
    after: String
    before: String
    first: Int
    last: Int
  ): OrganizationInvitationConnection
  memberStatuses(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: UserStatusOrder = {field: UPDATED_AT, direction: DESC}
  ): UserStatusConnection!
  members(
    after: String
    before: String
    first: Int
    last: Int
    membership: TeamMembershipType = ALL
    orderBy: TeamMemberOrder
    query: String
    role: TeamMemberRole
  ): TeamMemberConnection!
  membersResourcePath: URI!
  membersUrl: URI!
  name: String!
  newTeamResourcePath: URI!
  newTeamUrl: URI!
  notificationSetting: TeamNotificationSetting!
  organization: Organization!
  parentTeam: Team
  privacy: TeamPrivacy!
  projectV2(
    number: Int!
  ): ProjectV2
  projectsV2(
    after: String
    before: String
    filterBy: ProjectV2Filters = {}
    first: Int
    last: Int
    orderBy: ProjectV2Order = {field: NUMBER, direction: DESC}
    query: String = ""
  ): ProjectV2Connection!
  repositories(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: TeamRepositoryOrder
    query: String
  ): TeamRepositoryConnection!
  repositoriesResourcePath: URI!
  repositoriesUrl: URI!
  resourcePath: URI!
  reviewRequestDelegationAlgorithm: TeamReviewAssignmentAlgorithm @preview(toggledBy: "stone-crop-preview")
  reviewRequestDelegationEnabled: Boolean! @preview(toggledBy: "stone-crop-preview")
  reviewRequestDelegationMemberCount: Int @preview(toggledBy: "stone-crop-preview")
  reviewRequestDelegationNotifyTeam: Boolean! @preview(toggledBy: "stone-crop-preview")
  slug: String!
  teamsResourcePath: URI!
  teamsUrl: URI!
  updatedAt: DateTime!
  url: URI!
  viewerCanAdminister: Boolean!
  viewerCanSubscribe: Boolean!
  viewerSubscription: SubscriptionState
}
type TeamAddMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type TeamAddRepositoryAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
interface TeamAuditEntryData {
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
}
type TeamChangeParentTeamAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  parentTeam: Team
  parentTeamName: String
  parentTeamNameWas: String
  parentTeamResourcePath: URI
  parentTeamUrl: URI
  parentTeamWas: Team
  parentTeamWasResourcePath: URI
  parentTeamWasUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type TeamConnection {
  edges: [TeamEdge]
  nodes: [Team]
  pageInfo: PageInfo!
  totalCount: Int!
}
type TeamDiscussion implements Comment & Deletable & Node & Reactable & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  bodyVersion: String!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  comments(
    after: String
    before: String
    first: Int
    fromComment: Int
    last: Int
    orderBy: TeamDiscussionCommentOrder
  ): TeamDiscussionCommentConnection!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  commentsResourcePath: URI!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  commentsUrl: URI!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  isPinned: Boolean!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  isPrivate: Boolean!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  lastEditedAt: DateTime
  number: Int!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  resourcePath: URI!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  team: Team!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  title: String!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  updatedAt: DateTime!
  url: URI!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanPin: Boolean!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  viewerCanReact: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
  viewerSubscription: SubscriptionState
}
type TeamDiscussionComment implements Comment & Deletable & Node & Reactable & UniformResourceLocatable & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  bodyVersion: String!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  discussion: TeamDiscussion!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  lastEditedAt: DateTime
  number: Int!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(
    after: String
    before: String
    content: ReactionContent
    first: Int
    last: Int
    orderBy: ReactionOrder
  ): ReactionConnection!
  resourcePath: URI!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  updatedAt: DateTime!
  url: URI!
    @deprecated(
      reason: "The Team Discussions feature is deprecated in favor of Organization Discussions. Follow the guide at https://github.blog/changelog/2023-02-08-sunset-notice-team-discussions/ to find a suitable replacement. Removal on 2024-07-01 UTC."
    )
  userContentEdits(
    after: String
    before: String
    first: Int
    last: Int
  ): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}
type TeamDiscussionCommentConnection {
  edges: [TeamDiscussionCommentEdge]
  nodes: [TeamDiscussionComment]
  pageInfo: PageInfo!
  totalCount: Int!
}
type TeamDiscussionCommentEdge {
  cursor: String!
  node: TeamDiscussionComment
}
input TeamDiscussionCommentOrder {
  direction: OrderDirection!
  field: TeamDiscussionCommentOrderField!
}
enum TeamDiscussionCommentOrderField {
  NUMBER
}
type TeamDiscussionConnection {
  edges: [TeamDiscussionEdge]
  nodes: [TeamDiscussion]
  pageInfo: PageInfo!
  totalCount: Int!
}
type TeamDiscussionEdge {
  cursor: String!
  node: TeamDiscussion
}
input TeamDiscussionOrder {
  direction: OrderDirection!
  field: TeamDiscussionOrderField!
}
enum TeamDiscussionOrderField {
  CREATED_AT
}
type TeamEdge {
  cursor: String!
  node: Team
}
type TeamMemberConnection {
  edges: [TeamMemberEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type TeamMemberEdge {
  cursor: String!
  memberAccessResourcePath: URI!
  memberAccessUrl: URI!
  node: User!
  role: TeamMemberRole!
}
input TeamMemberOrder {
  direction: OrderDirection!
  field: TeamMemberOrderField!
}
enum TeamMemberOrderField {
  CREATED_AT
  LOGIN
}
enum TeamMemberRole {
  MAINTAINER
  MEMBER
}
enum TeamMembershipType {
  ALL
  CHILD_TEAM
  IMMEDIATE
}
enum TeamNotificationSetting {
  NOTIFICATIONS_DISABLED
  NOTIFICATIONS_ENABLED
}
input TeamOrder {
  direction: OrderDirection!
  field: TeamOrderField!
}
enum TeamOrderField {
  NAME
}
enum TeamPrivacy {
  SECRET
  VISIBLE
}
type TeamRemoveMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type TeamRemoveRepositoryAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}
type TeamRepositoryConnection {
  edges: [TeamRepositoryEdge]
  nodes: [Repository]
  pageInfo: PageInfo!
  totalCount: Int!
}
type TeamRepositoryEdge {
  cursor: String!
  node: Repository!
  permission: RepositoryPermission!
}
input TeamRepositoryOrder {
  direction: OrderDirection!
  field: TeamRepositoryOrderField!
}
enum TeamRepositoryOrderField {
  CREATED_AT
  NAME
  PERMISSION
  PUSHED_AT
  STARGAZERS
  UPDATED_AT
}
enum TeamReviewAssignmentAlgorithm @preview(toggledBy: "stone-crop-preview") {
  LOAD_BALANCE
  ROUND_ROBIN
}
enum TeamRole {
  ADMIN
  MEMBER
}
type TextMatch {
  fragment: String!
  highlights: [TextMatchHighlight!]!
  property: String!
}
type TextMatchHighlight {
  beginIndice: Int!
  endIndice: Int!
  text: String!
}
enum ThreadSubscriptionFormAction {
  NONE
  SUBSCRIBE
  UNSUBSCRIBE
}
enum ThreadSubscriptionState {
  DISABLED
  IGNORING_LIST
  IGNORING_THREAD
  NONE
  SUBSCRIBED_TO_LIST
  SUBSCRIBED_TO_THREAD
  SUBSCRIBED_TO_THREAD_EVENTS
  SUBSCRIBED_TO_THREAD_TYPE
  UNAVAILABLE
}
type Topic implements Node & Starrable {
  id: ID!
  name: String!
  relatedTopics(
    first: Int = 3
  ): [Topic!]!
  repositories(
    affiliations: [RepositoryAffiliation]
    after: String
    before: String
    first: Int
    hasIssuesEnabled: Boolean
    isLocked: Boolean
    last: Int
    orderBy: RepositoryOrder
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    privacy: RepositoryPrivacy
    sponsorableOnly: Boolean = false
  ): RepositoryConnection!
  stargazerCount: Int!
  stargazers(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: StarOrder
  ): StargazerConnection!
  viewerHasStarred: Boolean!
}
interface TopicAuditEntryData {
  topic: Topic
  topicName: String
}
enum TopicSuggestionDeclineReason {
  NOT_RELEVANT
  PERSONAL_PREFERENCE
  TOO_GENERAL
  TOO_SPECIFIC
}
enum TrackedIssueStates {
  CLOSED
  OPEN
}
input TransferEnterpriseOrganizationInput {
  clientMutationId: String
  destinationEnterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type TransferEnterpriseOrganizationPayload {
  clientMutationId: String
  organization: Organization
}
input TransferIssueInput {
  clientMutationId: String
  createLabelsIfMissing: Boolean = false
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type TransferIssuePayload {
  clientMutationId: String
  issue: Issue
}
type TransferredEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  fromRepository: Repository
  id: ID!
  issue: Issue!
}
type Tree implements GitObject & Node {
  abbreviatedOid: String!
  commitResourcePath: URI!
  commitUrl: URI!
  entries: [TreeEntry!]
  id: ID!
  oid: GitObjectID!
  repository: Repository!
}
type TreeEntry {
  extension: String
  isGenerated: Boolean!
  language: Language
  lineCount: Int
  mode: Int!
  name: String!
  nameRaw: Base64String!
  object: GitObject
  oid: GitObjectID!
  path: String
  pathRaw: Base64String
  repository: Repository!
  size: Int!
  submodule: Submodule
  type: String!
}
scalar URI
input UnarchiveProjectV2ItemInput {
  clientMutationId: String
  itemId: ID! @possibleTypes(concreteTypes: ["ProjectV2Item"])
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
type UnarchiveProjectV2ItemPayload {
  clientMutationId: String
  item: ProjectV2Item
}
input UnarchiveRepositoryInput {
  clientMutationId: String
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type UnarchiveRepositoryPayload {
  clientMutationId: String
  repository: Repository
}
type UnassignedEvent implements Node {
  actor: Actor
  assignable: Assignable!
  assignee: Assignee
  createdAt: DateTime!
  id: ID!
  user: User
    @deprecated(reason: "Assignees can now be mannequins. Use the 'assignee' field instead. Removal on 2020-01-01 UTC.")
}
input UnfollowOrganizationInput {
  clientMutationId: String
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type UnfollowOrganizationPayload {
  clientMutationId: String
  organization: Organization
}
input UnfollowUserInput {
  clientMutationId: String
  userId: ID! @possibleTypes(concreteTypes: ["User"])
}
type UnfollowUserPayload {
  clientMutationId: String
  user: User
}
interface UniformResourceLocatable {
  resourcePath: URI!
  url: URI!
}
type UnknownSignature implements GitSignature {
  email: String!
  isValid: Boolean!
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}
type UnlabeledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  label: Label!
  labelable: Labelable!
}
input UnlinkProjectV2FromRepositoryInput {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type UnlinkProjectV2FromRepositoryPayload {
  clientMutationId: String
  repository: Repository
}
input UnlinkProjectV2FromTeamInput {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
  teamId: ID! @possibleTypes(concreteTypes: ["Team"])
}
type UnlinkProjectV2FromTeamPayload {
  clientMutationId: String
  team: Team
}
input UnlinkRepositoryFromProjectInput {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type UnlinkRepositoryFromProjectPayload {
  clientMutationId: String
  project: Project
  repository: Repository
}
input UnlockLockableInput {
  clientMutationId: String
  lockableId: ID! @possibleTypes(concreteTypes: ["Discussion", "Issue", "PullRequest"], abstractType: "Lockable")
}
type UnlockLockablePayload {
  actor: Actor
  clientMutationId: String
  unlockedRecord: Lockable
}
type UnlockedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  lockable: Lockable!
}
input UnmarkDiscussionCommentAsAnswerInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["DiscussionComment"])
}
type UnmarkDiscussionCommentAsAnswerPayload {
  clientMutationId: String
  discussion: Discussion
}
input UnmarkFileAsViewedInput {
  clientMutationId: String
  path: String!
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type UnmarkFileAsViewedPayload {
  clientMutationId: String
  pullRequest: PullRequest
}
input UnmarkIssueAsDuplicateInput {
  canonicalId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "IssueOrPullRequest")
  clientMutationId: String
  duplicateId: ID! @possibleTypes(concreteTypes: ["Issue", "PullRequest"], abstractType: "IssueOrPullRequest")
}
type UnmarkIssueAsDuplicatePayload {
  clientMutationId: String
  duplicate: IssueOrPullRequest
}
input UnmarkProjectV2AsTemplateInput {
  clientMutationId: String
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
type UnmarkProjectV2AsTemplatePayload {
  clientMutationId: String
  projectV2: ProjectV2
}
type UnmarkedAsDuplicateEvent implements Node {
  actor: Actor
  canonical: IssueOrPullRequest
  createdAt: DateTime!
  duplicate: IssueOrPullRequest
  id: ID!
  isCrossRepository: Boolean!
}
input UnminimizeCommentInput {
  clientMutationId: String
  subjectId: ID!
    @possibleTypes(
      concreteTypes: ["CommitComment", "DiscussionComment", "GistComment", "IssueComment", "PullRequestReviewComment"]
      abstractType: "Minimizable"
    )
}
type UnminimizeCommentPayload {
  clientMutationId: String
  unminimizedComment: Minimizable
}
input UnpinIssueInput {
  clientMutationId: String
  issueId: ID! @possibleTypes(concreteTypes: ["Issue"])
}
type UnpinIssuePayload {
  clientMutationId: String
  issue: Issue
}
type UnpinnedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  issue: Issue!
}
input UnresolveReviewThreadInput {
  clientMutationId: String
  threadId: ID! @possibleTypes(concreteTypes: ["PullRequestReviewThread"])
}
type UnresolveReviewThreadPayload {
  clientMutationId: String
  thread: PullRequestReviewThread
}
type UnsubscribedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  subscribable: Subscribable!
}
interface Updatable {
  viewerCanUpdate: Boolean!
}
interface UpdatableComment {
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
}
input UpdateBranchProtectionRuleInput {
  allowsDeletions: Boolean
  allowsForcePushes: Boolean
  blocksCreations: Boolean
  branchProtectionRuleId: ID! @possibleTypes(concreteTypes: ["BranchProtectionRule"])
  bypassForcePushActorIds: [ID!]
  bypassPullRequestActorIds: [ID!]
  clientMutationId: String
  dismissesStaleReviews: Boolean
  isAdminEnforced: Boolean
  lockAllowsFetchAndMerge: Boolean
  lockBranch: Boolean
  pattern: String
  pushActorIds: [ID!]
  requireLastPushApproval: Boolean
  requiredApprovingReviewCount: Int
  requiredDeploymentEnvironments: [String!]
  requiredStatusCheckContexts: [String!]
  requiredStatusChecks: [RequiredStatusCheckInput!]
  requiresApprovingReviews: Boolean
  requiresCodeOwnerReviews: Boolean
  requiresCommitSignatures: Boolean
  requiresConversationResolution: Boolean
  requiresDeployments: Boolean
  requiresLinearHistory: Boolean
  requiresStatusChecks: Boolean
  requiresStrictStatusChecks: Boolean
  restrictsPushes: Boolean
  restrictsReviewDismissals: Boolean
  reviewDismissalActorIds: [ID!]
}
type UpdateBranchProtectionRulePayload {
  branchProtectionRule: BranchProtectionRule
  clientMutationId: String
}
input UpdateCheckRunInput {
  actions: [CheckRunAction!]
  checkRunId: ID! @possibleTypes(concreteTypes: ["CheckRun"])
  clientMutationId: String
  completedAt: DateTime
  conclusion: CheckConclusionState
  detailsUrl: URI
  externalId: String
  name: String
  output: CheckRunOutput
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  startedAt: DateTime
  status: RequestableCheckStatusState
}
type UpdateCheckRunPayload {
  checkRun: CheckRun
  clientMutationId: String
}
input UpdateCheckSuitePreferencesInput {
  autoTriggerPreferences: [CheckSuiteAutoTriggerPreference!]!
  clientMutationId: String
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type UpdateCheckSuitePreferencesPayload {
  clientMutationId: String
  repository: Repository
}
input UpdateDiscussionCommentInput {
  body: String!
  clientMutationId: String
  commentId: ID! @possibleTypes(concreteTypes: ["DiscussionComment"])
}
type UpdateDiscussionCommentPayload {
  clientMutationId: String
  comment: DiscussionComment
}
input UpdateDiscussionInput {
  body: String
  categoryId: ID @possibleTypes(concreteTypes: ["DiscussionCategory"])
  clientMutationId: String
  discussionId: ID! @possibleTypes(concreteTypes: ["Discussion"])
  title: String
}
type UpdateDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}
input UpdateEnterpriseAdministratorRoleInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  login: String!
  role: EnterpriseAdministratorRole!
}
type UpdateEnterpriseAdministratorRolePayload {
  clientMutationId: String
  message: String
}
input UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  policyValue: EnterpriseAllowPrivateRepositoryForkingPolicyValue
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseDefaultRepositoryPermissionSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue!
}
type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseMembersCanCreateRepositoriesSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  membersCanCreateInternalRepositories: Boolean
  membersCanCreatePrivateRepositories: Boolean
  membersCanCreatePublicRepositories: Boolean
  membersCanCreateRepositoriesPolicyEnabled: Boolean
  settingValue: EnterpriseMembersCanCreateRepositoriesSettingValue
}
type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseMembersCanDeleteIssuesSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseMembersCanMakePurchasesSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseMembersCanMakePurchasesSettingValue!
}
type UpdateEnterpriseMembersCanMakePurchasesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseOrganizationProjectsSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseOrganizationProjectsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseOwnerOrganizationRoleInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
  organizationRole: RoleInOrganization!
}
type UpdateEnterpriseOwnerOrganizationRolePayload {
  clientMutationId: String
  message: String
}
input UpdateEnterpriseProfileInput {
  clientMutationId: String
  description: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  location: String
  name: String
  websiteUrl: String
}
type UpdateEnterpriseProfilePayload {
  clientMutationId: String
  enterprise: Enterprise
}
input UpdateEnterpriseRepositoryProjectsSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseRepositoryProjectsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseTeamDiscussionsSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledDisabledSettingValue!
}
type UpdateEnterpriseTeamDiscussionsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput {
  clientMutationId: String
  enterpriseId: ID! @possibleTypes(concreteTypes: ["Enterprise"])
  settingValue: EnterpriseEnabledSettingValue!
}
type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}
input UpdateEnvironmentInput {
  clientMutationId: String
  environmentId: ID! @possibleTypes(concreteTypes: ["Environment"])
  reviewers: [ID!]
  waitTimer: Int
}
type UpdateEnvironmentPayload {
  clientMutationId: String
  environment: Environment
}
input UpdateIpAllowListEnabledSettingInput {
  clientMutationId: String
  ownerId: ID! @possibleTypes(concreteTypes: ["App", "Enterprise", "Organization"], abstractType: "IpAllowListOwner")
  settingValue: IpAllowListEnabledSettingValue!
}
type UpdateIpAllowListEnabledSettingPayload {
  clientMutationId: String
  owner: IpAllowListOwner
}
input UpdateIpAllowListEntryInput {
  allowListValue: String!
  clientMutationId: String
  ipAllowListEntryId: ID! @possibleTypes(concreteTypes: ["IpAllowListEntry"])
  isActive: Boolean!
  name: String
}
type UpdateIpAllowListEntryPayload {
  clientMutationId: String
  ipAllowListEntry: IpAllowListEntry
}
input UpdateIpAllowListForInstalledAppsEnabledSettingInput {
  clientMutationId: String
  ownerId: ID! @possibleTypes(concreteTypes: ["App", "Enterprise", "Organization"], abstractType: "IpAllowListOwner")
  settingValue: IpAllowListForInstalledAppsEnabledSettingValue!
}
type UpdateIpAllowListForInstalledAppsEnabledSettingPayload {
  clientMutationId: String
  owner: IpAllowListOwner
}
input UpdateIssueCommentInput {
  body: String!
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["IssueComment"])
}
type UpdateIssueCommentPayload {
  clientMutationId: String
  issueComment: IssueComment
}
input UpdateIssueInput {
  assigneeIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  body: String
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["Issue"])
  labelIds: [ID!] @possibleTypes(concreteTypes: ["Label"])
  milestoneId: ID @possibleTypes(concreteTypes: ["Milestone"])
  projectIds: [ID!]
  state: IssueState
  title: String
}
type UpdateIssuePayload {
  actor: Actor
  clientMutationId: String
  issue: Issue
}
input UpdateLabelInput @preview(toggledBy: "bane-preview") {
  clientMutationId: String
  color: String
  description: String
  id: ID! @possibleTypes(concreteTypes: ["Label"])
  name: String
}
type UpdateLabelPayload @preview(toggledBy: "bane-preview") {
  clientMutationId: String
  label: Label
}
input UpdateNotificationRestrictionSettingInput {
  clientMutationId: String
  ownerId: ID! @possibleTypes(concreteTypes: ["Enterprise", "Organization"], abstractType: "VerifiableDomainOwner")
  settingValue: NotificationRestrictionSettingValue!
}
type UpdateNotificationRestrictionSettingPayload {
  clientMutationId: String
  owner: VerifiableDomainOwner
}
input UpdateOrganizationAllowPrivateRepositoryForkingSettingInput {
  clientMutationId: String
  forkingEnabled: Boolean!
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
}
type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload {
  clientMutationId: String
  message: String
  organization: Organization
}
input UpdateOrganizationWebCommitSignoffSettingInput {
  clientMutationId: String
  organizationId: ID! @possibleTypes(concreteTypes: ["Organization"])
  webCommitSignoffRequired: Boolean!
}
type UpdateOrganizationWebCommitSignoffSettingPayload {
  clientMutationId: String
  message: String
  organization: Organization
}
type UpdateParameters {
  updateAllowsFetchAndMerge: Boolean!
}
input UpdateParametersInput {
  updateAllowsFetchAndMerge: Boolean!
}
input UpdateProjectCardInput {
  clientMutationId: String
  isArchived: Boolean
  note: String
  projectCardId: ID! @possibleTypes(concreteTypes: ["ProjectCard"])
}
type UpdateProjectCardPayload {
  clientMutationId: String
  projectCard: ProjectCard
}
input UpdateProjectColumnInput {
  clientMutationId: String
  name: String!
  projectColumnId: ID! @possibleTypes(concreteTypes: ["ProjectColumn"])
}
type UpdateProjectColumnPayload {
  clientMutationId: String
  projectColumn: ProjectColumn
}
input UpdateProjectInput {
  body: String
  clientMutationId: String
  name: String
  projectId: ID! @possibleTypes(concreteTypes: ["Project"])
  public: Boolean
  state: ProjectState
}
type UpdateProjectPayload {
  clientMutationId: String
  project: Project
}
input UpdateProjectV2CollaboratorsInput {
  clientMutationId: String
  collaborators: [ProjectV2Collaborator!]!
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
type UpdateProjectV2CollaboratorsPayload {
  clientMutationId: String
  collaborators(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2ActorConnection
}
input UpdateProjectV2DraftIssueInput {
  assigneeIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  body: String
  clientMutationId: String
  draftIssueId: ID! @possibleTypes(concreteTypes: ["DraftIssue"])
  title: String
}
type UpdateProjectV2DraftIssuePayload {
  clientMutationId: String
  draftIssue: DraftIssue
}
input UpdateProjectV2Input {
  clientMutationId: String
  closed: Boolean
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
  public: Boolean
  readme: String
  shortDescription: String
  title: String
}
input UpdateProjectV2ItemFieldValueInput {
  clientMutationId: String
  fieldId: ID!
    @possibleTypes(
      concreteTypes: ["ProjectV2Field", "ProjectV2IterationField", "ProjectV2SingleSelectField"]
      abstractType: "ProjectV2FieldConfiguration"
    )
  itemId: ID! @possibleTypes(concreteTypes: ["ProjectV2Item"])
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
  value: ProjectV2FieldValue!
}
type UpdateProjectV2ItemFieldValuePayload {
  clientMutationId: String
  projectV2Item: ProjectV2Item
}
input UpdateProjectV2ItemPositionInput {
  afterId: ID @possibleTypes(concreteTypes: ["ProjectV2Item"])
  clientMutationId: String
  itemId: ID! @possibleTypes(concreteTypes: ["ProjectV2Item"])
  projectId: ID! @possibleTypes(concreteTypes: ["ProjectV2"])
}
type UpdateProjectV2ItemPositionPayload {
  clientMutationId: String
  items(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2ItemConnection
}
type UpdateProjectV2Payload {
  clientMutationId: String
  projectV2: ProjectV2
}
input UpdatePullRequestBranchInput {
  clientMutationId: String
  expectedHeadOid: GitObjectID
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
}
type UpdatePullRequestBranchPayload {
  clientMutationId: String
  pullRequest: PullRequest
}
input UpdatePullRequestInput {
  assigneeIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  baseRefName: String
  body: String
  clientMutationId: String
  labelIds: [ID!] @possibleTypes(concreteTypes: ["Label"])
  maintainerCanModify: Boolean
  milestoneId: ID @possibleTypes(concreteTypes: ["Milestone"])
  projectIds: [ID!]
  pullRequestId: ID! @possibleTypes(concreteTypes: ["PullRequest"])
  state: PullRequestUpdateState
  title: String
}
type UpdatePullRequestPayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
}
input UpdatePullRequestReviewCommentInput {
  body: String!
  clientMutationId: String
  pullRequestReviewCommentId: ID! @possibleTypes(concreteTypes: ["PullRequestReviewComment"])
}
type UpdatePullRequestReviewCommentPayload {
  clientMutationId: String
  pullRequestReviewComment: PullRequestReviewComment
}
input UpdatePullRequestReviewInput {
  body: String!
  clientMutationId: String
  pullRequestReviewId: ID! @possibleTypes(concreteTypes: ["PullRequestReview"])
}
type UpdatePullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
}
input UpdateRefInput {
  clientMutationId: String
  force: Boolean = false
  oid: GitObjectID!
  refId: ID! @possibleTypes(concreteTypes: ["Ref"])
}
type UpdateRefPayload {
  clientMutationId: String
  ref: Ref
}
input UpdateRefsInput @preview(toggledBy: "update-refs-preview") {
  clientMutationId: String
  refUpdates: [RefUpdate!]!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
}
type UpdateRefsPayload @preview(toggledBy: "update-refs-preview") {
  clientMutationId: String
}
input UpdateRepositoryInput {
  clientMutationId: String
  description: String
  hasDiscussionsEnabled: Boolean
  hasIssuesEnabled: Boolean
  hasProjectsEnabled: Boolean
  hasWikiEnabled: Boolean
  homepageUrl: URI
  name: String
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  template: Boolean
}
type UpdateRepositoryPayload {
  clientMutationId: String
  repository: Repository
}
input UpdateRepositoryRulesetInput {
  bypassActors: [RepositoryRulesetBypassActorInput!]
  clientMutationId: String
  conditions: RepositoryRuleConditionsInput
  enforcement: RuleEnforcement
  name: String
  repositoryRulesetId: ID! @possibleTypes(concreteTypes: ["RepositoryRuleset"])
  rules: [RepositoryRuleInput!]
  target: RepositoryRulesetTarget
}
type UpdateRepositoryRulesetPayload {
  clientMutationId: String
  ruleset: RepositoryRuleset
}
input UpdateRepositoryWebCommitSignoffSettingInput {
  clientMutationId: String
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  webCommitSignoffRequired: Boolean!
}
type UpdateRepositoryWebCommitSignoffSettingPayload {
  clientMutationId: String
  message: String
  repository: Repository
}
input UpdateSponsorshipPreferencesInput {
  clientMutationId: String
  privacyLevel: SponsorshipPrivacy = PUBLIC
  receiveEmails: Boolean = true
  sponsorId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "Sponsor")
  sponsorLogin: String
  sponsorableId: ID @possibleTypes(concreteTypes: ["Organization", "User"], abstractType: "Sponsorable")
  sponsorableLogin: String
}
type UpdateSponsorshipPreferencesPayload {
  clientMutationId: String
  sponsorship: Sponsorship
}
input UpdateSubscriptionInput {
  clientMutationId: String
  state: SubscriptionState!
  subscribableId: ID!
    @possibleTypes(
      concreteTypes: ["Commit", "Discussion", "Issue", "PullRequest", "Repository", "Team", "TeamDiscussion"]
      abstractType: "Subscribable"
    )
}
type UpdateSubscriptionPayload {
  clientMutationId: String
  subscribable: Subscribable
}
input UpdateTeamDiscussionCommentInput {
  body: String!
  bodyVersion: String
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["TeamDiscussionComment"])
}
type UpdateTeamDiscussionCommentPayload {
  clientMutationId: String
  teamDiscussionComment: TeamDiscussionComment
}
input UpdateTeamDiscussionInput {
  body: String
  bodyVersion: String
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["TeamDiscussion"])
  pinned: Boolean
  title: String
}
type UpdateTeamDiscussionPayload {
  clientMutationId: String
  teamDiscussion: TeamDiscussion
}
input UpdateTeamReviewAssignmentInput @preview(toggledBy: "stone-crop-preview") {
  algorithm: TeamReviewAssignmentAlgorithm = ROUND_ROBIN
  clientMutationId: String
  enabled: Boolean!
  excludedTeamMemberIds: [ID!] @possibleTypes(concreteTypes: ["User"])
  id: ID! @possibleTypes(concreteTypes: ["Team"])
  notifyTeam: Boolean = true
  teamMemberCount: Int = 1
}
type UpdateTeamReviewAssignmentPayload {
  clientMutationId: String
  team: Team
}
input UpdateTeamsRepositoryInput {
  clientMutationId: String
  permission: RepositoryPermission!
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  teamIds: [ID!]! @possibleTypes(concreteTypes: ["Team"])
}
type UpdateTeamsRepositoryPayload {
  clientMutationId: String
  repository: Repository
  teams: [Team!]
}
input UpdateTopicsInput {
  clientMutationId: String
  repositoryId: ID! @possibleTypes(concreteTypes: ["Repository"])
  topicNames: [String!]!
}
type UpdateTopicsPayload {
  clientMutationId: String
  invalidTopicNames: [String!]
  repository: Repository
}
type User implements Actor & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable {
  anyPinnableItems(
    type: PinnableItemType
  ): Boolean!
  avatarUrl(
    size: Int
  ): URI!
  bio: String
  bioHTML: HTML!
  canReceiveOrganizationEmailsWhenNotificationsRestricted(
    login: String!
  ): Boolean!
  commitComments(
    after: String
    before: String
    first: Int
    last: Int
  ): CommitCommentConnection!
  company: String
  companyHTML: HTML!
  contributionsCollection(
    from: DateTime
    organizationID: ID
    to: DateTime
  ): ContributionsCollection!
  createdAt: DateTime!
  databaseId: Int
  email: String!
  estimatedNextSponsorsPayoutInCents: Int!
  followers(
    after: String
    before: String
    first: Int
    last: Int
  ): FollowerConnection!
  following(
    after: String
    before: String
    first: Int
    last: Int
  ): FollowingConnection!
  gist(
    name: String!
  ): Gist
  gistComments(
    after: String
    before: String
    first: Int
    last: Int
  ): GistCommentConnection!
  gists(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: GistOrder
    privacy: GistPrivacy
  ): GistConnection!
  hasSponsorsListing: Boolean!
  hovercard(
    primarySubjectId: ID
  ): Hovercard!
  id: ID!
  interactionAbility: RepositoryInteractionAbility
  isBountyHunter: Boolean!
  isCampusExpert: Boolean!
  isDeveloperProgramMember: Boolean!
  isEmployee: Boolean!
  isFollowingViewer: Boolean!
  isGitHubStar: Boolean!
  isHireable: Boolean!
  isSiteAdmin: Boolean!
  isSponsoredBy(
    accountLogin: String!
  ): Boolean!
  isSponsoringViewer: Boolean!
  isViewer: Boolean!
  issueComments(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: IssueCommentOrder
  ): IssueCommentConnection!
  issues(
    after: String
    before: String
    filterBy: IssueFilters
    first: Int
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [IssueState!]
  ): IssueConnection!
  itemShowcase: ProfileItemShowcase!
  location: String
  login: String!
  monthlyEstimatedSponsorsIncomeInCents: Int!
  name: String
  organization(
    login: String!
  ): Organization
  organizationVerifiedDomainEmails(
    login: String!
  ): [String!]!
  organizations(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: OrganizationOrder = null
  ): OrganizationConnection!
  packages(
    after: String
    before: String
    first: Int
    last: Int
    names: [String]
    orderBy: PackageOrder = {field: CREATED_AT, direction: DESC}
    packageType: PackageType
    repositoryId: ID
  ): PackageConnection!
  pinnableItems(
    after: String
    before: String
    first: Int
    last: Int
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  pinnedItems(
    after: String
    before: String
    first: Int
    last: Int
    types: [PinnableItemType!]
  ): PinnableItemConnection!
  pinnedItemsRemaining: Int!
  project(
    number: Int!
  ): Project
  projectV2(
    number: Int!
  ): ProjectV2
  projects(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectOrder
    search: String
    states: [ProjectState!]
  ): ProjectConnection!
  projectsResourcePath: URI!
  projectsUrl: URI!
  projectsV2(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProjectV2Order = {field: NUMBER, direction: DESC}
    query: String
  ): ProjectV2Connection!
  pronouns: String
  publicKeys(
    after: String
    before: String
    first: Int
    last: Int
  ): PublicKeyConnection!
  pullRequests(
    after: String
    baseRefName: String
    before: String
    first: Int
    headRefName: String
    labels: [String!]
    last: Int
    orderBy: IssueOrder
    states: [PullRequestState!]
  ): PullRequestConnection!
  recentProjects(
    after: String
    before: String
    first: Int
    last: Int
  ): ProjectV2Connection!
  repositories(
    affiliations: [RepositoryAffiliation]
    after: String
    before: String
    first: Int
    hasIssuesEnabled: Boolean
    isArchived: Boolean
    isFork: Boolean
    isLocked: Boolean
    last: Int
    orderBy: RepositoryOrder
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  repositoriesContributedTo(
    after: String
    before: String
    contributionTypes: [RepositoryContributionType]
    first: Int
    hasIssues: Boolean
    includeUserRepositories: Boolean
    isLocked: Boolean
    last: Int
    orderBy: RepositoryOrder
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  repository(
    followRenames: Boolean = true
    name: String!
  ): Repository
  repositoryDiscussionComments(
    after: String
    before: String
    first: Int
    last: Int
    onlyAnswers: Boolean = false
    repositoryId: ID
  ): DiscussionCommentConnection!
  repositoryDiscussions(
    after: String
    answered: Boolean = null
    before: String
    first: Int
    last: Int
    orderBy: DiscussionOrder = {field: CREATED_AT, direction: DESC}
    repositoryId: ID
    states: [DiscussionState!] = []
  ): DiscussionConnection!
  resourcePath: URI!
  savedReplies(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SavedReplyOrder = {field: UPDATED_AT, direction: DESC}
  ): SavedReplyConnection
  socialAccounts(
    after: String
    before: String
    first: Int
    last: Int
  ): SocialAccountConnection!
  sponsoring(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SponsorOrder = {field: RELEVANCE, direction: DESC}
  ): SponsorConnection!
  sponsors(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SponsorOrder = {field: RELEVANCE, direction: DESC}
    tierId: ID
  ): SponsorConnection!
  sponsorsActivities(
    actions: [SponsorsActivityAction!] = []
    after: String
    before: String
    first: Int
    includeAsSponsor: Boolean = false
    includePrivate: Boolean = true
    last: Int
    orderBy: SponsorsActivityOrder = {field: TIMESTAMP, direction: DESC}
    period: SponsorsActivityPeriod = MONTH
    since: DateTime
    until: DateTime
  ): SponsorsActivityConnection!
  sponsorsListing: SponsorsListing
  sponsorshipForViewerAsSponsor(
    activeOnly: Boolean = true
  ): Sponsorship
  sponsorshipForViewerAsSponsorable(
    activeOnly: Boolean = true
  ): Sponsorship
  sponsorshipNewsletters(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SponsorshipNewsletterOrder = {field: CREATED_AT, direction: DESC}
  ): SponsorshipNewsletterConnection!
  sponsorshipsAsMaintainer(
    activeOnly: Boolean = true
    after: String
    before: String
    first: Int
    includePrivate: Boolean = false
    last: Int
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  sponsorshipsAsSponsor(
    activeOnly: Boolean = true
    after: String
    before: String
    first: Int
    last: Int
    maintainerLogins: [String!]
    orderBy: SponsorshipOrder
  ): SponsorshipConnection!
  starredRepositories(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: StarOrder
    ownedByViewer: Boolean
  ): StarredRepositoryConnection!
  status: UserStatus
  topRepositories(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: RepositoryOrder!
    since: DateTime
  ): RepositoryConnection!
  totalSponsorshipAmountAsSponsorInCents(
    since: DateTime
    sponsorableLogins: [String!] = []
    until: DateTime
  ): Int
  twitterUsername: String
  updatedAt: DateTime!
  url: URI!
  viewerCanChangePinnedItems: Boolean!
  viewerCanCreateProjects: Boolean!
  viewerCanFollow: Boolean!
  viewerCanSponsor: Boolean!
  viewerIsFollowing: Boolean!
  viewerIsSponsoring: Boolean!
  watching(
    affiliations: [RepositoryAffiliation]
    after: String
    before: String
    first: Int
    hasIssuesEnabled: Boolean
    isLocked: Boolean
    last: Int
    orderBy: RepositoryOrder
    ownerAffiliations: [RepositoryAffiliation] = [OWNER, COLLABORATOR]
    privacy: RepositoryPrivacy
  ): RepositoryConnection!
  websiteUrl: URI
}
enum UserBlockDuration {
  ONE_DAY
  ONE_MONTH
  ONE_WEEK
  PERMANENT
  THREE_DAYS
}
type UserBlockedEvent implements Node {
  actor: Actor
  blockDuration: UserBlockDuration!
  createdAt: DateTime!
  id: ID!
  subject: User
}
type UserConnection {
  edges: [UserEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}
type UserContentEdit implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  deletedBy: Actor
  diff: String
  editedAt: DateTime!
  editor: Actor
  id: ID!
  updatedAt: DateTime!
}
type UserContentEditConnection {
  edges: [UserContentEditEdge]
  nodes: [UserContentEdit]
  pageInfo: PageInfo!
  totalCount: Int!
}
type UserContentEditEdge {
  cursor: String!
  node: UserContentEdit
}
type UserEdge {
  cursor: String!
  node: User
}
type UserEmailMetadata {
  primary: Boolean
  type: String
  value: String!
}
type UserStatus implements Node {
  createdAt: DateTime!
  emoji: String
  emojiHTML: HTML
  expiresAt: DateTime
  id: ID!
  indicatesLimitedAvailability: Boolean!
  message: String
  organization: Organization
  updatedAt: DateTime!
  user: User!
}
type UserStatusConnection {
  edges: [UserStatusEdge]
  nodes: [UserStatus]
  pageInfo: PageInfo!
  totalCount: Int!
}
type UserStatusEdge {
  cursor: String!
  node: UserStatus
}
input UserStatusOrder {
  direction: OrderDirection!
  field: UserStatusOrderField!
}
enum UserStatusOrderField {
  UPDATED_AT
}
type VerifiableDomain implements Node {
  createdAt: DateTime!
  databaseId: Int
  dnsHostName: URI
  domain: URI!
  hasFoundHostName: Boolean!
  hasFoundVerificationToken: Boolean!
  id: ID!
  isApproved: Boolean!
  isRequiredForPolicyEnforcement: Boolean!
  isVerified: Boolean!
  owner: VerifiableDomainOwner!
  punycodeEncodedDomain: URI!
  tokenExpirationTime: DateTime
  updatedAt: DateTime!
  verificationToken: String
}
type VerifiableDomainConnection {
  edges: [VerifiableDomainEdge]
  nodes: [VerifiableDomain]
  pageInfo: PageInfo!
  totalCount: Int!
}
type VerifiableDomainEdge {
  cursor: String!
  node: VerifiableDomain
}
input VerifiableDomainOrder {
  direction: OrderDirection!
  field: VerifiableDomainOrderField!
}
enum VerifiableDomainOrderField {
  CREATED_AT
  DOMAIN
}
union VerifiableDomainOwner = Enterprise | Organization
input VerifyVerifiableDomainInput {
  clientMutationId: String
  id: ID! @possibleTypes(concreteTypes: ["VerifiableDomain"])
}
type VerifyVerifiableDomainPayload {
  clientMutationId: String
  domain: VerifiableDomain
}
type ViewerHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
  viewer: User!
}
interface Votable {
  upvoteCount: Int!
  viewerCanUpvote: Boolean!
  viewerHasUpvoted: Boolean!
}
type Workflow implements Node & UniformResourceLocatable {
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  name: String!
  resourcePath: URI!
  runs(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: WorkflowRunOrder = {field: CREATED_AT, direction: DESC}
  ): WorkflowRunConnection!
  state: WorkflowState!
  updatedAt: DateTime!
  url: URI!
}
type WorkflowRun implements Node & UniformResourceLocatable {
  checkSuite: CheckSuite!
  createdAt: DateTime!
  databaseId: Int
  deploymentReviews(
    after: String
    before: String
    first: Int
    last: Int
  ): DeploymentReviewConnection!
  event: String!
  file: WorkflowRunFile
  id: ID!
  pendingDeploymentRequests(
    after: String
    before: String
    first: Int
    last: Int
  ): DeploymentRequestConnection!
  resourcePath: URI!
  runNumber: Int!
  updatedAt: DateTime!
  url: URI!
  workflow: Workflow!
}
type WorkflowRunConnection {
  edges: [WorkflowRunEdge]
  nodes: [WorkflowRun]
  pageInfo: PageInfo!
  totalCount: Int!
}
type WorkflowRunEdge {
  cursor: String!
  node: WorkflowRun
}
type WorkflowRunFile implements Node & UniformResourceLocatable {
  id: ID!
  path: String!
  repositoryFileUrl: URI!
  repositoryName: URI!
  resourcePath: URI!
  run: WorkflowRun!
  url: URI!
  viewerCanPushRepository: Boolean!
  viewerCanReadRepository: Boolean!
}
input WorkflowRunOrder {
  direction: OrderDirection!
  field: WorkflowRunOrderField!
}
enum WorkflowRunOrderField {
  CREATED_AT
}
enum WorkflowState {
  ACTIVE
  DELETED
  DISABLED_FORK
  DISABLED_INACTIVITY
  DISABLED_MANUALLY
}
scalar X509Certificate